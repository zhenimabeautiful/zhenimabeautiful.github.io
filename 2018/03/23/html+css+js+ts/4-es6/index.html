<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#3367D6"/>
  <link rel="apple-touch-icon" href="/icons-192.png">
  <link rel="manifest" href="/manifest.json">
  
  <!--latex数学显示公式支持-->
  

  <meta name="generator" content="Hexo 6.2.0">

  

  

  
    <meta name="author" content="John Doe">
  

  

  

  <title>ES 2015~2019 | Hexo</title>

  

  
    <link rel="shortcut icon" href="/favicon.ico">
  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@1.1.3/index.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlightjs@9.16.2/styles/monokai.css">
  

  
<link rel="stylesheet" href="/css/style.css">

<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>
<body>
  <div class="root-container">
    
<!-- header container -->
<header class="header-container post">
  
    <div class="post-image" style="background-image: url(https://qiniu.sukoshi.xyz/src/images/68686407_p0.jpg)"></div>
  

  <!-- navbar -->
<nav class="navbar">
  <div class="navbar-content">
    <!-- logo -->
    <div class="navbar-logo">
      <a href="/">
        
          小仙女博客
        
      </a>
    </div>
    <!-- link -->
    <div class="navbar-link">
      <div class="navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      <!-- </div>
      <ul class="navbar-list">
        
          <li class="navbar-list-item"><a href="/">首页</a></li>
        
          <li class="navbar-list-item"><a href="/links">友链</a></li>
        
          <li class="navbar-list-item"><a href="/about">关于</a></li>
        
      </ul>
    </div> -->
  </div>
</nav>

  
  

  
  

  
  

  
  

  
  
    <div class="header-content">
      <div class="post-text layout-block">
        <div class="layout-margin">
          <h1 class="title-wrap">ES 2015~2019</h1>
          <h2 class="title-sub-wrap">
            <strong>John Doe</strong>
            <span>发布于</span>
            <time  class="article-date" datetime="2018-03-23T07:26:54.000Z" itemprop="datePublished">2018-03-23</time>
          </h2>
          <ul class="wrap-list dark">
  
    <li><a href="/categories/%E5%89%8D%E7%AB%AF/">📒 前端</a></li>
  
</ul>
          <ul class="wrap-list dark">
  
    <li><a href="/tags/es6/">🏷️ es6</a></li>
  
</ul>
        </div>
      </div>
    </div>
  

  
  
  
</header>

    <!-- 文章 -->

<!-- 文章内容 -->
<div class="body-container">
  <article class="content-container layout-block post-container">
    <div class="article-info">
      
      
      
      
      <section class="article-entry markdown-body layout-margin content-padding--large soft-size--large soft-style--box">
        <p><img src="https://poetries1.gitee.io/img-repo/2019/11/123.png"></p>
<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><ul>
<li><code>ES6</code>是<code>ECMA</code>为<code>JavaScript</code>制定的第6个标准版本</li>
<li>标准委员会最终决定，标准在每年6月正式发布并作为当年的正式版本，接下来的时间里就在此版本的基础上进行改动，直到下一年6月草案就自然变成新一年的版本，这样一来就无需以前的版本号，只要用年份标记即可。<code>ECMAscript 2015</code>是在2015年6月发布ES6的第一个版本。以此类推，<code>ECMAscript</code> 2016是ES6的第二个版本、 ECMAscript 2017是ES6的第三个版本。ES6既是一个历史名词也是一个泛指，含义是5.1版本以后的JavaScript下一代标准，目前涵盖了<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>、<code>ES2019</code></li>
</ul>
<blockquote>
<p>所以有些文章上提到的ES7(实质上是ES2016)、ES8(实质上是ES2017)、ES9(实质上是ES2018)、ES10(实质上是ES2019)，实质上都是一些不规范的概念。从ES1到ES6，每个标准都是花了好几年甚至十多年才制定下来，你一个ES6到ES7，ES7到ES8，才用了一年，按照这样的定义下去，那不是很快就ES20了。用正确的概念来说ES6目前涵盖了ES2015、ES2016、ES2017、ES2018、ES2019</p>
</blockquote>
<p><img src="https://poetries1.gitee.io/img-repo/2019/11/124.png" alt="img"></p>
<h2 id="二、ES2015"><a href="#二、ES2015" class="headerlink" title="二、ES2015"></a>二、ES2015</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/11/125.png" alt="img"></p>
<h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ul>
<li><code>const</code>命令：声明常量</li>
<li><code>let</code>命令：声明变量</li>
</ul>
<blockquote>
<p>作用</p>
</blockquote>
<p><strong>作用域</strong></p>
<ul>
<li>全局作用域</li>
<li>函数作用域：<code>function() &#123;&#125;</code></li>
<li>块级作用域：<code>&#123;&#125;</code></li>
</ul>
<p><strong>作用范围</strong></p>
<ul>
<li><code>var</code>命令在全局代码中执行</li>
<li><code>const</code>命令和<code>let</code>命令只能在代码块中执行</li>
</ul>
<p><strong>赋值使用</strong></p>
<ul>
<li><code>const</code>命令声明常量后必须立马赋值</li>
<li><code>let</code>命令声明变量后可立马赋值或使用时赋值</li>
</ul>
<blockquote>
<p>声明方法：<code>var</code>、<code>const</code>、<code>let</code>、<code>function</code>、<code>class</code>、<code>import</code></p>
</blockquote>
<p><strong>重点难点</strong></p>
<ul>
<li>不允许重复声明</li>
<li>未定义就使用会报错：<code>const</code>命令和<code>let</code>命令不存在变量提升</li>
<li>暂时性死区：在代码块内使用let命令声明变量之前，该变量都不可用</li>
</ul>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><ul>
<li>字符串解构：<code>const [a, b, c, d, e] = &quot;hello&quot;</code></li>
<li>数值解构：<code>const &#123; toString: s &#125; = 123</code></li>
<li>布尔值解构：<code>const &#123; toString: b &#125; = true</code></li>
</ul>
<p><strong>对象解构</strong></p>
<ul>
<li>形式：<code>const &#123; x, y &#125; = &#123; x: 1, y: 2 &#125;</code></li>
<li>默认：<code>const &#123; x, y = 2 &#125; = &#123; x: 1 &#125;</code></li>
<li>改名：<code>const &#123; x, y: z &#125; = &#123; x: 1, y: 2 &#125;</code></li>
</ul>
<p><strong>数组解构</strong></p>
<ul>
<li>规则：数据结构具有<code>Iterator</code>接口可采用数组形式的解构赋值</li>
<li>形式：<code>const [x, y] = [1, 2]</code></li>
<li>默认：<code>const [x, y = 2] = [1]</code></li>
</ul>
<p><strong>函数参数解构</strong></p>
<ul>
<li>数组解构：<code>function Func([x = 0, y = 1]) &#123;&#125;</code></li>
<li>对象解构：<code>function Func(&#123; x = 0, y = 1 &#125; = &#123;&#125;) &#123;&#125;</code></li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>交换变量值：<code>[x, y] = [y, x]</code></li>
<li>返回函数多个值：<code>const [x, y, z] = Func()</code></li>
<li>定义函数参数：<code>Func([1, 2])</code></li>
<li>提取JSON数据：<code>const &#123; name, version &#125; = packageJson</code></li>
<li>定义函数参数默认值：<code>function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;</code></li>
<li>遍历Map结构：<code>for (let [k, v] of Map) &#123;&#125;</code></li>
<li>输入模块指定属性和方法：<code>const &#123; readFile, writeFile &#125; = require(&quot;fs&quot;)</code></li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>匹配模式：只要等号两边的模式相同，左边的变量就会被赋予对应的值</li>
<li>解构赋值规则：只要等号右边的值不是对象或数组，就先将其转为对象</li>
<li>解构默认值生效条件：属性值严格等于undefined</li>
<li>解构遵循匹配模式</li>
<li>解构不成功时变量的值等于<code>undefined</code></li>
<li><code>undefined</code>和<code>null</code>无法转为对象，因此无法进行解构</li>
</ul>
<h3 id="字符串扩展"><a href="#字符串扩展" class="headerlink" title="字符串扩展"></a>字符串扩展</h3><ul>
<li><code>Unicode</code>表示法：大括号包含表示<code>Unicode</code>字符(<code>\u&#123;0xXX&#125;</code>或<code>\u&#123;0XXX&#125;</code>)</li>
<li>字符串遍历：可通过for-of遍历字符串</li>
<li>字符串模板：可单行可多行可插入变量的增强版字符串</li>
<li>标签模板：函数参数的特殊调用</li>
<li><code>String.raw()</code>：返回把字符串所有变量替换且对斜杠进行转义的结果</li>
<li><code>String.fromCodePoint()</code>：返回码点对应字符</li>
<li><code>codePointAt()</code>：返回字符对应码点(<code>String.fromCodePoint()</code>的逆操作)</li>
<li><code>normalize()</code>：把字符的不同表示方法统一为同样形式，返回新字符串(Unicode正规化)</li>
<li><code>repeat()</code>：把字符串重复n次，返回新字符串</li>
<li><code>matchAll()</code>：返回正则表达式在字符串的所有匹配</li>
<li><code>includes()</code>：是否存在指定字符串</li>
<li><code>startsWith()</code>：是否存在字符串头部指定字符串</li>
<li><code>endsWith()</code>：是否存在字符串尾部指定字符串</li>
</ul>
<p><strong>重点难点</strong></p>
<blockquote>
<p>以上扩展方法均可作用于由4个字节储存的<code>Unicode</code>字符上</p>
</blockquote>
<h3 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h3><ul>
<li>二进制表示法：0b或0B开头表示二进制(<code>0bXX</code>或<code>0BXX</code>)</li>
<li>八进制表示法：0o或0O开头表示二进制(<code>0oXX</code>或<code>0OXX</code>)</li>
<li><code>Number.EPSILON</code>：数值最小精度</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：最小安全数值(<code>-2^53</code>)</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：最大安全数值(<code>2^53</code>)</li>
<li><code>Number.parseInt()</code>：返回转换值的整数部分</li>
<li><code>Number.parseFloat()</code>：返回转换值的浮点数部分</li>
<li><code>Number.isFinite()</code>：是否为有限数值</li>
<li><code>Number.isNaN()</code>：是否为<code>NaN</code></li>
<li><code>Number.isInteger()</code>：是否为整数</li>
<li><code>Number.isSafeInteger()</code>：是否在数值安全范围内</li>
<li><code>Math.trunc()</code>：返回数值整数部分</li>
<li><code>Math.sign()</code>：返回数值类型(正数1、负数-1、零0)</li>
<li><code>Math.cbrt()</code>：返回数值立方根</li>
<li><code>Math.clz32()</code>：返回数值的32位无符号整数形式</li>
<li><code>Math.imul()</code>：返回两个数值相乘</li>
<li><code>Math.fround()</code>：返回数值的32位单精度浮点数形式</li>
<li><code>Math.hypot()</code>：返回所有数值平方和的平方根</li>
<li><code>Math.expm1()</code>：返回<code>e^n - 1</code></li>
<li><code>Math.log1p()</code>：返回<code>1 + n</code>的自然对数(<code>Math.log(1 + n)</code>)</li>
<li><code>Math.log10()</code>：返回以10为底的n的对数</li>
<li><code>Math.log2()</code>：返回以2为底的n的对数</li>
<li><code>Math.sinh()</code>：返回n的双曲正弦</li>
<li><code>Math.cosh()</code>：返回n的双曲余弦</li>
<li><code>Math.tanh()</code>：返回n的双曲正切</li>
<li><code>Math.asinh()</code>：返回n的反双曲正弦</li>
<li><code>Math.acosh()</code>：返回n的反双曲余弦</li>
<li><code>Math.atanh()</code>：返回n的反双曲正切</li>
</ul>
<h3 id="对象扩展"><a href="#对象扩展" class="headerlink" title="对象扩展"></a>对象扩展</h3><ul>
<li>简洁表示法：直接写入变量和函数作为对象的属性和方法<code>(&#123; prop, method() &#123;&#125; &#125;)</code></li>
<li>属性名表达式：字面量定义对象时使用[]定义键(<code>[prop]</code>，不能与上同时使用)</li>
<li>方法的name属性：返回方法函数名<ul>
<li>取值函数(<code>getter</code>)和存值函数(<code>setter</code>)：<code>get/set</code>函数名(属性的描述对象在get和set上)</li>
<li><code>bind</code>返回的函数：<code>bound</code> 函数名</li>
<li><code>Function</code>构造函数返回的函数实例：<code>anonymous</code></li>
</ul>
</li>
<li>属性的可枚举性和遍历：描述对象的<code>enumerable</code></li>
<li><code>super</code>关键字：指向当前对象的原型对象(只能用在对象的简写方法中<code>method() &#123;&#125;</code>)</li>
<li><code>Object.is()</code>：对比两值是否相等</li>
<li><code>Object.assign()</code>：合并对象(浅拷贝)，返回原对象</li>
<li><code>Object.getPrototypeOf()</code>：返回对象的原型对象</li>
<li><code>Object.setPrototypeOf()</code>：设置对象的原型对象</li>
<li><code>__proto__</code>：返回或设置对象的原型对象</li>
</ul>
<p><strong>属性遍历</strong></p>
<ul>
<li>描述：自身、可继承、可枚举、非枚举、<code>Symbol</code></li>
<li>遍历<ul>
<li><code>for-in</code>：遍历对象自身可继承可枚举属性</li>
<li><code>Object.keys()</code>：返回对象自身可枚举属性的键组成的数组</li>
<li><code>Object.getOwnPropertyNames()</code>：返回对象自身可继承可枚举非枚举属性的键组成的数组</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象<code>Symbol</code>属性的键组成的数组</li>
<li><code>Reflect.ownKeys()</code>：返回对象自身可继承可枚举非枚举Symbol属性的键组成的数组</li>
</ul>
</li>
<li>规则<ul>
<li>首先遍历所有数值键，按照数值升序排列</li>
<li>其次遍历所有字符串键，按照加入时间升序排列</li>
<li>最后遍历所有<code>Symbol</code>键，按照加入时间升序排列</li>
</ul>
</li>
</ul>
<h3 id="数组扩展"><a href="#数组扩展" class="headerlink" title="数组扩展"></a>数组扩展</h3><ul>
<li><p>扩展运算符(<code>...</code>)：转换数组为用逗号分隔的参数序列(<code>[...arr]</code>，相当于<code>rest/spread</code>参数的逆运算)</p>
</li>
<li><pre><code>Array.from()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">：转换具有</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Iterator
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  接口的数据结构为真正数组，返回新数组</span><br><span class="line"></span><br><span class="line">  - 类数组对象：包含`length`的对象、`Arguments`对象、`NodeList`对象</span><br><span class="line">  - 可遍历对象：`String`、`Set`结构、`Map`结构、`Generator`函数</span><br><span class="line"></span><br><span class="line">- `Array.of()`：转换一组值为真正数组，返回新数组</span><br><span class="line"></span><br><span class="line">- `copyWithin()`：把指定位置的成员复制到其他位置，返回原数组</span><br><span class="line"></span><br><span class="line">- `find()`：返回第一个符合条件的成员</span><br><span class="line"></span><br><span class="line">- `findIndex()`：返回第一个符合条件的成员索引值</span><br><span class="line"></span><br><span class="line">- `fill()`：根据指定值填充整个数组，返回原数组</span><br><span class="line"></span><br><span class="line">- `keys()`：返回以索引值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- `values()`：返回以属性值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- `entries()`：返回以索引值和属性值为遍历器的对象</span><br><span class="line"></span><br><span class="line">- 数组空位：ES6明确将数组空位转为`undefined`(空位处理规不一，建议避免出现)</span><br><span class="line"></span><br><span class="line">**扩展应用**</span><br><span class="line"></span><br><span class="line">- 克隆数组：`const arr = [...arr1]`</span><br><span class="line">- 合并数组：`const arr = [...arr1, ...arr2]`</span><br><span class="line">- 拼接数组：`arr.push(...arr1)`</span><br><span class="line">- 代替`apply`：`Math.max.apply(null, [x, y]) =&gt; Math.max(...[x, y])`</span><br><span class="line">- 转换字符串为数组：`[...&quot;hello&quot;]`</span><br><span class="line">- 转换类数组对象为数组：`[...Arguments, ...NodeList]`</span><br><span class="line">- 转换可遍历对象为数组：`[...String, ...Set, ...Map, ...Generator]`</span><br><span class="line">- 与数组解构赋值结合：`const [x, ...rest/spread] = [1, 2, 3]`</span><br><span class="line">- 计算`Unicode`字符长度：`Array.from(&quot;hello&quot;).length =&gt; [...&quot;hello&quot;].length`</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 使用`keys()`、`values()`、`entries()`返回的遍历器对象，可用`for-of`自动遍历或`next()`手动遍历</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 参数默认值：为函数参数指定默认值</span><br><span class="line"></span><br><span class="line">  - 形式：`function Func(x = 1, y = 2) &#123;&#125;`</span><br><span class="line">  - 参数赋值：惰性求值(函数调用后才求值)</span><br><span class="line">  - 参数位置：尾参数</span><br><span class="line">  - 参数作用域：函数作用域</span><br><span class="line">  - 声明方式：默认声明，不能用`const`或`let`再次声明</span><br><span class="line">  - `length`：返回没有指定默认值的参数个数</span><br><span class="line">  - 与解构赋值默认值结合：`function Func(&#123; x = 1, y = 2 &#125; = &#123;&#125;) &#123;&#125;`</span><br><span class="line">  - 应用</span><br><span class="line">    - 指定某个参数不得省略，省略即抛出错误：`function Func(x = throwMissing()) &#123;&#125;`</span><br><span class="line">    - 将参数默认值设为`undefined`，表明此参数可省略：`Func(undefined, 1)`</span><br><span class="line"></span><br><span class="line">- rest/spread参数(…)：返回函数多余参数</span><br><span class="line"></span><br><span class="line">  - 形式：以数组的形式存在，之后不能再有其他参数</span><br><span class="line">  - 作用：代替`Arguments`对象</span><br><span class="line">  - `length`：返回没有指定默认值的参数个数但不包括`rest/spread`参数</span><br><span class="line"></span><br><span class="line">- 严格模式：在严格条件下运行JS</span><br><span class="line"></span><br><span class="line">  - 应用：只要函数参数使用默认值、解构赋值、扩展运算符，那么函数内部就不能显式设定为严格模式</span><br><span class="line"></span><br><span class="line">- name属性</span><br><span class="line"></span><br><span class="line">  ：返回函数的函数名</span><br><span class="line"></span><br><span class="line">  - 将匿名函数赋值给变量：空字符串(ES5)、变量名(ES6)</span><br><span class="line">  - 将具名函数赋值给变量：函数名(ES5和ES6)</span><br><span class="line">  - `bind`返回的函数：`bound` 函数名(ES5和ES6)</span><br><span class="line">  - `Function`构造函数返回的函数实例：`anonymous`(ES5和ES6)</span><br><span class="line"></span><br><span class="line">- 箭头函数(=&gt;)：函数简写</span><br><span class="line"></span><br><span class="line">  - 无参数：`() =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 单个参数：`x =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 多个参数：`(x, y) =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 解构参数：`(&#123;x, y&#125;) =&gt; &#123;&#125;`</span><br><span class="line"></span><br><span class="line">  - 嵌套使用：部署管道机制</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    this</span><br></pre></td></tr></table></figure>

  指向固定化

  - 并非因为内部有绑定`this`的机制，而是根本没有自己的`this`，导致内部的`this`就是外层代码块的`this`
  - 因为没有`this`，因此不能用作构造函数
</code></pre>
</li>
<li><p>尾调用优化：只保留内层函数的调用帧</p>
<ul>
<li>尾调用<ul>
<li>定义：某个函数的最后一步是调用另一个函数</li>
<li>形式：<code>function f(x) &#123; return g(x); &#125;</code></li>
</ul>
</li>
<li>尾递归<ul>
<li>定义：函数尾调用自身</li>
<li>作用：只要使用尾递归就不会发生栈溢出，相对节省内存</li>
<li>实现：把所有用到的内部变量改写成函数的参数并使用参数默认值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>箭头函数误区</strong></p>
<ul>
<li>函数体内的<code>this</code>是定义时所在的对象而不是使用时所在的对象</li>
<li>可让<code>this</code>指向固定化，这种特性很有利于封装回调函数</li>
<li>不可当作构造函数，因此箭头函数不可使用<code>new</code>命令</li>
<li>不可使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li>
<li>不可使用<code>Arguments</code>对象，此对象在函数体内不存在(可用<code>rest/spread</code>参数代替)</li>
<li>返回对象时必须在对象外面加上括号</li>
</ul>
<h3 id="正则扩展"><a href="#正则扩展" class="headerlink" title="正则扩展"></a>正则扩展</h3><ul>
<li><p><strong>变更<code>RegExp</code>构造函数入参</strong>：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符)</p>
</li>
<li><p><strong>正则方法调用变更</strong>：字符串对象的<code>match()</code>、<code>replace()</code>、<code>search()</code>、<code>split()</code>内部调用转为调用<code>RegExp</code>实例对应的<code>RegExp.prototype[Symbol.方法]</code></p>
</li>
<li><p>u修饰符</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode</span><br></pre></td></tr></table></figure>

<p>模式修饰符，正确处理大于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\uFFFF</span><br></pre></td></tr></table></figure>

<p>的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unicode</span><br></pre></td></tr></table></figure>

<p>字符</p>
<ul>
<li>点字符(<code>.</code>)</li>
<li><code>Unicode</code>表示法</li>
<li>量词</li>
<li>预定义模式</li>
<li><code>i</code>修饰符</li>
<li>转义</li>
</ul>
</li>
<li><p><strong>y修饰符</strong>：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似)</p>
</li>
<li><p><strong>unicode</strong>：是否设置<code>u</code>修饰符</p>
</li>
<li><p><strong>sticky</strong>：是否设置<code>y</code>修饰符</p>
</li>
<li><p><strong>flags</strong>：正则表达式的修饰符</p>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li><code>y</code>修饰符隐含头部匹配标志<code>^</code></li>
<li>单单一个y修饰符对<code>match()</code>只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配</li>
</ul>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul>
<li>定义：独一无二的值</li>
<li>声明：<code>const set = Symbol(str)</code></li>
<li>入参：字符串(可选)</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li><code>Symbol()</code>：创建以参数作为描述的Symbol值(不登记在全局环境)</li>
<li><code>Symbol.for()</code>：创建以参数作为描述的Symbol值，如存在此参数则返回原有的Symbol值(先搜索后创建，登记在全局环境)</li>
<li><code>Symbol.keyFor()</code>：返回已登记的<code>Symbol</code>值的描述(只能返回<code>Symbol.for()</code>的<code>key</code>)</li>
<li><code>Object.getOwnPropertySymbols()</code>：返回对象中所有用作属性名的<code>Symbol</code>值的数组</li>
</ul>
<p><strong>内置</strong></p>
<ul>
<li><code>Symbol.hasInstance</code>：指向一个内部方法，当其他对象使用<code>instanceof</code>运算符判断是否为此对象的实例时会调用此方法</li>
<li><code>Symbol.isConcatSpreadable</code>：指向一个布尔值，定义对象用于<code>Array.prototype.concat()</code>时是否可展开</li>
<li><code>Symbol.species</code>：指向一个构造函数，当实例对象使用自身构造函数时会调用指定的构造函数</li>
<li><code>Symbol.match</code>：指向一个函数，当实例对象被<code>String.prototype.match()</code>调用时会重新定义<code>match()</code>的行为</li>
<li><code>Symbol.replace</code>：指向一个函数，当实例对象被<code>String.prototype.replace()</code>调用时会重新定义<code>replace()</code>的行为</li>
<li><code>Symbol.search</code>：指向一个函数，当实例对象被<code>String.prototype.search()</code>调用时会重新定义<code>search()</code>的行为</li>
<li><code>Symbol.split</code>：指向一个函数，当实例对象被<code>String.prototype.split()</code>调用时会重新定义<code>split()</code>的行为</li>
<li><code>Symbol.iterator</code>：指向一个默认遍历器方法，当实例对象执行<code>for-of</code>时会调用指定的默认遍历器</li>
<li><code>Symbol.toPrimitive</code>：指向一个函数，当实例对象被转为原始类型的值时会返回此对象对应的原始类型值</li>
<li><code>Symbol.toStringTag</code>：指向一个函数，当实例对象被<code>Object.prototype.toString()</code>调用时其返回值会出现在<code>toString()</code>返回的字符串之中表示对象的类型</li>
<li><code>Symbol.unscopables</code>：指向一个对象，指定使用<code>with</code>时哪些属性会被<code>with</code>环境排除</li>
</ul>
<p><strong>数据类型</strong></p>
<ul>
<li><code>Undefined</code></li>
<li><code>Null</code></li>
<li><code>String</code></li>
<li><code>Number</code></li>
<li><code>Boolean</code></li>
<li><code>Object</code>(包含<code>Array</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code>)</li>
<li><code>Symbol</code></li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>唯一化对象属性名：属性名属于<code>Symbol</code>类型，就都是独一无二的，可保证不会与其他属性名产生冲突</li>
<li>消除魔术字符串：在代码中多次出现且与代码形成强耦合的某一个具体的字符串或数值</li>
<li>遍历属性名：无法通过<code>for-in</code>、<code>for-of</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回，只能通过<code>Object.getOwnPropertySymbols</code>返回<br>启用模块的<code>Singleton</code>模式：调用一个类在任何时候返回同一个实例(<code>window</code>和<code>global</code>)，- 使用<code>Symbol.for()</code>来模拟全局的<code>Singleton</code>模式</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li><code>Symbol()</code>生成一个原始类型的值不是对象，因此<code>Symbol()</code>前不能使用<code>new</code>命令</li>
<li><code>Symbol()</code>参数表示对当前<code>Symbol</code>值的描述，相同参数的<code>Symbol()</code>返回值不相等</li>
<li><code>Symbol</code>值不能与其他类型的值进行运算</li>
<li><code>Symbol</code>值可通过<code>String()</code>或<code>toString()</code>显式转为字符串</li>
<li><code>Symbol</code>值作为对象属性名时，此属性是公开属性，但不是私有属性</li>
<li><code>Symbol</code>值作为对象属性名时，只能用方括号运算符(<code>[]</code>)读取，不能用点运算符(<code>.</code>)读取&#96;</li>
<li><code>Symbol</code>值作为对象属性名时，不会被常规方法遍历得到，可利用此特性为对象定义非私有但又只用于内部的方法</li>
</ul>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><strong>Set</strong></p>
<ul>
<li>定义：类似于数组的数据结构，成员值都是唯一且没有重复的值</li>
<li>声明：<code>const set = new Set(arr)</code></li>
<li>入参：具有<code>Iterator</code>接口的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>Set</code></li>
<li><code>size</code>：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li><code>add()</code>：添加值，返回实例</li>
<li><code>delete()</code>：删除值，返回布尔值</li>
<li><code>has()</code>：检查值，返回布尔值</li>
<li><code>clear()</code>：清除所有成员</li>
<li><code>keys()</code>：返回以属性值为遍历器的对象</li>
<li><code>values()</code>：返回以属性值为遍历器的对象</li>
<li><code>entries()</code>：返回以属性值和属性值为遍历器的对象</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>去重字符串：<code>[...new Set(str)].join(&quot;&quot;)</code></li>
<li>去重数组：<code>[...new Set(arr)]或Array.from(new Set(arr))</code></li>
<li>集合数组<ul>
<li>声明：<code>const a = new Set(arr1)、const b = new Set(arr2)</code></li>
<li>并集：<code>new Set([...a, ...b])</code></li>
<li>交集：<code>new Set([...a].filter(v =&gt; b.has(v)))</code></li>
<li>差集：<code>new Set([...a].filter(v =&gt; !b.has(v)))</code></li>
</ul>
</li>
<li>映射集合<ul>
<li>声明：<code>let set = new Set(arr)</code></li>
<li>映射：<code>set = new Set([...set].map(v =&gt; v * 2))</code>或<code>set = new Set(Array.from(set, v =&gt; v * 2))</code></li>
</ul>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>没有键只有值，可认为键和值两值相等</li>
<li>添加多个<code>NaN</code>时，只会存在一个<code>NaN</code></li>
<li>添加相同的对象时，会认为是不同的对象</li>
<li>添加值时不会发生类型转换<code>(5 !== &quot;5&quot;)</code></li>
<li><code>keys()</code>和<code>values()</code>的行为完全一致，<code>entries()</code>返回的遍历器同时包括键和值且两值相等</li>
</ul>
<p><strong>WeakSet</strong></p>
<ul>
<li>定义：和<code>Set</code>结构类似，成员值只能是对象</li>
<li>声明：<code>const set = new WeakSet(arr)</code></li>
<li>入参：具有&#96;Iterator接口的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakSet</code></li>
</ul>
</li>
<li>方法<ul>
<li><code>add()</code>：添加值，返回实例</li>
<li><code>delete()</code>：删除值，返回布尔值</li>
<li><code>has()</code>：检查值，返回布尔值</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>储存<code>DOM</code>节点：<code>DOM</code>节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在<code>WeakSe</code>t结构中的引用就会自动消</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>成员都是弱引用，垃圾回收机制不考虑<code>WeakSet</code>结构对此成员的引用</li>
<li>成员不适合引用，它会随时消失，因此ES6规定<code>WeakSet</code>结构不可遍历</li>
<li>其他对象不再引用成员时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakSet</code>结构中</li>
</ul>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong>Map</strong></p>
<ul>
<li>定义：类似于对象的数据结构，成员键可以是任何类型的值</li>
<li>声明：<code>const set = new Map(arr)</code></li>
<li>入参：具有<code>Iterator</code>接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>Map</code></li>
<li><code>size</code>：返回实例成员总数</li>
</ul>
</li>
<li>方法<ul>
<li><code>get()</code>：返回键值对</li>
<li><code>set()</code>：添加键值对，返回实例</li>
<li><code>delete()</code>：删除键值对，返回布尔值</li>
<li><code>has()</code>：检查键值对，返回布尔值</li>
<li><code>clear()</code>：清除所有成员</li>
<li><code>keys()</code>：返回以键为遍历器的对象</li>
<li><code>values()</code>：返回以值为遍历器的对象</li>
<li><code>entries()</code>：返回以键和值为遍历器的对象</li>
<li><code>forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>遍历顺序：插入顺序</li>
<li>对同一个键多次赋值，后面的值将覆盖前面的值</li>
<li>对同一个对象的引用，被视为一个键</li>
<li>对同样值的两个实例，被视为两个键</li>
<li>键跟内存地址绑定，只要内存地址不一样就视为两个键</li>
<li>添加多个以<code>NaN</code>作为键时，只会存在一个以<code>NaN</code>作为键的值</li>
<li><code>Object</code>结构提供字符串—值的对应，<code>Map</code>结构提供值—值的对应</li>
</ul>
<p><strong>WeakMap</strong></p>
<ul>
<li>定义：和<code>Map</code>结构类似，成员键只能是对象</li>
<li>声明：<code>const set = new WeakMap(arr)</code></li>
<li>入参：具有Iterator接口且每个成员都是一个双元素数组的数据结构</li>
<li>属性<ul>
<li><code>constructor</code>：构造函数，返回<code>WeakMap</code></li>
</ul>
</li>
<li>方法<ul>
<li><code>get()</code>：返回键值对</li>
<li><code>set()</code>：添加键值对，返回实例</li>
<li><code>delete()</code>：删除键值对，返回布尔值</li>
<li><code>has()</code>：检查键值对，返回布尔值</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>储存DOM节点：DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏</li>
<li>部署私有属性：内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>成员键都是弱引用，垃圾回收机制不考虑<code>WeakMap</code>结构对此成员键的引用</li>
<li>成员键不适合引用，它会随时消失，因此ES6规定<code>WeakMap</code>结构不可遍历</li>
<li>其他对象不再引用成员键时，垃圾回收机制会自动回收此成员所占用的内存，不考虑此成员是否还存在于<code>WeakMap</code>结构中</li>
<li>一旦不再需要，成员会自动消失，不用手动删除引用</li>
<li>弱引用的只是键而不是值，值依然是正常引用</li>
<li>即使在外部消除了成员键的引用，内部的成员值依然存在</li>
</ul>
<h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li>定义：修改某些操作的默认行为</li>
<li>声明：<code>const proxy = new Proxy(target, handler)</code></li>
<li>入参<ul>
<li><code>target</code>：拦截的目标对象</li>
<li><code>handler</code>：定制拦截行为</li>
</ul>
</li>
<li>方法<ul>
<li><code>Proxy.revocable()</code>：返回可取消的<code>Proxy</code>实例(返回<code>&#123; proxy, revoke &#125;</code>，通过<code>revoke()</code>取消代理)</li>
</ul>
</li>
<li>拦截方式<ul>
<li><code>get()</code>：拦截对象属性读取</li>
<li><code>set()</code>：拦截对象属性设置，返回布尔值</li>
<li><code>has()</code>：拦截对象属性检查<code>k in obj</code>，返回布尔值</li>
<li><code>deleteProperty()</code>：拦截对象属性删除<code>delete obj[k]</code>，返回布尔值</li>
<li><code>defineProperty()</code>：拦截对象属性定义<code>Object.defineProperty()</code>、<code>Object.defineProperties()</code>，返回布尔值</li>
<li><code>ownKeys()</code>：拦截对象属性遍历<code>for-in</code>、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()</code>，返回数组</li>
<li><code>getOwnPropertyDescriptor()</code>：拦截对象属性描述读取<code>Object.getOwnPropertyDescriptor()</code>，返回对象</li>
<li><code>getPrototypeOf()</code>：拦截对象原型读取<code>instanceof</code>、<code>Object.getPrototypeOf()</code>、<code>Object.prototype.__proto__</code>、<code>Object.prototype.isPrototypeOf()</code>、<code>Reflect.getPrototypeOf()</code>，返回对象</li>
<li><code>setPrototypeOf()</code>：拦截对象原型设置<code>Object.setPrototypeOf()</code>，返回布尔值</li>
<li><code>isExtensible()</code>：拦截对象是否可扩展读取<code>Object.isExtensible()</code>，返回布尔值</li>
<li><code>preventExtensions()</code>：拦截对象不可扩展设置<code>Object.preventExtensions()</code>，返回布尔值</li>
<li><code>apply()</code>：拦截<code>Proxy</code>实例作为函数调用<code>proxy()</code>、<code>proxy.apply()</code>、<code>proxy.call()</code></li>
<li><code>construct()</code>：拦截<code>Proxy</code>实例作为构造函数调用<code>new proxy()</code></li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li><code>Proxy.revocable()</code>：不允许直接访问对象，必须通过代理访问，一旦访问结束就收回代理权不允许再次访问</li>
<li><code>get()</code>：读取未知属性报错、读取数组负数索引的值、封装链式操作、生成DOM嵌套节点</li>
<li><code>set()</code>：数据绑定(<code>Vue</code>数据绑定实现原理)、确保属性值设置符合要求、防止内部属性被外部读写</li>
<li><code>has()</code>：隐藏内部属性不被发现、排除不符合属性条件的对象</li>
<li><code>deleteProperty()</code>：保护内部属性不被删除</li>
<li><code>defineProperty()</code>：阻止属性被外部定义</li>
<li><code>ownKeys()</code>：保护内部属性不被遍历</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>要使<code>Proxy</code>起作用，必须针对实例进行操作，而不是针对目标对象进行操作</li>
<li>没有设置任何拦截时，等同于直接通向原对象</li>
<li>属性被定义为不可读写&#x2F;扩展&#x2F;配置&#x2F;枚举时，使用拦截方法会报错</li>
<li>代理下的目标对象，内部<code>this</code>指向<code>Proxy</code>代理</li>
</ul>
<h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><ul>
<li>定义：保持<code>Object</code>方法的默认行为</li>
<li>方法<ul>
<li><code>get()</code>：返回对象属性</li>
<li><code>set()</code>：设置对象属性，返回布尔值</li>
<li><code>has()</code>：检查对象属性，返回布尔值</li>
<li><code>deleteProperty()</code>：删除对象属性，返回布尔值</li>
<li><code>defineProperty()</code>：定义对象属性，返回布尔值</li>
<li><code>ownKeys()</code>：遍历对象属性，返回数<code>组(Object.getOwnPropertyNames()+Object.getOwnPropertySymbols())</code></li>
<li><code>getOwnPropertyDescriptor()</code>：返回对象属性描述，返回对象</li>
<li><code>getPrototypeOf()</code>：返回对象原型，返回对象</li>
<li><code>setPrototypeOf()</code>：设置对象原型，返回布尔值</li>
<li><code>isExtensible()</code>：返回对象是否可扩展，返回布尔值</li>
<li><code>preventExtensions()</code>：设置对象不可扩展，返回布尔值</li>
<li><code>apply()</code>：绑定<code>this</code>后执行指定函数</li>
<li><code>construct()</code>：调用构造函数创建实例</li>
</ul>
</li>
</ul>
<p><strong>设计目的</strong></p>
<ul>
<li><code>Object</code>属于语言内部的方法放到<code>Reflect</code>上</li>
<li>将某些<code>Object</code>方法报错情况改成返回<code>false</code></li>
<li>让<code>Object</code>操作变成函数行为</li>
<li><code>Proxy</code>与<code>Reflect</code>相辅相成</li>
</ul>
<p><strong>废弃方法</strong></p>
<ul>
<li><code>Object.defineProperty()</code> &#x3D;&gt; <code>Reflect.defineProperty()</code></li>
<li><code>Object.getOwnPropertyDescriptor()</code> &#x3D;&gt; <code>Reflect.getOwnPropertyDescriptor()</code></li>
</ul>
<blockquote>
<p>数据绑定：观察者模式</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const observerQueue = new Set();</span><br><span class="line">const observe = fn =&gt; observerQueue.add(fn);</span><br><span class="line">const observable = obj =&gt; new Proxy(obj, &#123;</span><br><span class="line">    set(tgt, key, val, receiver) &#123;</span><br><span class="line">        const result = Reflect.set(tgt, key, val, receiver);</span><br><span class="line">        observerQueue.forEach(v =&gt; v());</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const person = observable(&#123; age: 25, name: &quot;Yajun&quot; &#125;);</span><br><span class="line">const print = () =&gt; console.log(`$&#123;person.name&#125; is $&#123;person.age&#125; years old`);</span><br><span class="line">observe(print);</span><br><span class="line">person.name = &quot;Joway&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><ul>
<li><p>定义：对一类具有共同特征的事物的抽象(构造函数语法糖)</p>
</li>
<li><p>原理：类本身指向构造函数，所有方法定义在<code>prototype</code>上，可看作构造函数的另一种写法(<code>Class === Class.prototype.constructor</code>)</p>
</li>
<li><p>方法和关键字</p>
<ul>
<li><code>constructor()</code>：构造函数，<code>new</code>命令生成实例时自动调用</li>
<li><code>extends</code>：继承父类</li>
<li><code>super</code>：新建父类的this</li>
<li><code>static</code>：定义静态属性方法</li>
<li><code>get</code>：取值函数，拦截属性的取值行为</li>
<li><code>set</code>：存值函数，拦截属性的存值行为</li>
</ul>
</li>
<li><p>属性</p>
<ul>
<li><code>__proto__</code>：构造函数的继承(总是指向父类)</li>
<li><code>__proto__.__proto__</code>：子类的原型的原型，即父类的原型(总是指向父类的<code>__proto__</code>)</li>
<li><code>prototype.__proto__</code>：属性方法的继承(总是指向父类的<code>prototype</code>)</li>
</ul>
</li>
<li><p><strong>静态属性</strong>：定义类完成后赋值属性，该属性不会被实例继承，只能通过类来调用</p>
</li>
<li><p><strong>静态方法</strong>：使用static定义方法，该方法不会被实例继承，只能通过类来调用(方法中的this指向类，而不是实例)</p>
</li>
<li><p>继承</p>
<ul>
<li><p>实质</p>
<ul>
<li><p>ES5实质：先创造子类实例的<code>this</code>，再将父类的属性方法添加到<code>this</code>上(<code>Parent.apply(this)</code>)</p>
</li>
<li><p><code>ES6</code>实质：先将父类实例的属性方法加到<code>this</code>上(调用<code>super()</code>)，再用子类构造函数修改<code>this</code></p>
</li>
<li><p>&#96;&#96;&#96;<br>super</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 作为函数调用：只能在构造函数中调用`super()`，内部`this`指向继承的当前子类(`super()`调用后才可在构造函数中使用`this`)</span><br><span class="line">  - 作为对象调用：在普通方法中指向父类的原型对象，在静态方法中指向父类</span><br><span class="line"></span><br><span class="line">- 显示定义：使用`constructor() &#123; super(); &#125;`定义继承父类，没有书写则显示定义</span><br><span class="line"></span><br><span class="line">- 子类继承父类：子类使用父类的属性方法时，必须在构造函数中调用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>super()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">，否则得不到父类的</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>this</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      - 父类静态属性方法可被子类继承</span><br><span class="line">      - 类继承父类后，可从`super`上调用父类静态属性方法</span><br><span class="line"></span><br><span class="line">- 实例</span><br><span class="line"></span><br><span class="line">  ：类相当于实例的原型，所有在类中定义的属性方法都会被实例继承</span><br><span class="line"></span><br><span class="line">  - 显式指定属性方法：使用`this`指定到自身上(使用`Class.hasOwnProperty()`可检测到)</span><br><span class="line">  - 隐式指定属性方法：直接声明定义在对象原型上(使用`Class.__proto__.hasOwnProperty()`可检测到)</span><br><span class="line"></span><br><span class="line">- 表达式</span><br><span class="line"></span><br><span class="line">  - 类表达式：`const Class = class &#123;&#125;`</span><br><span class="line">  - `name`属性：返回紧跟`class`后的类名</span><br><span class="line">  - 属性表达式：`[prop]`</span><br><span class="line">  - `Generator`方法：`* mothod() &#123;&#125;`</span><br><span class="line">  - `Async`方法：`async mothod() &#123;&#125;`</span><br><span class="line"></span><br><span class="line">- this指向</span><br><span class="line"></span><br><span class="line">  ：解构实例属性或方法时会报错</span><br><span class="line"></span><br><span class="line">  - 绑定`this`：`this.mothod = this.mothod.bind(this)`</span><br><span class="line">  - 箭头函数：`this.mothod = () =&gt; this.mothod()`</span><br><span class="line"></span><br><span class="line">- 属性定义位置</span><br><span class="line"></span><br><span class="line">  - 定义在构造函数中并使用`this`指向</span><br><span class="line">  - 定义在类最顶层</span><br><span class="line"></span><br><span class="line">- **`new.target`：确定构造函数是如何调用**</span><br><span class="line"></span><br><span class="line">**原生构造函数**</span><br><span class="line"></span><br><span class="line">- `String()`</span><br><span class="line">- `Number()`</span><br><span class="line">- `Boolean()`</span><br><span class="line">- `Array()`</span><br><span class="line">- `Object()`</span><br><span class="line">- `Function()`</span><br><span class="line">- `Date()`</span><br><span class="line">- `RegExp()`</span><br><span class="line">- `Error()`</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 在实例上调用方法，实质是调用原型上的方法</span><br><span class="line">- `Object.assign()`可方便地一次向类添加多个方法`(Object.assign(Class.prototype, &#123; ... &#125;))`</span><br><span class="line">- 类内部所有定义的方法是不可枚举的(`non-enumerable`)</span><br><span class="line">- 构造函数默认返回实例对象(`this`)，可指定返回另一个对象</span><br><span class="line">- 取值函数和存值函数设置在属性的`Descriptor`对象上</span><br><span class="line">- 类不存在变量提升</span><br><span class="line">- 利用`new.target === Class`写出不能独立使用必须继承后才能使用的类</span><br><span class="line">- 子类继承父类后，`this`指向子类实例，通过`super`对某个属性赋值，赋值的属性会变成子类实例的属性</span><br><span class="line">- 使用`super`时，必须显式指定是作为函数还是作为对象使用</span><br><span class="line">- `extends`不仅可继承类还可继承原生的构造函数</span><br><span class="line"></span><br><span class="line">**私有属性方法**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>const name &#x3D; Symbol(“name”);<br>const print &#x3D; Symbol(“print”);<br>class Person {<br>    constructor(age) {<br>        this[name] &#x3D; “Bruce”;<br>        this.age &#x3D; age;<br>    }<br>    <a href="">print</a> {<br>        console.log(<code>$&#123;this[name]&#125; is $&#123;this.age&#125; years old</code>);<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**继承混合类**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function CopyProperties(target, source) {<br>    for (const key of Reflect.ownKeys(source)) {<br>        if (key !&#x3D;&#x3D; “constructor” &amp;&amp; key !&#x3D;&#x3D; “prototype” &amp;&amp; key !&#x3D;&#x3D; “name”) {<br>            const desc &#x3D; Object.getOwnPropertyDescriptor(source, key);<br>            Object.defineProperty(target, key, desc);<br>        }<br>    }<br>}<br>function MixClass(…mixins) {<br>    class Mix {<br>        constructor() {<br>            for (const mixin of mixins) {<br>                CopyProperties(this, new mixin());<br>            }<br>        }<br>    }<br>    for (const mixin of mixins) {<br>        CopyProperties(Mix, mixin);<br>        CopyProperties(Mix.prototype, mixin.prototype);<br>    }<br>    return Mix;<br>}<br>class Student extends MixClass(Person, Kid) {}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Module</span><br><span class="line"></span><br><span class="line">**命令**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  export</span><br></pre></td></tr></table></figure>

<p>  ：规定模块对外接口</p>
<ul>
<li><p>默认导出：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</p>
</li>
<li><p>单独导出：<code>export const name = &quot;Bruce&quot;</code></p>
</li>
<li><p>按需导出：<code>export &#123; age, name, sex &#125;(推荐)</code></p>
</li>
<li><p>改名导出：<code>export &#123; name as newName &#125;</code></p>
</li>
<li><pre><code>import
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：导入模块内部功能</span><br><span class="line"></span><br><span class="line">  - 默认导入：`import Person from &quot;person&quot;`</span><br><span class="line">  - 整体导入：`import * as Person from &quot;person&quot;`</span><br><span class="line">  - 按需导入：`import &#123; age, name, sex &#125; from &quot;person&quot;`</span><br><span class="line">  - 改名导入：`import &#123; name as newName &#125; from &quot;person&quot;`</span><br><span class="line">  - 自执导入：`import &quot;person&quot;`</span><br><span class="line">  - 复合导入：`import Person, &#123; name &#125; from &quot;person&quot;`</span><br><span class="line"></span><br><span class="line">- 复合模式：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
export
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令和</span><br><span class="line"></span><br></pre></td></tr></table></figure>
import
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  命令结合在一起写成一行，变量实质没有被导入 当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量</span><br><span class="line"></span><br><span class="line">  - 默认导入导出：`export &#123; default &#125; from &quot;person&quot;`</span><br><span class="line">  - 整体导入导出：`export * from &quot;person&quot;`</span><br><span class="line">  - 按需导入导出：`export &#123; age, name, sex &#125; from &quot;person&quot;`</span><br><span class="line">  - 改名导入导出：`export &#123; name as newName &#125; from &quot;person&quot;`</span><br><span class="line">  - 具名改默认导入导出：`export &#123; name as default &#125; from &quot;person&quot;`</span><br><span class="line">  - 默认改具名导入导出：`export &#123; default as name &#125; from &quot;person&quot;`</span><br><span class="line"></span><br><span class="line">- 继承：默认导出和改名导出结合使用可使模块具备继承性</span><br><span class="line"></span><br><span class="line">- 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</span><br><span class="line"></span><br><span class="line">- 严格模式：ES6模块自动采用严格模式(不管模块头部是否添加`use strict`)</span><br><span class="line"></span><br><span class="line">**模块方案**</span><br><span class="line"></span><br><span class="line">- **CommonJS**：用于服务器(动态化依赖)</span><br><span class="line">- **AMD**：用于浏览器(动态化依赖)</span><br><span class="line">- **CMD**：用于浏览器(动态化依赖)</span><br><span class="line">- **UMD**：用于浏览器和服务器(动态化依赖)</span><br><span class="line">- **ESM**：用于浏览器和服务器(静态化依赖)</span><br><span class="line"></span><br><span class="line">**加载方式**</span><br><span class="line"></span><br><span class="line">- 运行时加载</span><br><span class="line">  - 定义：整体加载模块生成一个对象，再从对象上获取需要的属性和方法进行加载(全部加载)</span><br><span class="line">  - 影响：只有运行时才能得到这个对象，导致无法在编译时做静态优化</span><br><span class="line">- **编译时加载**</span><br><span class="line">- 定义：直接从模块中获取需要的属性和方法进行加载(按需加载)</span><br><span class="line">- 影响：在编译时就完成模块加载，效率比其他方案高，但无法引用模块本身(本身不是对象)，可拓展JS高级语法(宏和类型校验)</span><br><span class="line"></span><br><span class="line">**加载实现**</span><br><span class="line"></span><br><span class="line">- 传统加载</span><br><span class="line"></span><br><span class="line">  ：通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&lt;script&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  进行同步或异步加载脚本</span><br><span class="line"></span><br><span class="line">  - 同步加载：``</span><br><span class="line">  - `Defer`异步加载：``(顺序加载，渲染完再执行)</span><br><span class="line">  - `Async`异步加载：``(乱序加载，下载完就执行)</span><br><span class="line"></span><br><span class="line">- **模块加载**：``(默认是`Defer`异步加载)</span><br><span class="line"></span><br><span class="line">**CommonJS和ESM的区别**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  CommonJS</span><br></pre></td></tr></table></figure>

输出值的拷贝，

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESM</span><br></pre></td></tr></table></figure>

输出值的引用

- `CommonJS`一旦输出一个值，模块内部的变化就影响不到这个值
- `ESM`是动态引用且不会缓存值，模块里的变量绑定其所在的模块，等到脚本真正执行时，再根据这个只读引用到被加载的那个模块里去取值
</code></pre>
</li>
<li><pre><code>CommonJS
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是运行时加载，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ESM
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  是编译时加载</span><br><span class="line"></span><br><span class="line">  - `CommonJS`加载模块是对象(即`module.exports`)，该对象只有在脚本运行完才会生成</span><br><span class="line">  - `ESM`加载模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成</span><br><span class="line"></span><br><span class="line">**Node加载**</span><br><span class="line"></span><br><span class="line">- 背景：`CommonJS`和`ESM`互不兼容，目前解决方案是将两者分开，采用各自的加载方案</span><br><span class="line"></span><br><span class="line">- 区分：要求</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ESM
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">采用</span><br><span class="line"></span><br></pre></td></tr></table></figure>
.mjs
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  后缀文件名</span><br><span class="line"></span><br><span class="line">  - `require()`不能加载`.mjs`文件，只有`import`命令才可加载`.mjs`文件</span><br><span class="line">  - `.mjs`文件里不能使用`require()`，必须使用`import`命令加载文件</span><br><span class="line"></span><br><span class="line">- 驱动：`node --experimental-modules file.mjs`</span><br><span class="line"></span><br><span class="line">- 限制：`Node`的`import`命令目前只支持加载本地模块(`file:协`议)，不支持加载远程模块</span><br><span class="line"></span><br><span class="line">- 加载优先级</span><br><span class="line"></span><br><span class="line">  - 脚本文件省略后缀名：依次尝试加载四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)</span><br><span class="line">  - 以上不存在：尝试加载`package.json`的`main`字段指定的脚本</span><br><span class="line">  - 以上不存在：依次尝试加载名称为`index`四个后缀名文件(`.mjs`、`.js`、`.json`、`node`)</span><br><span class="line">  - 以上不存在：报错</span><br><span class="line"></span><br><span class="line">- 不存在的内部变量：`arguments`、`exports`、`module`、`require`、`this`、`__dirname`、`__filename`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  CommonJS</span><br></pre></td></tr></table></figure>

加载

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ESM</span><br></pre></td></tr></table></figure>

- 不能使用`require()`，只能使用`import()`
</code></pre>
</li>
<li><p>&#96;&#96;&#96;<br>ESM</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加载</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CommonJS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 自动将`module.exports`转化成`export default`</span><br><span class="line">  - `CommonJS`输出缓存机制在ESM加载方式下依然有效</span><br><span class="line">  - 采用`import`命令加载`CommonJS`模块时，不允许采用按需导入，应使用默认导入或整体导入</span><br><span class="line"></span><br><span class="line">**循环加载**</span><br><span class="line"></span><br><span class="line">- 定义：脚本`A`的执行依赖脚本`B`，而脚本`A`的执行又依赖脚本B</span><br><span class="line">- 加载原理</span><br><span class="line">  - `CommonJS`：`require()`首次加载脚本就会执行整个脚本，在内存里生成一个对象缓存下来，二次加载脚本时直接从缓存中获取</span><br><span class="line">  - `ESM`：`import`命令加载变量不会被缓存，而是成为一个指向被加载模块的引用</span><br><span class="line">- 循环加载</span><br><span class="line">  - `CommonJS`：只输出已经执行的部分，还未执行的部分不会输出</span><br><span class="line">  - `ESM`：需开发者自己保证真正取值时能够取到值(可把变量写成函数形式，函数具有提升作用)</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- `ES6`模块中，顶层`this`指向`undefined`，不应该在顶层代码使用`this`</span><br><span class="line">- `一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取</span><br><span class="line">- `export`命令输出的接口与其对应的值是动态绑定关系，即通过该接口可获取模块内部实时的值</span><br><span class="line">- `import`命令大括号里的变量名必须与被导入模块对外接口的名称相同</span><br><span class="line">- `import`命令输入的变量只读(本质是输入接口)，不允许在加载模块的脚本里改写接口</span><br><span class="line">- `import`命令命令具有提升效果，会提升到整个模块的头部，首先执行</span><br><span class="line">  重复执行同一句import语句，只会执行一次</span><br><span class="line">- `export default`命令只能使用一次</span><br><span class="line">- `export default`命令导出的整体模块，在执行`import`命令时其后不能跟大括号</span><br><span class="line">- `export default`命令本质是输出一个名为`default`的变量，后面不能跟变量声明语句</span><br><span class="line">- `export default`命令本质是将后面的值赋给名为`default`的变量，可直接将值写在其后</span><br><span class="line">- `export default`命令和`export &#123;&#125;`命令可同时存在，对应复合导入</span><br><span class="line">- `export`命令和`import`命令可出现在模块任何位置，只要处于模块顶层即可，不能处于块级作用域</span><br><span class="line">- `import()`加载模块成功后，此模块会作为一个对象，当作`then()`的参数，可使用对象解构赋值来获取输出接口</span><br><span class="line">- 同时动态加载多个模块时，可使用`Promise.all()`和`import()`相结合来实现</span><br><span class="line">- `import()`和结`合async/await`来书写同步操作的代码</span><br><span class="line"></span><br><span class="line">**单例模式：跨模块常量**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;&#x2F; 常量跨文件共享<br>&#x2F;&#x2F; person.js<br>const NAME &#x3D; “Bruce”;<br>const AGE &#x3D; 25;<br>const SEX &#x3D; “male”;<br>export { AGE, NAME, SEX };<br>&#x2F;&#x2F; file1.js<br>import { AGE } from “person”;<br>console.log(AGE);<br>&#x2F;&#x2F; file2.js<br>import { AGE, NAME, SEX } from “person”;<br>console.log(AGE, NAME, SEX);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 默认导入互换整体导入</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import Person from “person”;<br>console.log(Person.AGE);<br>import * as Person from “person”;<br>console.log(Person.default.AGE);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Iterator</span><br><span class="line"></span><br><span class="line">- 定义：为各种不同的数据结构提供统一的访问机制</span><br><span class="line">- 原理：创建一个指针指向首个成员，按照次序使用`next()`指向下一个成员，直接到结束位置(数据结构只要部署`Iterator`接口就可完成遍历操作)</span><br><span class="line">- 作用</span><br><span class="line">  - 为各种数据结构提供一个统一的简便的访问接口</span><br><span class="line">  - 使得数据结构成员能够按某种次序排列</span><br><span class="line">  - `ES6`创造了新的遍历命令`for-of`，`Iterator`接口主要供`for-of`消费</span><br><span class="line">- 形式：`for-of`(自动去寻找`Iterator`接口)</span><br><span class="line">- 数据结构</span><br><span class="line">  - 集合：`Array`、`Object`、`Set`、`Map`</span><br><span class="line">  - 原生具备接口的数据结构：`String`、`Array`、`Set`、`Map`、`TypedArray`、`Arguments、NodeList`</span><br><span class="line">- 部署：默认部署在`Symbol.iterator`(具备此属性被认为可遍历的`iterable`)</span><br><span class="line">- 遍历器对象</span><br><span class="line">  - `next()`：下一步操作，返回`&#123; done, value &#125;`(必须部署)</span><br><span class="line">  - `return()`：`for-of`提前退出调用，返回`&#123; done: true &#125;`</span><br><span class="line">  - `throw()`：不使用，配合`Generator`函数使用</span><br><span class="line"></span><br><span class="line">**ForOf循环**</span><br><span class="line"></span><br><span class="line">- 定义：调用`Iterator`接口产生遍历器对象(`for-of`内部调用数据结构的`Symbol.iterator()`)</span><br><span class="line"></span><br><span class="line">- 遍历字符串：`for-in`获取索引，`for-of`获取值(可识别32位UTF-16字符)</span><br><span class="line"></span><br><span class="line">- 遍历数组：`for-in`获取索引，`for-of`获取值</span><br><span class="line"></span><br><span class="line">- 遍历对象：`for-in`获取键，`for-of`需自行部署</span><br><span class="line"></span><br><span class="line">- 遍历`Set`：`for-of`获取值 =&gt; `for (const v of set)`</span><br><span class="line"></span><br><span class="line">- 遍历`Map`：`for-of`获取键值对 =&gt; `for (const [k, v] of map)`</span><br><span class="line"></span><br><span class="line">- 遍历类数组：包含`length`的对象、`Arguments`对象、`NodeList`对象(无`Iterator`接口的类数组可用`Array.from()`转换)</span><br><span class="line"></span><br><span class="line">- 计算生成数据结构：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Set</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Map</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - `keys()`：返回遍历器对象，遍历所有的键</span><br><span class="line">  - `values()`：返回遍历器对象，遍历所有的值</span><br><span class="line">  - `entries()`：返回遍历器对象，遍历所有的键值对</span><br><span class="line"></span><br><span class="line">- 与for-in区别</span><br><span class="line"></span><br><span class="line">  - 有着同`for-in`一样的简洁语法，但没有`for-in`那些缺点、</span><br><span class="line">  - 不同于`forEach()`，它可与`break`、`continue`和`return`配合使用</span><br><span class="line">  - 提供遍历所有数据结构的统一操作接口</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 改写具有`Iterator`接口的数据结构的`Symbol.iterator`</span><br><span class="line">- 解构赋值：对`Set`进行结构</span><br><span class="line">- 扩展运算符：将部署Iterator接口的数据结构转为数组</span><br><span class="line">- `yield*`：`yield*`后跟一个可遍历的数据结构，会调用其遍历器接口</span><br><span class="line">- 接受数组作为参数的函数：`for-of`、`Array.from()`、`new Set()`、`new WeakSet()`、`new Map()`、`new WeakMap()`、`Promise.all()`、`Promise.race()`</span><br><span class="line"></span><br><span class="line">### Promise</span><br><span class="line"></span><br><span class="line">- 定义：包含异步操作结果的对象</span><br><span class="line"></span><br><span class="line">- 状态</span><br><span class="line"></span><br><span class="line">  - 进行中：`pending`</span><br><span class="line">  - 已成功：`resolved`</span><br><span class="line">  - 已失败：`rejected`</span><br><span class="line"></span><br><span class="line">- 特点</span><br><span class="line"></span><br><span class="line">  - 对象的状态不受外界影响</span><br><span class="line">  - 一旦状态改变就不会再变，任何时候都可得到这个结果</span><br><span class="line"></span><br><span class="line">- 声明：`new Promise((resolve, reject) =&gt; &#123;&#125;)`</span><br><span class="line"></span><br><span class="line">- 出参</span><br><span class="line"></span><br><span class="line">  - `resolve`：将状态从未完成变为成功，在异步操作成功时调用，并将异步操作的结果作为参数传递出去</span><br><span class="line">  - `reject`：将状态从未完成变为失败，在异步操作失败时调用，并将异步操作的错误作为参数传递出去</span><br><span class="line"></span><br><span class="line">- 方法</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    then()</span><br></pre></td></tr></table></figure>

<p>  ：分别指定</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolved</span><br></pre></td></tr></table></figure>

<p>  状态和</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rejected</span><br></pre></td></tr></table></figure>

<p>  状态的回调函数</p>
<ul>
<li><p>第一参数：状态变为<code>resolved</code>时调用</p>
</li>
<li><p>第二参数：状态变为<code>rejected</code>时调用(可选)</p>
</li>
<li><p><code>catch()</code>：指定发生错误时的回调函数</p>
</li>
<li><pre><code>Promise.all()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：将多个实例包装成一个新实例，返回全部实例状态变更后的结果数组(齐变更再返回)</span><br><span class="line"></span><br><span class="line">  - 入参：具有`Iterator`接口的数据结构</span><br><span class="line">  - 成功：只有全部实例状态变成`resolved`，最终状态才会变成`resolved`</span><br><span class="line">  - 失败：其中一个实例状态变成`rejected`，最终状态就会变成`rejected`</span><br><span class="line"></span><br><span class="line">- `Promise.race()`：将多个实例包装成一个新实例，返回全部实例状态优先变更后的结果(先变更先返回)</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Promise.resolve()</span><br></pre></td></tr></table></figure>

：将对象转为Promise对象(等价于

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Promise(resolve =&gt; resolve())</span><br></pre></td></tr></table></figure>

)

- `Promise`实例：原封不动地返回入参
- `Thenable`对象：将此对象转为`Promise`对象并返回(`Thenable`为包含`then()`的对象，执行`then()`相当于执行此对象的`then()`)
- 不具有`then()`的对象：将此对象转为`Promise`对象并返回，状态为`resolved`
- 不带参数：返回`Promise`对象，状态为`resolved`
</code></pre>
</li>
<li><p><code>Promise.reject()</code>：将对象转为状态为<code>rejected</code>的<code>Promise</code>对象(等价于<code>new Promise((resolve, reject) =&gt; reject())</code>)</p>
</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>加载图片</li>
<li><code>AJAX</code>转<code>Promise</code>对象</li>
</ul>
<p><strong>重点难点</strong></p>
<ul>
<li>只有异步操作的结果可决定当前状态是哪一种，其他操作都无法改变这个状态</li>
<li>状态改变只有两种可能：从<code>pending</code>变为<code>resolved</code>、从<code>pending</code>变为<code>rejected</code></li>
<li>一旦新建<code>Promise</code>对象就会立即执行，无法中途取消</li>
<li>不设置回调函数，内部抛错不会反应到外部</li>
<li>当处于<code>pending</code>时，无法得知目前进展到哪一个阶段</li>
<li>实例状态变为<code>resolved</code>或<code>rejected</code>时，会触发<code>then()</code>绑定的回调函数</li>
<li><code>resolve()</code>和<code>reject()</code>的执行总是晚于本轮循环的同步任务</li>
<li><code>then()</code>返回新实例，其后可再调用另一个<code>then()</code></li>
<li><code>then()</code>运行中抛出错误会被<code>catch()</code>捕获</li>
<li><code>reject()</code>的作用等同于抛出错误</li>
<li>实例状态已变成<code>resolved</code>时，再抛出错误是无效的，不会被捕获，等于没有抛出</li>
<li>实例状态的错误具有冒泡性质，会一直向后传递直到被捕获为止，错误总是会被下一个<code>catch()</code>捕获</li>
<li>不要在<code>then()</code>里定义<code>rejected</code>状态的回调函数(不使用其第二参数)</li>
<li>建议使用<code>catch()</code>捕获错误，不要使用<code>then()</code>第二个参数捕获</li>
<li>没有使用<code>catch()</code>捕获错误，实例抛错不会传递到外层代码，即不会有任何反应</li>
<li>作为参数的实例定义了<code>catch()</code>，一旦被<code>rejected</code>并不会触发<code>Promise.all()</code>的<code>catch()</code></li>
<li><code>Promise.reject()</code>的参数会原封不动地作为<code>rejected</code>的理由，变成后续方法的参数</li>
</ul>
<h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><ul>
<li><p>定义：封装多个内部状态的异步编程解决方案</p>
</li>
<li><p>形式：调用<code>Generator</code>函数(该函数不执行)返回指向内部状态的指针对象(不是运行结果)</p>
</li>
<li><p>声明：<code>function* Func() &#123;&#125;</code></p>
</li>
<li><p>方法</p>
<ul>
<li><code>next()</code>：使指针移向下一个状态，返回<code>&#123; done, value &#125;</code>(入参会被当作上一个<code>yield</code>命令表达式的返回值)</li>
<li><code>return()</code>：返回指定值且终结遍历<code>Generator</code>函数，返回<code>&#123; done: true, value: 入参 &#125;</code></li>
<li><code>throw()</code>：在<code>Generator</code>函数体外抛出错误，在<code>Generator</code>函数体内捕获错误，返回自定义的<code>new Errow()</code></li>
</ul>
</li>
<li><pre><code>yield
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令：声明内部状态的值(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
return
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  声明结束返回的值)</span><br><span class="line"></span><br><span class="line">  - 遇到`yield`命令就暂停执行后面的操作，并将其后表达式的值作为返回对象的`value`</span><br><span class="line">  - 下次调用`next()`时，再继续往下执行直到遇到下一个`yield`命令</span><br><span class="line">  - 没有再遇到`yield`命令就一直运行到`Generator`函数结束，直到遇到`return`语句为止并将其后表达式的值作为返回对象的`value`</span><br><span class="line">  - `Generator`函数没有`return`语句则返回对象的`value`为`undefined`</span><br><span class="line"></span><br><span class="line">- `yield*`命令：在一个`Generator`函数里执行另一个`Generator`函数(后随具有`Iterator`接口的数据结构)</span><br><span class="line"></span><br><span class="line">- 遍历：通过`for-of`自动调用`next()`</span><br><span class="line"></span><br><span class="line">- 作为对象属性</span><br><span class="line"></span><br><span class="line">  - 全写：`const obj = &#123; method: function*() &#123;&#125; &#125;`</span><br><span class="line">  - 简写：`const obj = &#123; * method() &#123;&#125; &#125;`</span><br><span class="line"></span><br><span class="line">- 上下文：执行产生的上下文环境一旦遇到`yield`命令就会暂时退出堆栈(但并不消失)，所有变量和对象会冻结在当前状态，等到对它执行`next()`时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行</span><br><span class="line"></span><br><span class="line">**方法异同**</span><br><span class="line"></span><br><span class="line">- 相同点</span><br><span class="line"></span><br><span class="line">  ：</span><br><span class="line"></span><br><span class="line">  - `next()`、`throw()`、`return()`本质上是同一件事，作用都是让函数恢复执行且使用不同的语句替换yield命令</span><br><span class="line"></span><br><span class="line">- 不同点</span><br><span class="line"></span><br><span class="line">  - `next()`：将`yield`命令替换成一个值</span><br><span class="line">  - `return()`：将`yield`命令替换成一个`return`语句</span><br><span class="line">  - `throw()`：将`yield`命令替换成一个`throw`语句</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 异步操作同步化表达</span><br><span class="line">- 控制流管理</span><br><span class="line">- 为对象部署`Iterator`接口：把`Generator`函数赋值给对象的`Symbol.iterator`，从而使该对象具有`Iterator`接口</span><br><span class="line">- 作为具有`Iterator`接口的数据结构</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- 每次调用`next()`，指针就从函数头部或上次停下的位置开始执行，直到遇到下一个`yield`命令或`return`语句为止</span><br><span class="line">- 函数内部可不用`yield`命令，但会变成单纯的暂缓执行函数(还是需要`next()`触发)</span><br><span class="line">- `yield`命令是暂停执行的标记，`next()`是恢复执行的操作</span><br><span class="line">- `yield`命令用在另一个表达式中必须放在圆括号里</span><br><span class="line">- `yield`命令用作函数参数或放在赋值表达式的右边，可不加圆括号</span><br><span class="line">- `yield`命令本身没有返回值，可认为是返回`undefined`</span><br><span class="line">- `yield`命令表达式为惰性求值，等`next()`执行到此才求值</span><br><span class="line">- 函数调用后生成遍历器对象，此对象的`Symbol.iterator`是此对象本身</span><br><span class="line">- 在函数运行的不同阶段，通过`next()`从外部向内部注入不同的值，从而调整函数行为</span><br><span class="line">- 首个`next()`用来启动遍历器对象，后续才可传递参数</span><br><span class="line">- 想首次调用`next()`时就能输入值，可在函数外面再包一层</span><br><span class="line">- 一旦`next()`返回对象的`done`为`true`，`for-of`遍历会中止且不包含该返回对象</span><br><span class="line">- 函数内部部署`try-finally`且正在执行`try`，那么`return()`会导致立刻进入`finally`，执行完`finally`以后整个函数才会结束</span><br><span class="line">- 函数内部没有部署`try-catch`，`throw()`抛错将被外部`try-catch`捕获</span><br><span class="line">- `throw()`抛错要被内部捕获，前提是必须至少执行过一次`next()`</span><br><span class="line">- `throw()`被捕获以后，会附带执行下一条`yield`命令</span><br><span class="line">- 函数还未开始执行，这时`throw()`抛错只可能抛出在函数外部</span><br><span class="line"></span><br><span class="line">&gt; 首次next()可传值</span><br><span class="line"></span><br></pre></td></tr></table></figure>
function Wrapper(func) &#123;
  return function(...args) &#123;
      const generator = func(...args);
      generator.next();
      return generator;
  &#125;
&#125;
const print = Wrapper(function*() &#123;
  console.log(`First Input: $&#123;yield&#125;`);
  return &quot;done&quot;;
&#125;);
print().next(&quot;hello&quot;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## ES2016</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/126.png)</span><br><span class="line"></span><br><span class="line">### 数值扩展</span><br><span class="line"></span><br><span class="line">- 指数运算符(`**`)：数值求幂(相当于`Math.pow()`)</span><br><span class="line"></span><br><span class="line">### 数组扩展</span><br><span class="line"></span><br><span class="line">- `includes()`：是否存在指定成员</span><br><span class="line"></span><br><span class="line">## ES2017</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/127.png)</span><br><span class="line"></span><br><span class="line">**声明**</span><br><span class="line"></span><br><span class="line">- 共享内存和原子操作：由全局对象`SharedArrayBuffer`和`Atomics`实现，将数据存储在一块共享内存空间中，这些数据可在`JS`主线程和`web-worker`线程之间共享</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- `padStart()`：把指定字符串填充到字符串头部，返回新字符串</span><br><span class="line">- `padEnd()`：把指定字符串填充到字符串尾部，返回新字符串</span><br><span class="line"></span><br><span class="line">**对象扩展**</span><br><span class="line"></span><br><span class="line">- `Object.getOwnPropertyDescriptors()`：返回对象所有自身属性(非继承属性)的描述对象</span><br><span class="line">- `Object.values()`：返回以值组成的数组</span><br><span class="line">- `Object.entries()`：返回以键和值组成的数组</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 函数参数尾逗号：允许函数最后一个参数有尾逗号</span><br><span class="line"></span><br><span class="line">**Async**</span><br><span class="line"></span><br><span class="line">- 定义：使异步函数以同步函数的形式书写(`Generator`函数语法糖)</span><br><span class="line"></span><br><span class="line">- 原理：将`Generator`函数和自动执行器`spawn`包装在一个函数里</span><br><span class="line"></span><br><span class="line">- 形式：将`Generator`函数的`*`替换成`async`，将`yield`替换成`await`</span><br><span class="line"></span><br><span class="line">- 声明</span><br><span class="line"></span><br><span class="line">  - 具名函数：`async function Func() &#123;&#125;`</span><br><span class="line">  - 函数表达式：`const func = async function() &#123;&#125;`</span><br><span class="line">  - 箭头函数：`const func = async() =&gt; &#123;&#125;`</span><br><span class="line">  - 对象方法：`const obj = &#123; async func() &#123;&#125; &#125;`</span><br><span class="line">  - 类方法：`class Cla &#123; async Func() &#123;&#125; &#125;`</span><br><span class="line"></span><br><span class="line">- await命令</span><br><span class="line"></span><br><span class="line">  ：等待当前</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Promise
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  对象状态变更完毕</span><br><span class="line"></span><br><span class="line">  - 正常情况：后面是`Promise`对象则返回其结果，否则返回对应的值</span><br><span class="line">  - 后随`Thenable`对象：将其等同于`Promise`对象返回其结果</span><br><span class="line"></span><br><span class="line">- **错误处理**：将`await`命令`Promise`对象放到`try-catch`中(可放多个)</span><br><span class="line"></span><br><span class="line">**Async对Generator改进**</span><br><span class="line"></span><br><span class="line">- 内置执行器</span><br><span class="line">- 更好的语义</span><br><span class="line">- 更广的适用性</span><br><span class="line">- 返回值是`Promise`对象</span><br><span class="line"></span><br><span class="line">**应用场景**</span><br><span class="line"></span><br><span class="line">- 按顺序完成异步操作</span><br><span class="line"></span><br><span class="line">**重点难点**</span><br><span class="line"></span><br><span class="line">- `Async`函数返回`Promise`对象，可使用`then()`添加回调函数</span><br><span class="line">- 内部`return`返回值会成为后续`then()`的出参</span><br><span class="line">- 内部抛出错误会导致返回的`Promise`对象变为`rejected`状态，被`catch()`接收到</span><br><span class="line">- 返回的`Promise`对象必须等到内部所有`await`命令`Promise`对象执行完才会发生状态改变，除非遇到`return`语句或抛出错误</span><br><span class="line">- 任何一个`await`命令`Promise`对象变为`rejected`状态，整个`Async`函数都会中断执行</span><br><span class="line">- 希望即使前一个异步操作失败也不要中断后面的异步操作</span><br><span class="line">  - 将`await`命令`Promise`对象放到`try-catch`中</span><br><span class="line">  - `await`命令`Promise`对象跟一个`catch()`</span><br><span class="line">- `await`命令`Promise`对象可能变为`rejected`状态，最好把其放到`try-catch`中</span><br><span class="line">- 多个`await`命令`Promise`对象若不存在继发关系，最好让它们同时触发</span><br><span class="line">- `await`命令只能用在`Async`函数之中，否则会报错</span><br><span class="line">- 数组使用`forEach()`执行`async/await`会失效，可使用`for-of`和P`romise.all()`代替</span><br><span class="line">- 可保留运行堆栈，函数上下文随着`Async`函数的执行而存在，执行完成就消失</span><br><span class="line"></span><br><span class="line">## ES2018</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/128.png)</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- 放松对标签模板里字符串转义的限制：遇到不合法的字符串转义返回`undefined`，并且从`raw`上可获取原字符串</span><br><span class="line"></span><br><span class="line">**对象扩展**</span><br><span class="line"></span><br><span class="line">- 扩展运算符(`...`)：转换对象为用逗号分隔的参数序列(`&#123; ...obj &#125;`，相当于`rest/spread`参数的逆运算)</span><br><span class="line"></span><br><span class="line">&gt; 扩展应用</span><br><span class="line"></span><br><span class="line">- 克隆对象：`const obj = &#123; __proto__: Object.getPrototypeOf(obj1), ...obj1 &#125;`</span><br><span class="line">- 合并对象：`const obj = &#123; ...obj1, ...obj2 &#125;`</span><br><span class="line">- 转换字符串为对象：`&#123; ...&quot;hello&quot; &#125;`</span><br><span class="line">- 转换数组为对象：`&#123; ...[1, 2] &#125;`</span><br><span class="line">- 与对象解构赋值结合：`const &#123; x, ...rest/spread &#125; = &#123; x: 1, y: 2, z: 3 &#125;`(不能复制继承自原型对象的属性)</span><br><span class="line">- 修改现有对象部分属性：`const obj = &#123; x: 1, ...&#123; x: 2 &#125; &#125;`</span><br><span class="line"></span><br><span class="line">### 正则扩展</span><br><span class="line"></span><br><span class="line">- `s`修饰符：`dotAll`模式修饰符，使`.`匹配任意单个字符(`dotAll`模式)</span><br><span class="line"></span><br><span class="line">- `dotAll`：是否设置`s`修饰符</span><br><span class="line"></span><br><span class="line">- 后行断言：`x`只有在`y`后才匹配</span><br><span class="line"></span><br><span class="line">- 后行否定断言：`x`只有不在`y`后才匹配</span><br><span class="line"></span><br><span class="line">- `Unicode`属性转义</span><br><span class="line"></span><br><span class="line">  ：匹配符合</span><br><span class="line"></span><br></pre></td></tr></table></figure>
Unicode
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  某种属性的所有字符</span><br><span class="line"></span><br><span class="line">  - 正向匹配：`\p&#123;PropRule&#125;`</span><br><span class="line">  - 反向匹配：`\P&#123;PropRule&#125;`</span><br><span class="line">  - 限制：`\p&#123;...&#125;`和`\P&#123;...&#125;`只对`Unicode`字符有效，使用时需加上u修饰符</span><br><span class="line"></span><br><span class="line">- 具名组匹配</span><br><span class="line"></span><br><span class="line">  ：为每组匹配指定名字(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
?&lt;GroupName&gt;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  - 形式：`str.exec().groups.GroupName`</span><br><span class="line">  - 解构赋值替换</span><br><span class="line">    - 声明：`const time = &quot;2017-09-11&quot;、const regexp = /(?\d&#123;4&#125;)-(?\d&#123;2&#125;)-(?\d&#123;2&#125;)/u`</span><br><span class="line">    - 匹配：`time.replace(regexp, &quot;$/$/$&quot;)`</span><br><span class="line"></span><br><span class="line">### Promise</span><br><span class="line"></span><br><span class="line">- `finally()`：指定不管最后状态如何都会执行的回调函数</span><br><span class="line"></span><br><span class="line">### Async</span><br><span class="line"></span><br><span class="line">- 异步迭代器(`for-await-of`)：，循环等待每个`Promise`对象变为`resolved`状态才进入下一步</span><br><span class="line"></span><br><span class="line">## ES2019</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/129.png)</span><br><span class="line"></span><br><span class="line">### 字符串扩展</span><br><span class="line"></span><br><span class="line">- 直接输入`U+2028`和`U+2029`：字符串可直接输入行分隔符和段分隔符</span><br><span class="line">- `JSON.stringify()`改造：可返回不符合`UTF-8`标准的字符串</span><br><span class="line">- `trimStart()`：消除字符串头部空格，返回新字符串</span><br><span class="line">- `trimEnd()`：消除字符串尾部空格，返回新字符串</span><br><span class="line"></span><br><span class="line">### 对象扩展</span><br><span class="line"></span><br><span class="line">- `Object.fromEntries()`：返回以键和值组成的对象(`Object.entries()`的逆操作)</span><br><span class="line"></span><br><span class="line">### 数组扩展</span><br><span class="line"></span><br><span class="line">- `flat()`：扁平化数组，返回新数组</span><br><span class="line">- `flatMap()`：映射且扁平化数组，返回新数组(只能展开一层数组)</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- `toString()`改造：返回函数原始代码(与编码一致)</span><br><span class="line">- `catch()`参数可省略：`catch()`中的参数可省略</span><br><span class="line"></span><br><span class="line">### Symbol</span><br><span class="line"></span><br><span class="line">- `description`：返回`Symbol`值的描述</span><br><span class="line"></span><br><span class="line">## ES提案</span><br><span class="line"></span><br><span class="line">![img](https://poetries1.gitee.io/img-repo/2019/11/130.png)</span><br><span class="line"></span><br><span class="line">### 声明</span><br><span class="line"></span><br><span class="line">- `globalThis`对象：作为顶层对象，指向全局环境下的`this`</span><br><span class="line">- `do`表达式：封装块级作用域的操作，返回内部最后执行表达式的值(`do&#123;&#125;`)</span><br><span class="line">- `throw`表达式：直接使用`throw new Error()`，无需`()`或`&#123;&#125;`包括</span><br><span class="line">- `!#`命令：指定脚本执行器(写在文件首行)</span><br><span class="line"></span><br><span class="line">### 数值扩展</span><br><span class="line"></span><br><span class="line">- 数值分隔符(`_`)：使用`_`作为千分位分隔符(增加数值的可读性)</span><br><span class="line">- `BigInt()`：创建任何位数的整数(新增的数据类型，使用`n`结尾)</span><br><span class="line"></span><br><span class="line">### 对象扩展</span><br><span class="line"></span><br><span class="line">- 链判断操作符(`?.`)：是否存在对象属性(不存在返回`undefined`且不再往下执行)</span><br><span class="line">- 空判断操作符(`??`)：是否值为`undefined`或`null`，是则使用默认值</span><br><span class="line"></span><br><span class="line">### 函数扩展</span><br><span class="line"></span><br><span class="line">- 函数部分执行：复用函数功能(`?`表示单个参数占位符，`...`表示多个参数占位符)</span><br><span class="line"></span><br><span class="line">- 管道操作符(`|&gt;`)：把左边表达式的值传入右边的函数进行求值(`f(x) =&gt; x |&gt; f`)</span><br><span class="line"></span><br><span class="line">- 绑定运算符(</span><br><span class="line"></span><br></pre></td></tr></table></figure>
::
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">)：函数绑定(左边是对象右边是函数，取代</span><br><span class="line"></span><br></pre></td></tr></table></figure>
bind
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
apply
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">、</span><br><span class="line"></span><br></pre></td></tr></table></figure>
call
</code></pre>
<p>调用)</p>
<ul>
<li><code>bind：bar.bind(foo)</code> &#x3D;&gt; <code>foo::bar</code></li>
<li><code>apply</code>：bar.apply(foo, arguments)<code>=&gt;</code>foo::bar(…arguments)&#96;</li>
</ul>
</li>
</ul>
<h3 id="Proxy-1"><a href="#Proxy-1" class="headerlink" title="Proxy"></a>Proxy</h3><ul>
<li><code>Promise.try()</code>：不想区分是否同步异步函数，包装函数为实例，使用<code>then()</code>指定下一步流程，使用<code>catch()</code>捕获错误</li>
</ul>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><ul>
<li>定义：提供沙箱功能，允许隔离代码，防止被隔离的代码拿到全局对象</li>
<li>声明：<code>new Realm().global</code></li>
</ul>
<h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><ul>
<li>静态属性：使用<code>static</code>定义属性，该属性不会被实例继承，只能通过类来调用</li>
<li>私有属性：使用<code>#</code>定义属性，该属性只能在类内部访问</li>
<li>私有方法：使用<code>#</code>定义方法，该方法只能在类内部访问</li>
<li>装饰器：使用<code>@</code>注释或修改类和类方法</li>
</ul>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><ul>
<li>import()：动态导入(返回Promise)<ul>
<li>背景：<code>import</code>命令被JS引擎静态分析，先于模块内的其他语句执行，无法取代<code>require()</code>的动态加载功能，提案建议引入<code>import()</code>来代替<code>require()</code></li>
<li>位置：可在任何地方使用</li>
<li>区别：<code>require()</code>是同步加载，<code>import()</code>是异步加载</li>
<li>场景：按需加载、条件加载、模块路径动态化</li>
</ul>
</li>
<li><strong>import.meta：返回脚本元信息</strong></li>
</ul>
<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><ul>
<li>顶层<code>Await</code>：允许在模块的顶层独立使用<code>await</code>命令(借用<code>await</code>解决模块异步加载的问题)</li>
</ul>

      </section>

      
      
        <nav class="article-nav">
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2018/03/25/html+css+js+ts/4-es6-%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95.md/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">es6对象扩展</h2>
        </a>
      
      <div class="card-text--row">Newer</div>
    </div>
  </article>
</div>
          
          
            <div class="article-nav-item layout-padding">
  <article class="card-container article-nav-card content-padding--primary soft-size--large soft-style--box">
    
    <div class="card-text">
      
        <a href="/2018/03/20/html+css+js+ts/4-asyncawait/" itemprop="url">
          <h2 class="card-text--title text-ellipsis">ES async/await</h2>
        </a>
      
      <div class="card-text--row">Older</div>
    </div>
  </article>
</div>
          
        </nav>
      

      <section class="page-message-container layout-padding">
        


  
  

  
  


      </section>
    </div>
    <div class="widget-info">
      <section class="widget-author widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-body">
    
      <img src="https://s.gravatar.com/avatar/2d6b803eea37de0257620d5fabee7e64?s=200&amp;r=g&amp;d=retro" class="soft-size--round soft-style--box" alt="Sukoshi">
    
    
      <h2>Sukoshi</h2>
    
    
      <p>贵在坚持</p>
    

    <div class="count-box">
      <div class="count-box--item">
        <svg class="icon icon-article" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M240.51564747 647.74217627h196.07203239c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806V165.10332731c0-33.18142087-30.16492806-60.32985613-60.32985612-60.32985611H245.04038668C225.43318342 104.7734712 210.35071939 119.85593522 210.35071939 139.46313845V617.57724821c0 16.59071043 13.57421762 30.16492806 30.16492808 30.16492806z m663.62841731-452.47392089v482.63884894c0 33.18142087-27.14843525 60.32985613-60.32985612 60.32985613H180.18579134c-33.18142087 0-60.32985613-27.14843525-60.32985612-60.32985613V195.26825538c-49.77213131 0-90.49478418 40.72265287-90.49478417 90.49478417v452.4739209c0 49.77213131 40.72265287 90.49478418 90.49478417 90.49478417h286.56681657c16.59071043 0 30.16492806 13.57421762 30.16492807 30.16492807s13.57421762 30.16492806 30.16492805 30.16492806h90.49478418c16.59071043 0 30.16492806-13.57421762 30.16492805-30.16492806s13.57421762-30.16492806 30.16492807-30.16492807h286.56681657c49.77213131 0 90.49478418-40.72265287 90.49478417-90.49478417V285.76303955c0-49.77213131-40.72265287-90.49478418-90.49478417-90.49478417zM587.41232014 647.74217627h191.54729318c19.60720323 0 34.68966726-15.08246403 34.68966729-34.68966727V134.93839925c0-16.59071043-13.57421762-30.16492806-30.16492808-30.16492805H617.57724821c-30.16492806 0-60.32985613 27.14843525-60.32985612 60.32985611v452.4739209c0 16.59071043 13.57421762 30.16492806 30.16492805 30.16492806z" fill="currentColor"></path>
</svg>
        <span>223</span>
      </div>
      <div class="count-box--item">
        <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
        29
      </div>
      <div class="count-box--item">
        <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
        37
      </div>
    </div>
  </div>
</section>

      

      
<section class="widet-notice widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-notice" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M512 945.02305225v28.15620663a24.27259221 24.27259221 0 0 1-24.27259221 24.27259335H394.0352a48.54518557 48.54518557 0 0 1-41.74885888-23.78714112l-110.68302222-184.47170332a132.04290333 132.04290333 0 0 1-17.47626667-48.54518557h118.4502511a200.97706667 200.97706667 0 0 1 76.21594113 14.56355556l20.38897777 133.49925888a48.54518557 48.54518557 0 0 0 36.40888888 27.67075555l16.01991111 2.91271112a24.27259221 24.27259221 0 0 1 20.38897778 25.72894889zM997.45185223 463.45481443a194.18074112 194.18074112 0 0 1-38.8361489 116.50844445 24.75804445 24.75804445 0 0 1-36.4088889 0l-34.95253333-34.95253333a24.27259221 24.27259221 0 0 1-2.91271111-30.58346667 97.09036999 97.09036999 0 0 0 0-106.79940665 24.27259221 24.27259221 0 0 1 2.91271111-30.58346666l34.95253333-34.95253334a24.75804445 24.75804445 0 0 1 18.93262223-7.28177777 26.2144 26.2144 0 0 1 17.47626667 9.70903665A194.18074112 194.18074112 0 0 1 997.45185223 463.45481443z m-194.18074112-388.36148111v776.72296335a48.54518557 48.54518557 0 0 1-48.54518556 48.54518443h-28.64165888a48.54518557 48.54518557 0 0 1-33.98163001-14.07810332l-145.63555556-143.20829668A291.27111111 291.27111111 0 0 0 342.57730333 657.63555556H172.18370333a145.63555556 145.63555556 0 0 1-145.63555556-145.63555556v-97.09036999a145.63555556 145.63555556 0 0 1 145.63555556-145.63555556h170.3936a291.27111111 291.27111111 0 0 0 206.31703779-85.43952668l145.63555555-143.20829554a48.54518557 48.54518557 0 0 1 33.98162888-14.07810446H754.72592555a48.54518557 48.54518557 0 0 1 48.54518556 48.54518555z" fill="currentColor"></path>
</svg>
    <span>NOTICE</span>
  </div>
  <div class="widget-body">
    <p>flex-block主题部分重构，详情查看https://github.com/miiiku/flex-block</p>
  </div>
</section>


      <section class="widget-categorys widget-item layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-categories" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M900.3614811 257.09082106h-339.81629553l-67.96326003-101.9448889c-19.41807444-29.12711113-48.54518557-43.69066667-82.52681443-43.69066667H123.6385189c-53.39970333 0-97.09036999 43.69066667-97.09037113 97.09036999v582.54222222c0 53.39970333 43.69066667 97.09036999 97.09037113 97.09037002h776.7229622c53.39970333 0 97.09036999-43.69066667 97.09037113-97.09037002V354.18119104c0-53.39970333-43.69066667-97.09036999-97.09037113-97.09036998z m-97.09036999 242.72592554H220.72888889c-24.27259221 0-48.54518557-24.27259221-48.54518556-48.54518556s24.27259221-48.54518557 48.54518556-48.54518444h582.54222222c24.27259221 0 48.54518557 24.27259221 48.54518556 48.54518444s-24.27259221 48.54518557-48.54518556 48.54518556z" fill="currentColor"></path>
</svg>
    <span>CATEGORYS</span>
  </div>
  <div class="widget-body">
    <ul class="categorys-list">
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%A1%86%E6%9E%B6/">
            框架 (77)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/React/">
            React (4)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%A1%86%E6%9E%B6/React/">
            React (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%8E%9F%E7%90%86/">
            原理 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%8E%9F%E7%90%86/React/">
            React (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">
            架构模式 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/%E6%A1%86%E6%9E%B6/">
            框架 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF/">
            前端 (61)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF/">
            移动端 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%9F%B3%E8%A7%86%E9%A2%91/">
            音视频 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/css/">
            css (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/javascript/">
            javascript (3)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/">
            问题 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/http/">
            http (14)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%90%8E%E7%AB%AF/">
            后端 (9)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/">
            框架 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/">
            小程序 (8)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%B7%A5%E5%85%B7/">
            工具 (15)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%90%8E%E7%AB%AF/%E7%AE%97%E6%B3%95/">
            算法 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
            正则表达式 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">
            前端性能优化 (6)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
            操作系统 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/">
            数据可视化 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">
            数据库 (2)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/">
            浏览器 (5)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%AE%97%E6%B3%95/">
            算法 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E7%88%AC%E8%99%AB/">
            爬虫 (1)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
            设计模式 (6)
          </a>
        </li>
      
        <li class="categorys-list-item">
          <a href="/categories/liunx/">
            liunx (2)
          </a>
        </li>
      
    </ul>
  </div>
</section>

      <section class="widget-tags widget-item  layout-margin content-padding--primary soft-size--large soft-style--box">
  <div class="widget-title">
    <svg class="icon icon-tags" viewBox="0 0 1098 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M283.42180005 272q0-28.38857157-20.09142843-48.48000001t-48.47999998-20.09142842-48.48000002 20.09142842-20.09142846 48.48000001 20.09142846 48.48 48.48000002 20.09142843 48.47999998-20.09142843 20.09142843-48.48zM855.0332285 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.03999997 263.58857157q-20.9142853 19.81714313-48.75428534 19.81714312-28.38857157 0-48.20571468-19.81714312l-383.04-383.58857157q-20.36571468-19.81714313-34.55999999-54.10285688t-14.19428534-62.6742853l0-222.85714313q0-27.84000002 20.36571469-48.20571469t48.2057147-20.36571466l222.85714313 0q28.38857157 0 62.6742853 14.19428529t54.65142842 34.55999999l383.04000001 382.49142843q19.81714313 20.9142853 19.81714314 48.75428532zM1060.74751475 580.57142843q0 28.38857157-19.81714313 48.2057147l-263.04 263.58857157q-20.9142853 19.81714313-48.75428531 19.81714312-19.26857155 0-31.61142843-7.47428531t-28.38857159-24.13714314l251.79428534-251.7942853q19.81714313-19.81714313 19.81714308-48.20571469 0-27.84000002-19.81714308-48.75428531l-383.04000001-382.49142845q-20.36571468-20.36571468-54.65142842-34.55999999t-62.67428532-14.19428534l120 0q28.38857157 0 62.67428532 14.19428534t54.65142842 34.55999999l383.03999998 382.49142845q19.81714313 20.9142853 19.81714314 48.75428531z" fill="currentColor"></path>
</svg>
    <span>TAGS</span>
  </div>
  <div class="widget-body">
    <div class="tags-cloud">
      <a href="/tags/Event-Loop/" style="font-size: 10px;" class="tags-cloud-0">Event Loop</a> <a href="/tags/Graphviz/" style="font-size: 10px;" class="tags-cloud-0">Graphviz</a> <a href="/tags/Mock/" style="font-size: 10px;" class="tags-cloud-0">Mock</a> <a href="/tags/Promise/" style="font-size: 10px;" class="tags-cloud-0">Promise</a> <a href="/tags/RESTful/" style="font-size: 10px;" class="tags-cloud-0">RESTful</a> <a href="/tags/React/" style="font-size: 19.23px;" class="tags-cloud-9">React</a> <a href="/tags/Redux/" style="font-size: 11.54px;" class="tags-cloud-2">Redux</a> <a href="/tags/async-await/" style="font-size: 10px;" class="tags-cloud-0">async/await</a> <a href="/tags/css/" style="font-size: 13.85px;" class="tags-cloud-4">css</a> <a href="/tags/echart/" style="font-size: 10px;" class="tags-cloud-0">echart</a> <a href="/tags/es6/" style="font-size: 16.92px;" class="tags-cloud-7">es6</a> <a href="/tags/eslint/" style="font-size: 10px;" class="tags-cloud-0">eslint</a> <a href="/tags/git/" style="font-size: 16.15px;" class="tags-cloud-6">git</a> <a href="/tags/hexo/" style="font-size: 10px;" class="tags-cloud-0">hexo</a> <a href="/tags/html/" style="font-size: 14.62px;" class="tags-cloud-5">html</a> <a href="/tags/http/" style="font-size: 17.69px;" class="tags-cloud-8">http</a> <a href="/tags/javascript/" style="font-size: 18.46px;" class="tags-cloud-8">javascript</a> <a href="/tags/mongodb/" style="font-size: 10px;" class="tags-cloud-0">mongodb</a> <a href="/tags/mysql/" style="font-size: 10px;" class="tags-cloud-0">mysql</a> <a href="/tags/nginx/" style="font-size: 10.77px;" class="tags-cloud-1">nginx</a> <a href="/tags/nodejs/" style="font-size: 13.08px;" class="tags-cloud-3">nodejs</a> <a href="/tags/python/" style="font-size: 10.77px;" class="tags-cloud-1">python</a> <a href="/tags/react/" style="font-size: 10px;" class="tags-cloud-0">react</a> <a href="/tags/typescript/" style="font-size: 12.31px;" class="tags-cloud-2">typescript</a> <a href="/tags/vs-code/" style="font-size: 11.54px;" class="tags-cloud-2">vs code</a> <a href="/tags/vue/" style="font-size: 20px;" class="tags-cloud-10">vue</a> <a href="/tags/vue3/" style="font-size: 10px;" class="tags-cloud-0">vue3</a> <a href="/tags/xml/" style="font-size: 10px;" class="tags-cloud-0">xml</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 13.85px;" class="tags-cloud-4">优化</a> <a href="/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15.38px;" class="tags-cloud-5">小程序</a> <a href="/tags/%E6%8A%93%E5%8C%85/" style="font-size: 10px;" class="tags-cloud-0">抓包</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 10px;" class="tags-cloud-0">操作系统</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;" class="tags-cloud-0">正则表达式</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 13.08px;" class="tags-cloud-3">浏览器</a> <a href="/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/" style="font-size: 10.77px;" class="tags-cloud-1">移动端</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;" class="tags-cloud-0">算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13.85px;" class="tags-cloud-4">设计模式</a>
    </div>
  </div>
</section>
    </div>
  </article>
</div>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    
    <div class="social-icons">
      
        
      
        
      
        
      
        
          <a href="https://github.com/miiiku/" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-github" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M64.6 512c0 195.6 125.4 361.9 300.1 422.9 23.5 5.9 19.9-10.8 19.9-22.2v-77.6c-135.8 15.9-141.3-74-150.5-89-18.5-31.5-61.9-39.5-49-54.5 31-15.9 62.5 4 98.9 58 26.4 39.1 77.9 32.5 104.1 26 5.7-23.5 17.9-44.5 34.7-60.9-140.7-25.2-199.4-111.1-199.4-213.3 0-49.5 16.4-95.1 48.4-131.8-20.4-60.6 1.9-112.4 4.9-120.1 58.2-5.2 118.5 41.6 123.3 45.3 33.1-8.9 70.8-13.7 112.9-13.7 42.4 0 80.3 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.4-43.9 2.9 7.7 24.7 58.3 5.5 118.1 32.5 36.8 49 82.8 49 132.4 0 102.3-59 188.3-200.2 213.2 23.5 23.3 38.1 55.5 38.1 91.1v112.7c0.8 9 0 17.9 15.1 17.9C832.7 877 960.4 709.4 960.4 512.1c0-247.5-200.6-447.9-447.9-447.9C265 64.1 64.6 264.5 64.6 512z"></path>
</svg>
          </a>
        
      
        
          <a href="https://twitter.com/guanquanhong" class="soft-size--primary soft-style--box" target="_blank" rel="noopener noreferrer">
            <svg class="icon icon-twitter" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
  <path d="M962.285714 233.142857q-38.285714 56-92.571429 95.428571 0.571429 8 0.571429 24 0 74.285714-21.714286 148.285714t-66 142-105.428571 120.285714-147.428571 83.428571-184.571429 31.142857q-154.857143 0-283.428571-82.857143 20 2.285714 44.571429 2.285714 128.571429 0 229.142857-78.857143-60-1.142857-107.428571-36.857143t-65.142857-91.142857q18.857143 2.857143 34.857143 2.857143 24.571429 0 48.571429-6.285714-64-13.142857-106-63.714286t-42-117.428571l0-2.285714q38.857143 21.714286 83.428571 23.428571-37.714286-25.142857-60-65.714286t-22.285714-88q0-50.285714 25.142857-93.142857 69.142857 85.142857 168.285714 136.285714t212.285714 56.857143q-4.571429-21.714286-4.571429-42.285714 0-76.571429 54-130.571429t130.571429-54q80 0 134.857143 58.285714 62.285714-12 117.142857-44.571429-21.142857 65.714286-81.142857 101.714286 53.142857-5.714286 106.285714-28.571429z"></path>
</svg>
          </a>
        
      
    </div>
     
    <p>&copy; 2022 <a href="/" target="_blank">John Doe</a></p>

    
    
    <p>
      <a href="javascript:;" id="theme-light">🌞 浅色</a>
      <a href="javascript:;" id="theme-dark">🌛 深色</a>
      <a href="javascript:;" id="theme-auto">🤖️ 自动</a>
    </p>
  </div>
</footer>
  </div>

  <div class="back-to-top-fixed soft-size--round soft-style--box">
    <svg class="icon icon-back-to-top" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg">
      <path d="M725.333333 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8l-213.333333-213.333333c-17.066667-17.066667-17.066667-42.666667 0-59.733333s42.666667-17.066667 59.733333 0l213.333333 213.333333c17.066667 17.066667 17.066667 42.666667 0 59.733333C746.666667 422.4 738.133333 426.666667 725.333333 426.666667z"></path>
      <path d="M298.666667 426.666667c-12.8 0-21.333333-4.266667-29.866667-12.8-17.066667-17.066667-17.066667-42.666667 0-59.733333l213.333333-213.333333c17.066667-17.066667 42.666667-17.066667 59.733333 0s17.066667 42.666667 0 59.733333l-213.333333 213.333333C320 422.4 311.466667 426.666667 298.666667 426.666667z"></path>
      <path d="M512 896c-25.6 0-42.666667-17.066667-42.666667-42.666667L469.333333 170.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 682.666667C554.666667 878.933333 537.6 896 512 896z"></path>
    </svg>
  </div>

  
  <!-- aplayer -->


<!-- dplayer -->




  


  


  




<script src="/js/script.js"></script>


  
  <!-- 尾部用户自定义相关内容 -->
</body>
</html>
