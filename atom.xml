<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-31T07:25:06.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git-stach</title>
    <link href="http://example.com/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/"/>
    <id>http://example.com/2022/01/12/%E5%B7%A5%E5%85%B7/git-stach/</id>
    <published>2022-01-12T03:57:49.000Z</published>
    <updated>2022-05-31T07:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在一个栈上</p><p>后续你可以在任何时候任何分支重新将某次的修改推出来，重新应用这些更改的代码</p><p>默认情况下，<code>git stash</code>会缓存下列状态的文件：</p><ul><li>添加到暂存区的修改（staged changes）</li><li>Git跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ul><p>但以下状态的文件不会缓存：</p><ul><li>在工作目录中新的文件（untracked files）</li><li>被忽略的文件（ignored files）</li></ul><p>如果想要上述的文件都被缓存，可以使用<code>-u</code>或者<code>--include-untracked</code>可以工作目录新的文件，使用<code>-a</code>或者<code>--all</code>命令可以当前目录下的所有修改</p><h2 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h2><p>关于<code>git stash</code>常见的命令如下：</p><ul><li>git stash</li><li>git stash save</li><li>git stash list</li><li>git stash pop</li><li>git stash apply</li><li>git stash show</li><li>git stash drop</li><li>git stash clear</li></ul><h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><p>保存当前工作进度，会把暂存区和工作区的改动保存起来</p><h3 id="git-stash-save"><a href="#git-stash-save" class="headerlink" title="git stash save"></a>git stash save</h3><p><code>git stash save</code>可以用于存储修改.并且将<code>git</code>的工作状态切回到<code>HEAD</code>也就是上一次合法提交上</p><p>如果给定具体的文件路径,<code>git stash</code>只会处理路径下的文件.其他的文件不会被存储，其存在一些参数：</p><ul><li>–keep-index 或者 -k 只会存储为加入 git 管理的文件</li><li>–include-untracked 为追踪的文件也会被缓存,当前的工作空间会被恢复为完全清空的状态</li><li>-a 或者 –all 命令可以当前目录下的所有修改，包括被 git 忽略的文件</li></ul><h3 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h3><p>显示保存进度的列表。也就意味着，<code>git stash</code>命令可以多次执行，当多次使用<code>git stash</code>命令后，栈里会充满未提交的代码，如下：</p><p><img src="https://static.vue-js.com/50216dd0-fccf-11eb-bc6f-3f06e1491664.png" alt="img"></p><p>其中，<code>stash@&#123;0&#125;</code>、<code>stash@&#123;1&#125;</code>就是当前<code>stash</code>的名称</p><h3 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h3><p><code>git stash pop</code> 从栈中读取最近一次保存的内容，也就是栈顶的<code>stash</code>会恢复到工作区</p><p>也可以通过 <code>git stash pop</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p><p>如果从<code>stash</code>中恢复的内容和当前目录中的内容发生了冲突，则需要手动修复冲突或者创建新的分支来解决冲突</p><h3 id="git-stash-apply"><a href="#git-stash-apply" class="headerlink" title="git stash apply"></a>git stash apply</h3><p>将堆栈中的内容应用到当前目录，不同于<code>git stash pop</code>，该命令不会将内容从堆栈中删除</p><p>也就说该命令能够将堆栈的内容多次应用到工作目录中，适应于多个分支的情况</p><p>同样，可以通过<code>git stash apply</code> + <code>stash</code>名字执行恢复哪个<code>stash</code>恢复到当前目录</p><h3 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h3><p>查看堆栈中最新保存的<code>stash</code>和当前目录的差异</p><p>通过使用<code>git stash show -p</code>查看详细的不同</p><p>通过使用<code>git stash show stash@&#123;1&#125;</code>查看指定的<code>stash</code>和当前目录差异</p><p><img src="https://static.vue-js.com/458620a0-fccf-11eb-bc6f-3f06e1491664.png" alt="img"></p><h3 id="git-stash-drop"><a href="#git-stash-drop" class="headerlink" title="git stash drop"></a>git stash drop</h3><p><code>git stash drop</code> + <code>stash</code>名称表示从堆栈中移除某个指定的stash</p><h3 id="git-stash-clear"><a href="#git-stash-clear" class="headerlink" title="git stash clear"></a>git stash clear</h3><p>删除所有存储的进度</p><h2 id="三、应用场景"><a href="#三、应用场景" class="headerlink" title="三、应用场景"></a>三、应用场景</h2><p>当你在项目的一部分上已经工作一段时间后，所有东西都进入了混乱的状态， 而这时你想要切换到另一个分支或者拉下远端的代码去做一点别的事情</p><p>但是你创建一次未完成的代码的<code>commit</code>提交，这时候就可以使用<code>git stash</code></p><p>例如以下场景：</p><p>当你的开发进行到一半,但是代码还不想进行提交 ,然后需要同步去关联远端代码时.如果你本地的代码和远端代码没有冲突时,可以直接通过<code>git pull</code>解决</p><p>但是如果可能发生冲突怎么办.直接<code>git pull</code>会拒绝覆盖当前的修改，这时候就可以依次使用下述的命令：</p><ul><li>git stash</li><li>git pull</li><li>git stash pop</li></ul><p>或者当你开发到一半，现在要修改别的分支问题的时候，你也可以使用<code>git stash</code>缓存当前区域的代码</p><ul><li>git stash：保存开发到一半的代码</li><li>git commit -m ‘修改问题’</li><li>git stash pop：将代码追加到最新的提交之后</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; title=&quot;一、是什么&quot;&gt;&lt;/a&gt;一、是什么&lt;/h2&gt;&lt;p&gt;stash，译为存放，在 git 中，可以理解为保存当前工作进度，会把暂存区和工作区的改动进行保存，这些修改会保存在</summary>
      
    
    
    
    <category term="工具" scheme="http://example.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue3优化</title>
    <link href="http://example.com/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/10/16/Vue/vue3%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-16T00:26:19.000Z</published>
    <updated>2022-06-07T00:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、编译阶段"><a href="#一、编译阶段" class="headerlink" title="一、编译阶段"></a>一、编译阶段</h2><p>回顾<code>Vue2</code>，我们知道每个组件实例都对应一个 <code>watcher</code> 实例，它会在组件渲染的过程中把用到的数据<code>property</code>记录为依赖，当依赖发生改变，触发<code>setter</code>，则会通知<code>watcher</code>，从而使关联的组件重新渲染</p><p><img src="https://static.vue-js.com/39066120-5ed0-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>试想一下，一个组件结构如下图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span>&gt;</span>静态文本<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件内部只有一个动态节点，剩余一堆都是静态节点，所以这里很多 <code>diff</code> 和遍历其实都是不需要的，造成性能浪费</p><p>因此，<code>Vue3</code>在编译阶段，做了进一步优化。主要有如下：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><h4 id="diff算法优化"><a href="#diff算法优化" class="headerlink" title="diff算法优化"></a>diff算法优化</h4><p><code>vue3</code>在<code>diff</code>算法中相比<code>vue2</code>增加了静态标记</p><p>关于这个静态标记，其作用是为了会发生变化的地方添加一个<code>flag</code>标记，下次发生变化的时候直接找该地方进行比较</p><p>下图这里，已经标记静态节点的<code>p</code>标签在<code>diff</code>过程中则不会比较，把性能进一步提高</p><p><img src="https://static.vue-js.com/c732e150-5c58-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>关于静态类型枚举如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> enum <span class="title class_">PatchFlags</span> &#123;</span><br><span class="line">  <span class="variable constant_">TEXT</span> = <span class="number">1</span>,<span class="comment">// 动态的文本节点</span></span><br><span class="line">  <span class="variable constant_">CLASS</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 2 动态的 class</span></span><br><span class="line">  <span class="variable constant_">STYLE</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  <span class="comment">// 4 动态的 style</span></span><br><span class="line">  <span class="variable constant_">PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,  <span class="comment">// 8 动态属性，不包括类名和样式</span></span><br><span class="line">  <span class="variable constant_">FULL_PROPS</span> = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,  <span class="comment">// 16 动态 key，当 key 变化时需要完整的 diff 算法做比较</span></span><br><span class="line">  <span class="variable constant_">HYDRATE_EVENTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,  <span class="comment">// 32 表示带有事件监听器的节点</span></span><br><span class="line">  <span class="variable constant_">STABLE_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,   <span class="comment">// 64 一个不会改变子节点顺序的 Fragment</span></span><br><span class="line">  <span class="variable constant_">KEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">// 128 带有 key 属性的 Fragment</span></span><br><span class="line">  <span class="variable constant_">UNKEYED_FRAGMENT</span> = <span class="number">1</span> &lt;&lt; <span class="number">8</span>, <span class="comment">// 256 子节点没有 key 的 Fragment</span></span><br><span class="line">  <span class="variable constant_">NEED_PATCH</span> = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,   <span class="comment">// 512</span></span><br><span class="line">  <span class="variable constant_">DYNAMIC_SLOTS</span> = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,  <span class="comment">// 动态 solt</span></span><br><span class="line">  <span class="variable constant_">HOISTED</span> = -<span class="number">1</span>,  <span class="comment">// 特殊标志是负整数表示永远不会用作 diff</span></span><br><span class="line">  <span class="variable constant_">BAIL</span> = -<span class="number">2</span> <span class="comment">// 一个特殊的标志，指代差异算法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态提升"><a href="#静态提升" class="headerlink" title="静态提升"></a>静态提升</h4><p><code>Vue3</code>中对不参与更新的元素，会做静态提升，只会被创建一次，在渲染时直接复用</p><p>这样就免去了重复的创建节点，大型应用会受益于这个改动，免去了重复的创建操作，优化了运行时候的内存占用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;你好&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>没有做静态提升之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>),</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做了静态提升之后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/*#__PURE__*/</span><span class="title function_">_createVNode</span>(<span class="string">&quot;span&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;你好&quot;</span>, -<span class="number">1</span> <span class="comment">/* HOISTED */</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(_Fragment, <span class="literal">null</span>, [</span><br><span class="line">    _hoisted_1,</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">message</span>), <span class="number">1</span> <span class="comment">/* TEXT */</span>)</span><br><span class="line">  ], <span class="number">64</span> <span class="comment">/* STABLE_FRAGMENT */</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the console for the AST</span></span><br></pre></td></tr></table></figure><p>静态内容<code>_hoisted_1</code>被放置在<code>render</code> 函数外，每次渲染的时候只要取 <code>_hoisted_1</code> 即可</p><p>同时 <code>_hoisted_1</code> 被打上了 <code>PatchFlag</code> ，静态标记值为 -1 ，特殊标志是负整数表示永远不会用于 Diff</p><h4 id="事件监听缓存"><a href="#事件监听缓存" class="headerlink" title="事件监听缓存"></a>事件监听缓存</h4><p>默认情况下绑定事件行为会被视为动态绑定，所以每次都会去追踪它的变化</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;button @click = &#x27;onClick&#x27;&gt;点我&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>没开启事件监听器缓存</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> render = <span class="comment">/*#__PURE__*/</span><span class="title function_">_withId</span>(<span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123; <span class="attr">onClick</span>: _ctx.<span class="property">onClick</span> &#125;, <span class="string">&quot;点我&quot;</span>, <span class="number">8</span> <span class="comment">/* PROPS */</span>, [<span class="string">&quot;onClick&quot;</span>])</span><br><span class="line">                                             <span class="comment">// PROPS=1&lt;&lt;3,// 8 //动态属性，但不包含类名和样式</span></span><br><span class="line">  ]))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>开启事件侦听器缓存后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="title function_">_openBlock</span>(), <span class="title function_">_createBlock</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, [</span><br><span class="line">    <span class="title function_">_createVNode</span>(<span class="string">&quot;button&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">onClick</span>: _cache[<span class="number">1</span>] || (_cache[<span class="number">1</span>] = <span class="function">(<span class="params">...args</span>) =&gt;</span> (_ctx.<span class="title function_">onClick</span>(...args)))</span><br><span class="line">    &#125;, <span class="string">&quot;点我&quot;</span>)</span><br><span class="line">  ]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述发现开启了缓存后，没有了静态标记。也就是说下次<code>diff</code>算法的时候直接使用</p><h4 id="SSR优化"><a href="#SSR优化" class="headerlink" title="SSR优化"></a>SSR优化</h4><p>当静态内容大到一定量级时候，会用<code>createStaticVNode</code>方法在客户端去生成一个static node，这些静态<code>node</code>，会被直接<code>innerHtml</code>，就不需要创建对象，然后根据对象渲染</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">...  <span class="comment">// 很多个静态属性</span></span><br><span class="line">&lt;div&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mergeProps <span class="keyword">as</span> _mergeProps &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123; ssrRenderAttrs <span class="keyword">as</span> _ssrRenderAttrs, ssrInterpolate <span class="keyword">as</span> _ssrInterpolate &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/server-renderer&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">ssrRender</span>(<span class="params">_ctx, _push, _parent, _attrs, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _cssVars = &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: _ctx.<span class="property">color</span> &#125;&#125;</span><br><span class="line">  <span class="title function_">_push</span>(<span class="string">`&lt;div<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrRenderAttrs(_mergeProps(_attrs, _cssVars))</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&gt;&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;...&lt;div&gt;&lt;span&gt;你好&lt;/span&gt;&lt;div&gt;&lt;span&gt;<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">    _ssrInterpolate(_ctx.message)</span></span></span><br><span class="line"><span class="subst"><span class="string">  &#125;</span>&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、源码体积"><a href="#二、源码体积" class="headerlink" title="二、源码体积"></a>二、源码体积</h2><p>相比<code>Vue2</code>，<code>Vue3</code>整体体积变小了，除了移出一些不常用的API，再重要的是<code>Tree shanking</code></p><p>任何一个函数，如<code>ref</code>、<code>reavtived</code>、<code>computed</code>等，仅仅在用到的时候才打包，没用到的模块都被摇掉，打包的整体体积变小</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; computed, defineComponent, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> readOnlyAge = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> age.<span class="property">value</span>++) <span class="comment">// 19</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            age,</span><br><span class="line">            state,</span><br><span class="line">            readOnlyAge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="三、响应式系统"><a href="#三、响应式系统" class="headerlink" title="三、响应式系统"></a>三、响应式系统</h2><p><code>vue2</code>中采用 <code>defineProperty</code>来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加<code>getter</code>和<code>setter</code>，实现响应式</p><p><code>vue3</code>采用<code>proxy</code>重写了响应式系统，因为<code>proxy</code>可以对整个对象进行监听，所以不需要深度遍历</p><ul><li>可以监听动态属性的添加</li><li>可以监听到数组的索引和数组<code>length</code>属性</li><li>可以监听删除属性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、编译阶段&quot;&gt;&lt;a href=&quot;#一、编译阶段&quot; class=&quot;headerlink&quot; title=&quot;一、编译阶段&quot;&gt;&lt;/a&gt;一、编译阶段&lt;/h2&gt;&lt;p&gt;回顾&lt;code&gt;Vue2&lt;/code&gt;，我们知道每个组件实例都对应一个 &lt;code&gt;watcher&lt;/cod</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue3-设计目标、做了哪些优化</title>
    <link href="http://example.com/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2021/10/11/Vue/Vue3-%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87%E3%80%81%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8C%96/</id>
    <published>2021-10-11T13:19:27.000Z</published>
    <updated>2022-06-07T00:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、设计目标"><a href="#一、设计目标" class="headerlink" title="一、设计目标"></a>一、设计目标</h2><p>不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下<code>Vue3</code>之前我们或许会面临的问题</p><ul><li>随着功能的增长，复杂组件的代码变得越来越难以维护</li><li>缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制</li><li>类型推断不够友好</li><li><code>bundle</code>的时间太久了</li></ul><p>而 <code>Vue3</code> 经过长达两三年时间的筹备，做了哪些事情？</p><p>我们从结果反推</p><ul><li>更小</li><li>更快</li><li>TypeScript支持</li><li>API设计一致性</li><li>提高自身可维护性</li><li>开放更多底层功能</li></ul><p>一句话概述，就是更小更快更友好了</p><h3 id="更小"><a href="#更小" class="headerlink" title="更小"></a>更小</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue3`移除一些不常用的 `API</span><br></pre></td></tr></table></figure><p>引入<code>tree-shaking</code>，可以将无用模块“剪辑”，仅打包需要的，使打包的整体体积变小了</p><h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>主要体现在编译方面：</p><ul><li>diff算法优化</li><li>静态提升</li><li>事件监听缓存</li><li>SSR优化</li></ul><p>下篇文章我们会进一步介绍</p><h3 id="更友好"><a href="#更友好" class="headerlink" title="更友好"></a>更友好</h3><p><code>vue3</code>在兼顾<code>vue2</code>的<code>options API</code>的同时还推出了<code>composition API</code>，大大增加了代码的逻辑组织和代码复用能力</p><p>这里代码简单演示下：</p><p>存在一个获取鼠标位置的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要调用这个函数，即可获取<code>x</code>、<code>y</code>的坐标，完全不用关注实现过程</p><p>试想一下，如果很多类似的第三方库，我们只需要调用即可，不必关注实现过程，开发效率大大提高</p><p>同时，<code>VUE3</code>是基于<code>typescipt</code>编写的，可以享受到自动的类型定义提示</p><h2 id="三、优化方案"><a href="#三、优化方案" class="headerlink" title="三、优化方案"></a>三、优化方案</h2><p><code>vue3</code>从很多层面都做了优化，可以分成三个方面：</p><ul><li>源码</li><li>性能</li><li>语法 API</li></ul><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码可以从两个层面展开：</p><ul><li>源码管理</li><li>TypeScript</li></ul><h4 id="源码管理"><a href="#源码管理" class="headerlink" title="源码管理"></a>源码管理</h4><p><code>vue3</code>整个源码是通过 <code>monorepo</code>的方式维护的，根据功能将不同的模块拆分到<code>packages</code>目录下面不同的子目录中</p><p><img src="https://static.vue-js.com/d7c32520-5c58-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>这样使得模块拆分更细化，职责划分更明确，模块之间的依赖关系也更加明确，开发人员也更容易阅读、理解和更改所有模块源码，提高代码的可维护性</p><p>另外一些 <code>package</code>（比如 <code>reactivity</code> 响应式库）是可以独立于 <code>Vue</code> 使用的，这样用户如果只想使用 <code>Vue3</code>的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 <code>Vue</code></p><h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p><code>Vue3</code>是基于<code>typeScript</code>编写的，提供了更好的类型检查，能支持复杂的类型推导</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>vue3</code>是从什么哪些方面对性能进行进一步优化呢？</p><ul><li>体积优化</li><li>编译优化</li><li>数据劫持优化</li></ul><p>这里讲述数据劫持：</p><p>在<code>vue2</code>中，数据劫持是通过<code>Object.defineProperty</code>，这个 API 有一些缺陷，并不能检测对象属性的添加和删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;a&#x27;</span>,&#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// track</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// trigger</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>尽管<code>Vue</code>为了解决这个问题提供了 <code>set</code>和<code>delete</code>实例方法，但是对于用户来说，还是增加了一定的心智负担</p><p>同时在面对嵌套层级比较深的情况下，就存在性能问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: &#123;</span><br><span class="line">      <span class="attr">b</span>: &#123;</span><br><span class="line">          <span class="attr">c</span>: &#123;</span><br><span class="line">          <span class="attr">d</span>: <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比之下，<code>vue3</code>是通过<code>proxy</code>监听整个对象，那么对于删除还是监听当然也能监听到</p><p>同时<code>Proxy</code> 并不能监听到内部深层次的对象变化，而 <code>Vue3</code> 的处理方式是在<code>getter</code> 中去递归响应式，这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归</p><h3 id="语法-API"><a href="#语法-API" class="headerlink" title="语法 API"></a>语法 API</h3><p>这里当然说的就是<code>composition API</code>，其两大显著的优化：</p><ul><li>优化逻辑组织</li><li>优化逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><p>一张图，我们可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势</p><p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>相同功能的代码编写在一块，而不像<code>options API</code>那样，各个功能的代码混成一块</p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>vue2</code>中，我们是通过<code>mixin</code>实现功能混合，如果多个<code>mixin</code>混合，会存在两个非常明显的问题：命名冲突和数据来源不清晰</p><p>而通过<code>composition</code>这种形式，可以将一些复用的代码抽离出来作为一个函数，只要的使用的地方直接进行调用即可</p><p>同样是上文的获取鼠标位置的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs, reactive, onUnmounted, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useMouse</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;<span class="attr">x</span>:<span class="number">0</span>,<span class="attr">y</span>:<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">update</span> = e=&gt;&#123;</span><br><span class="line">        state.<span class="property">x</span> = e.<span class="property">pageX</span>;</span><br><span class="line">        state.<span class="property">y</span> = e.<span class="property">pageY</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;mousemove&#x27;</span>,update);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">toRefs</span>(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> useMousePosition <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">useMousePosition</span>()</span><br><span class="line">        <span class="keyword">return</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的<code>hook</code>函数，也不会出现命名冲突的问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、设计目标&quot;&gt;&lt;a href=&quot;#一、设计目标&quot; class=&quot;headerlink&quot; title=&quot;一、设计目标&quot;&gt;&lt;/a&gt;一、设计目标&lt;/h2&gt;&lt;p&gt;不以解决实际业务痛点的更新都是耍流氓，下面我们来列举一下&lt;code&gt;Vue3&lt;/code&gt;之前我们或许会面临</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue3-Treeshaking</title>
    <link href="http://example.com/2021/09/29/Vue/vue3-Treeshaking/"/>
    <id>http://example.com/2021/09/29/Vue/vue3-Treeshaking/</id>
    <published>2021-09-29T01:48:38.000Z</published>
    <updated>2022-06-07T00:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tree shaking` 是一种通过清除多余代码方式来优化项目打包体积的技术，专业术语叫 `Dead code elimination</span><br></pre></td></tr></table></figure><p>简单来讲，就是在保持代码运行结果不变的前提下，去除无用的代码</p><p>如果把代码打包比作制作蛋糕，传统的方式是把鸡蛋（带壳）全部丢进去搅拌，然后放入烤箱，最后把（没有用的）蛋壳全部挑选并剔除出去</p><p>而<code>treeshaking</code>则是一开始就把有用的蛋白蛋黄（import）放入搅拌，最后直接作出蛋糕</p><p>也就是说 ，<code>tree shaking</code> 其实是找出使用的代码</p><p>在<code>Vue2</code>中，无论我们使用什么功能，它们最终都会出现在生产代码中。主要原因是<code>Vue</code>实例在项目中是单例的，捆绑程序无法检测到该对象的哪些属性在代码中被使用到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>而<code>Vue3</code>源码引入<code>tree shaking</code>特性，将全局 API 进行分块。如果您不使用其某些功能，它们将不会包含在您的基础包中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; nextTick, observable &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><h2 id="二、如何做"><a href="#二、如何做" class="headerlink" title="二、如何做"></a>二、如何做</h2><p><code>Tree shaking</code>是基于<code>ES6</code>模板语法（<code>import</code>与<code>exports</code>），主要是借助<code>ES6</code>模块的静态编译思想，在编译时就能确定模块的依赖关系，以及输入和输出的变量</p><p><code>Tree shaking</code>无非就是做了两件事：</p><ul><li>编译阶段利用<code>ES6 Module</code>判断哪些模块已经加载</li><li>判断那些模块和变量未被使用或者引用，进而删除对应代码</li></ul><p>下面就来举个例子：</p><p>通过脚手架<code>vue-cli</code>安装<code>Vue2</code>与<code>Vue3</code>项目</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vue-demo</span><br></pre></td></tr></table></figure><h3 id="Vue2-项目"><a href="#Vue2-项目" class="headerlink" title="Vue2 项目"></a>Vue2 项目</h3><p>组件中使用<code>data</code>属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data: () =&gt; (&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">        &#125;),</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>对项目进行打包，体积如下图</p><p><img src="https://static.vue-js.com/6bd2aff0-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>为组件设置其他属性（<code>compted</code>、<code>watch</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">question</span>:<span class="string">&quot;&quot;</span>, </span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="attr">computed</span>: &#123;</span><br><span class="line">        <span class="attr">double</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">watch</span>: &#123;</span><br><span class="line">        <span class="attr">question</span>: <span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">answer</span> = <span class="string">&#x27;xxxx&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再一次打包，发现打包出来的体积并没有变化</p><p><img src="https://static.vue-js.com/7c29e260-6097-11eb-ab90-d9ae814b240d.png" alt="img"></p><h3 id="Vue3-项目"><a href="#Vue3-项目" class="headerlink" title="Vue3 项目"></a>Vue3 项目</h3><p>组件中简单使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将项目进行打包</p><p><img src="https://static.vue-js.com/95df0000-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>在组件中引入<code>computed</code>和<code>watch</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, defineComponent, computed, watch &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.<span class="property">count</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">watch</span>(</span><br><span class="line">      <span class="function">() =&gt;</span> state.<span class="property">count</span>,</span><br><span class="line">      <span class="function">(<span class="params">count, preCount</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(preCount);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      double,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再次对项目进行打包，可以看到在引入<code>computer</code>和<code>watch</code>之后，项目整体体积变大了</p><p><img src="https://static.vue-js.com/b36a7a00-6097-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><h2 id="三、作用"><a href="#三、作用" class="headerlink" title="三、作用"></a>三、作用</h2><p>通过<code>Tree shaking</code>，<code>Vue3</code>给我们带来的好处是：</p><ul><li>减少程序体积（更小）</li><li>减少程序执行时间（更快）</li><li>便于将来对程序架构进行优化（更友好）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、是什么&quot;&gt;&lt;a href=&quot;#一、是什么&quot; class=&quot;headerlink&quot; title=&quot;一、是什么&quot;&gt;&lt;/a&gt;一、是什么&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue3-Proxy API 替代 defineProperty API</title>
    <link href="http://example.com/2021/09/26/Vue/vue3-Proxy%20API%20%E6%9B%BF%E4%BB%A3%20defineProperty%20API%20/"/>
    <id>http://example.com/2021/09/26/Vue/vue3-Proxy%20API%20%E6%9B%BF%E4%BB%A3%20defineProperty%20API%20/</id>
    <published>2021-09-26T04:54:42.000Z</published>
    <updated>2022-06-07T00:49:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Object-defineProperty"><a href="#一、Object-defineProperty" class="headerlink" title="一、Object.defineProperty"></a>一、Object.defineProperty</h2><p>定义：<code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象</p><h5 id="为什么能实现响应式"><a href="#为什么能实现响应式" class="headerlink" title="#为什么能实现响应式"></a><a href="https://vue3js.cn/interview/vue3/proxy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%AE%9E%E7%8E%B0%E5%93%8D%E5%BA%94%E5%BC%8F">#</a>为什么能实现响应式</h5><p>通过<code>defineProperty</code> 两个属性，<code>get</code>及<code>set</code></p><ul><li>get</li></ul><p>属性的 getter 函数，当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值</p><ul><li>set</li></ul><p>属性的 setter 函数，当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。默认为 undefined</p><p>下面通过代码展示：</p><p>定义一个响应式函数<code>defineReactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    app.<span class="property">innerText</span> = obj.<span class="property">foo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>defineReactive</code>，数据发生变化触发<code>update</code>方法，实现数据响应式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="title function_">defineReactive</span>(obj, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    obj.<span class="property">foo</span> = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toLocaleTimeString</span>()</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>在对象存在多个<code>key</code>情况下，需要进行遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在嵌套对象的情况，还需要在<code>defineReactive</code>中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="title function_">observe</span>(val)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`get <span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">                val = newVal</span><br><span class="line">                <span class="title function_">update</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当给<code>key</code>赋值为对象的时候，还需要在<code>set</code>属性中进行递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">        <span class="title function_">observe</span>(newVal) <span class="comment">// 新值是对象的情况</span></span><br><span class="line">        <span class="title function_">notifyUpdate</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子能够实现对一个对象的基本响应式，但仍然存在诸多问题</p><p>现在对一个对象进行删除与添加属性操作，无法劫持到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">bar</span>: <span class="string">&quot;bar&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">observe</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">foo</span> <span class="comment">// no ok</span></span><br><span class="line">obj.<span class="property">jar</span> = <span class="string">&#x27;xxx&#x27;</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>当我们对一个数组进行监听的时候，并不那么好使了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrData = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arrData.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="title function_">defineProperty</span>(arrData,index,val)</span><br><span class="line">&#125;)</span><br><span class="line">arrData.<span class="title function_">push</span>() <span class="comment">// no ok</span></span><br><span class="line">arrData.<span class="title function_">pop</span>()  <span class="comment">// no ok</span></span><br><span class="line">arrDate[<span class="number">0</span>] = <span class="number">99</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>可以看到数据的<code>api</code>无法劫持到，从而无法实现数据响应式，</p><p>所以在<code>Vue2</code>中，增加了<code>set</code>、<code>delete</code> API，并且对数组<code>api</code>方法进行一个重写</p><p>还有一个问题则是，如果存在深层的嵌套对象关系，需要深层的进行监听，造成了性能的极大问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>检测不到对象属性的添加和删除</li><li>数组<code>API</code>方法无法监听到</li><li>需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题</li></ul><h2 id="二、proxy"><a href="#二、proxy" class="headerlink" title="二、proxy"></a>二、proxy</h2><p><code>Proxy</code>的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作，这就完全可以代理所有属性了</p><p>在<code>ES6</code>系列中，我们详细讲解过<code>Proxy</code>的使用，就不再述说了</p><p>下面通过代码进行展示：</p><p>定义一个响应式方法<code>reactive</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下简单数据的操作，发现都能劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1.获取</span></span><br><span class="line">state.<span class="property">foo</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 2.设置已存在属性</span></span><br><span class="line">state.<span class="property">foo</span> = <span class="string">&#x27;fooooooo&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 3.设置不存在属性</span></span><br><span class="line">state.<span class="property">dong</span> = <span class="string">&#x27;dong&#x27;</span> <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 4.删除属性</span></span><br><span class="line"><span class="keyword">delete</span> state.<span class="property">dong</span> <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>再测试嵌套对象情况，这时候发现就不那么 OK 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">bar</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置嵌套对象属性</span></span><br><span class="line">state.<span class="property">bar</span>.<span class="property">a</span> = <span class="number">10</span> <span class="comment">// no ok</span></span><br></pre></td></tr></table></figure><p>如果要解决，需要在<code>get</code>之上再进行一层代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">isObject</span>(res) ? <span class="title function_">reactive</span>(res) : res</span><br><span class="line">        &#125;,</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><code>Object.defineProperty</code>只能遍历对象属性进行劫持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">defineReactive</span>(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Proxy相当于在对象外层加拦截</span></span><br><span class="line">    <span class="keyword">const</span> observed = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`获取<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`设置<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">deleteProperty</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> res = <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, key)</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`删除<span class="subst">$&#123;key&#125;</span>:<span class="subst">$&#123;res&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> observed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy</code>可以直接监听数组的变化（<code>push</code>、<code>shift</code>、<code>splice</code>）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> proxtObj = <span class="title function_">reactive</span>(obj)</span><br><span class="line">obj.<span class="title function_">psuh</span>(<span class="number">4</span>) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><code>Proxy</code>有多达13种拦截方法,不限于<code>apply</code>、<code>ownKeys</code>、<code>deleteProperty</code>、<code>has</code>等等，这是<code>Object.defineProperty</code>不具备的</p><p>正因为<code>defineProperty</code>自身的缺陷，导致<code>Vue2</code>在实现响应式过程需要实现其他的方法辅助（如重写数组方法、增加额外<code>set</code>、<code>delete</code>方法）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组重写</span></span><br><span class="line"><span class="keyword">const</span> originalProto = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="title class_">Object</span>.<span class="title function_">create</span>(originalProto)</span><br><span class="line">[<span class="string">&#x27;push&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;shift&#x27;</span>, <span class="string">&#x27;unshift&#x27;</span>, <span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;reverse&#x27;</span>, <span class="string">&#x27;sort&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">  arrayProto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    originalProto[method].<span class="title function_">apply</span>(<span class="variable language_">this</span>.<span class="property">arguments</span>)</span><br><span class="line">    dep.<span class="title function_">notice</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// set、delete</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj,<span class="string">&#x27;bar&#x27;</span>,<span class="string">&#x27;newbar&#x27;</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">delete</span>(obj),<span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>Proxy</code> 不兼容IE，也没有 <code>polyfill</code>, <code>defineProperty</code> 能支持到IE9</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Object-defineProperty&quot;&gt;&lt;a href=&quot;#一、Object-defineProperty&quot; class=&quot;headerlink&quot; title=&quot;一、Object.defineProperty&quot;&gt;&lt;/a&gt;一、Object.definePr</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue3-Composition API详解</title>
    <link href="http://example.com/2021/09/14/Vue/vue3-Composition%20API%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2021/09/14/Vue/vue3-Composition%20API%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-09-14T03:26:49.000Z</published>
    <updated>2022-06-07T00:48:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Composition API</code>也叫组合式API，是Vue3.x的新特性。</p><blockquote><p>通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。在处理如此大的应用程序时，共享和重用代码变得尤为重要</p></blockquote><p><strong>通俗的讲：</strong></p><p>没有<code>Composition API</code>之前vue相关业务的代码需要配置到option的特定的区域，中小型项目是没有问题的，但是在大型项目中会导致后期的维护性比较复杂，同时代码可复用性不高。Vue3.x中的composition-api就是为了解决这个问题而生的</p><p><strong>compositon api提供了以下几个函数：</strong></p><ul><li><code>setup</code></li><li><code>ref</code></li><li><code>reactive</code></li><li><code>watchEffect</code></li><li><code>watch</code></li><li><code>computed</code></li><li><code>toRefs</code></li><li>生命周期的<code>hooks</code></li></ul><h2 id="一、setup组件选项"><a href="#一、setup组件选项" class="headerlink" title="一、setup组件选项"></a>一、setup组件选项</h2><blockquote><p>新的 <code>setup</code> 组件选项在<strong>创建组件之前</strong>执行，一旦 <code>props</code> 被解析，并充当合成 <code>API</code> 的入口点</p></blockquote><p><strong>提示：</strong></p><blockquote><p>由于在执行 <code>setup</code> 时尚未创建组件实例，因此在 <code>setup</code> 选项中没有 <code>this</code>。这意味着，除了<code>props</code>之外，你将无法访问组件中声明的任何属性——本地状态、计算属性或方法。</p></blockquote><p>使用 <code>setup</code> 函数时，它将接受两个参数：</p><ol><li><code>props</code></li><li><code>context</code></li></ol><p>让我们更深入地研究如何使用每个参数</p><h3 id="1-Props"><a href="#1-Props" class="headerlink" title="1. Props"></a>1. Props</h3><blockquote><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 <code>prop</code> 时，它将被更新</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: String</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    console.log(props.title)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>但是，因为 <code>props</code> 是响应式的，你不能使用 <code>ES6</code> 解构，因为它会消除 <code>prop</code> 的响应性。</p></blockquote><p>如果需要解构 prop，可以通过使用 <code>setup</code> 函数中的 <a href="https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 来安全地完成此操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">import &#123; toRefs &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">setup(props) &#123;</span><br><span class="line">const &#123; title &#125; = toRefs(props)</span><br><span class="line"></span><br><span class="line">console.log(title.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-上下文"><a href="#2-上下文" class="headerlink" title="2. 上下文"></a>2. 上下文</h3><blockquote><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露三个组件的 property</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    // Attribute (非响应式对象)</span><br><span class="line">    console.log(context.attrs)</span><br><span class="line"></span><br><span class="line">    // 插槽 (非响应式对象)</span><br><span class="line">    console.log(context.slots)</span><br><span class="line"></span><br><span class="line">    // 触发事件 (方法)</span><br><span class="line">    console.log(context.emit)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// MyBook.vue</span><br><span class="line">export default &#123;</span><br><span class="line">  setup(props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 更改应用副作用，那么应该在 <code>onUpdated</code>生命周期钩子中执行此操作。</p></blockquote><h3 id="3-setup组件的-property"><a href="#3-setup组件的-property" class="headerlink" title="3. setup组件的 property"></a>3. setup组件的 property</h3><blockquote><p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p></blockquote><ul><li><code>props</code></li><li><code>attrs</code></li><li><code>slots</code></li><li><code>emit</code></li></ul><p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p><ul><li><code>data</code></li><li><code>computed</code></li><li><code>methods</code></li></ul><h3 id="4-ref-reactive-以及setup结合模板使用"><a href="#4-ref-reactive-以及setup结合模板使用" class="headerlink" title="4. ref reactive 以及setup结合模板使用"></a>4. ref reactive 以及setup结合模板使用</h3><p>在看<code>setup</code>结合模板使用之前，我们首先得知道<code>ref</code> 和 <code>reactive</code> 方法。</p><p>如果 <code>setup</code> 返回一个对象则可以在模板中绑定对象中的属性和方法，但是要定义响应式数据的时候可以使用<code>ref</code>, <code>reactive</code>方法定义响应式的数据</p><h5 id="错误写法："><a href="#错误写法：" class="headerlink" title="错误写法："></a><strong>错误写法：</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = &quot;这是setup中的msg&quot;;</span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;)</span><br><span class="line">            msg = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="正确写法一："><a href="#正确写法一：" class="headerlink" title="正确写法一："></a><strong>正确写法一：</strong></h5><blockquote><p><strong>ref</strong>用来定义响应式的 字符串、 数值、 数组、<code>Bool</code>类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">import &#123;  </span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变etup中的msg&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line"></span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = ref(&quot;这是setup中的msg&quot;);</span><br><span class="line"></span><br><span class="line">        let list = ref([&quot;马总&quot;, &quot;李总&quot;, &quot;刘总&quot;])</span><br><span class="line"></span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            msg.value = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            list,</span><br><span class="line">            updateMsg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h5 id="正确写法二："><a href="#正确写法二：" class="headerlink" title="正确写法二："></a><strong>正确写法二：</strong></h5><p><strong>reactive</strong> 用来定义响应式的对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    reactive   </span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">&#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateMsg&quot;&gt;改变setup中的msg&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li v-for=&quot;(item,index) in list&quot; :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&#123;&#123;setupData.title&#125;&#125;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button @click=&quot;updateTitle&quot;&gt;更新setup中的title&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    ref</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let msg = ref(&quot;这是setup中的msg&quot;);</span><br><span class="line"></span><br><span class="line">        let setupData = reactive(&#123;</span><br><span class="line">            title: &quot;reactive定义响应式数据的title&quot;,</span><br><span class="line">            userinfo: &#123;</span><br><span class="line">                username: &quot;张三&quot;,</span><br><span class="line">                age: 20</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let updateMsg = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            msg.value = &quot;改变后的值&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        let updateTitle = () =&gt; &#123;</span><br><span class="line">            alert(&quot;触发方法&quot;);</span><br><span class="line">            setupData.title = &quot;我是改变后的title&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;</span><br><span class="line">            msg,</span><br><span class="line">            setupData,</span><br><span class="line">            updateMsg,</span><br><span class="line">            updateTitle</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">.home &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>**说明:**要改变ref定义的属性名称需要通过 <code>属性名称.value</code>来修改，要改变<code>reactive</code>中定义的对象名称可以直接</p><h3 id="5-使用-this"><a href="#5-使用-this" class="headerlink" title="5. 使用 this"></a>5. 使用 <code>this</code></h3><blockquote><p><strong>在 <code>setup()</code> 内部，<code>this</code> 不会是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这在和其它选项式 API 一起使用 <code>setup()</code> 时可能会导致混淆</p></blockquote><h2 id="二、toRefs-解构响应式对象数据"><a href="#二、toRefs-解构响应式对象数据" class="headerlink" title="二、toRefs - 解构响应式对象数据"></a>二、toRefs - 解构响应式对象数据</h2><blockquote><p>把一个响应式对象转换成普通对象，该普通对象的每个 <code>property</code> 都是一个 <code>ref</code> ，和响应式对象 <code>property</code> 一一对应</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user = reactive(&#123;</span><br><span class="line">            username: &quot;张三&quot;,</span><br><span class="line">            age: 10000,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user)</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 &#x2F; 扩展（使用 <code>…</code>操作符）返回的对象，并不会丢失响应性：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function useFeatureX() &#123;</span><br><span class="line">  const state = reactive(&#123;</span><br><span class="line">    foo: 1,</span><br><span class="line">    bar: 2,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  // 对 state 的逻辑操作</span><br><span class="line">  // ....</span><br><span class="line"></span><br><span class="line">  // 返回时将属性都转为 ref</span><br><span class="line">  return toRefs(state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // 可以解构，不会丢失响应性</span><br><span class="line">    const &#123; foo, bar &#125; = useFeatureX()</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      foo,</span><br><span class="line">      bar,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、computed-计算属性"><a href="#三、computed-计算属性" class="headerlink" title="三、computed - 计算属性"></a>三、computed - 计算属性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;解构响应式对象数据+computed&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot; placeholder=&quot;firstName&quot; /&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot; placeholder=&quot;lastName&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &#123;&#123;fullName&#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    toRefs,</span><br><span class="line">    computed</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;解构响应式对象数据&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const user = reactive(&#123;</span><br><span class="line">            firstName: &quot;&quot;,</span><br><span class="line">            lastName: &quot;&quot;,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        const fullName = computed(() =&gt; &#123;</span><br><span class="line">            return user.firstName + &quot; &quot; + user.lastName</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            ...toRefs(user),</span><br><span class="line">            fullName</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="四、readonly-“深层”的只读代理"><a href="#四、readonly-“深层”的只读代理" class="headerlink" title="四、readonly “深层”的只读代理"></a>四、readonly “深层”的只读代理</h2><blockquote><p>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;readonly - “深层”的只读代理&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; reactive, readonly &#125; from &quot;vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Readonly&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const original = reactive(&#123; count: 0 &#125;);</span><br><span class="line">    const copy = readonly(original);</span><br><span class="line"></span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">      original.count++;</span><br><span class="line">      copy.count++; // 报警告，Set operation on key &quot;count&quot; failed: target is readonly. Proxy &#123;count: 1&#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return &#123; original, copy &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="五、watchEffect"><a href="#五、watchEffect" class="headerlink" title="五、watchEffect"></a>五、watchEffect</h2><blockquote><p>在响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watchEffect - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;stop&quot;&gt;手动关闭侦听器&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watchEffect</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;WatchEffect&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const data = reactive(&#123;</span><br><span class="line">            count: 1,</span><br><span class="line">            num: 1</span><br><span class="line">        &#125;);</span><br><span class="line">        const stop = watchEffect(() =&gt; console.log(`侦听器：$&#123;data.count&#125;`));</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            data.count++;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        return &#123;</span><br><span class="line">            data,</span><br><span class="line">            stop</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="六、watch-、watch-与watchEffect区别"><a href="#六、watch-、watch-与watchEffect区别" class="headerlink" title="六、watch 、watch 与watchEffect区别"></a>六、watch 、watch 与watchEffect区别</h2><p>对比<code>watchEffect</code>，**<code>watch</code>允许我们**：</p><ul><li>懒执行，也就是说仅在侦听的源变更时才执行回调；</li><li>更明确哪些状态的改变会触发侦听器重新运行；</li><li>访问侦听状态变化前后的值</li></ul><p><strong>更明确哪些状态的改变会触发侦听器重新运行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;count1: &#123;&#123;data.count1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;count2: &#123;&#123;data.count2&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;button @click=&quot;stopAll&quot;&gt;Stop All&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    reactive,</span><br><span class="line">    watch</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        const data = reactive(&#123;</span><br><span class="line">            count1: 0,</span><br><span class="line">            count2: 0</span><br><span class="line">        &#125;);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        const stop1 = watch(data, () =&gt;</span><br><span class="line">            console.log(&quot;watch1&quot;, data.count1, data.count2)</span><br><span class="line">        );</span><br><span class="line">        // 侦听多个数据源</span><br><span class="line">        const stop2 = watch([data], () =&gt; &#123;</span><br><span class="line">            console.log(&quot;watch2&quot;, data.count1, data.count2);</span><br><span class="line">        &#125;);</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            data.count1++;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">        return &#123;</span><br><span class="line">            data,</span><br><span class="line">            stopAll: () =&gt; &#123;</span><br><span class="line">                stop1();</span><br><span class="line">                stop2();</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>访问侦听状态变化前后的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; v-model=&quot;keywords&quot; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    ref,</span><br><span class="line">    watch</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let keywords = ref(&quot;111&quot;);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        watch(keywords, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">            console.log(newValue, oldValue)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            keywords</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>懒执行，也就是说仅在侦听的源变更时才执行回调</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;num1=&#123;&#123;num1&#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;num2=&#123;&#123;num2&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;</span><br><span class="line">    ref,</span><br><span class="line">    watch,</span><br><span class="line">    watchEffect</span><br><span class="line">&#125; from &quot;vue&quot;;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &quot;Watch&quot;,</span><br><span class="line">    setup() &#123;</span><br><span class="line">        let num1 = ref(10);</span><br><span class="line">        let num2 = ref(10);</span><br><span class="line">        // 侦听单个数据源</span><br><span class="line">        watch(num1, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">            console.log(newValue, oldValue)</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        watchEffect(() =&gt; console.log(`watchEffect侦听器：$&#123;num2.value&#125;`));</span><br><span class="line"></span><br><span class="line">        return &#123;</span><br><span class="line">            num1,</span><br><span class="line">            num2</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="七、组合式api生命周期钩子"><a href="#七、组合式api生命周期钩子" class="headerlink" title="七、组合式api生命周期钩子"></a>七、组合式api生命周期钩子</h2><p>你可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。</p><p>下表包含如何在 <a href="https://v3.cn.vuejs.org/guide/composition-api-setup.html">setup ()</a> 内部调用生命周期钩子：</p><table><thead><tr><th align="left">选项式 API</th><th align="left">Hook inside <code>setup</code></th></tr></thead><tbody><tr><td align="left"><code>beforeCreate</code></td><td align="left">不需要*</td></tr><tr><td align="left"><code>created</code></td><td align="left">不需要*</td></tr><tr><td align="left"><code>beforeMount</code></td><td align="left"><code>onBeforeMount</code></td></tr><tr><td align="left"><code>mounted</code></td><td align="left"><code>onMounted</code></td></tr><tr><td align="left"><code>beforeUpdate</code></td><td align="left"><code>onBeforeUpdate</code></td></tr><tr><td align="left"><code>updated</code></td><td align="left"><code>onUpdated</code></td></tr><tr><td align="left"><code>beforeUnmount</code></td><td align="left"><code>onBeforeUnmount</code></td></tr><tr><td align="left"><code>unmounted</code></td><td align="left"><code>onUnmounted</code></td></tr><tr><td align="left"><code>errorCaptured</code></td><td align="left"><code>onErrorCaptured</code></td></tr><tr><td align="left"><code>renderTracked</code></td><td align="left"><code>onRenderTracked</code></td></tr><tr><td align="left"><code>renderTriggered</code></td><td align="left"><code>onRenderTriggered</code></td></tr></tbody></table><blockquote><p>因为 <code>setup</code> 是围绕 <code>beforeCreate</code> 和 <code>created</code> 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 <code>setup</code> 函数中编写</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // mounted</span><br><span class="line">    onMounted(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;Component is mounted!&#x27;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、Provider-Inject"><a href="#八、Provider-Inject" class="headerlink" title="八、Provider Inject"></a>八、Provider Inject</h2><p>通常，当我们需要将数据从父组件传递到子组件时，我们使用 <a href="https://v3.cn.vuejs.org/guide/component-props.html">props</a>。想象一下这样的结构：你有一些深嵌套的组件，而你只需要来自深嵌套子组件中父组件的某些内容。在这种情况下，你仍然需要将 prop 传递到整个组件链中，这可能会很烦人</p><blockquote><p>对于这种情况，我们可以使用 <code>provide</code> 和 <code>inject</code> 对父组件可以作为其所有子组件的依赖项提供程序，而不管组件层次结构有多深。这个特性有两个部分：父组件有一个 <code>provide</code> 选项来提供数据，子组件有一个 <code>inject</code> 选项来开始使用这个数据</p></blockquote><h3 id="1-非组合式api中的写法"><a href="#1-非组合式api中的写法" class="headerlink" title="1. 非组合式api中的写法"></a>1. <strong>非组合式api中的写法</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMap.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyMarker /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import MyMarker from &#x27;./MyMarker.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  provide: &#123;</span><br><span class="line">    location: &#x27;North Pole&#x27;,</span><br><span class="line">    geolocation: &#123;</span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- src/components/MyMarker.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: [&#x27;location&#x27;, &#x27;geolocation&#x27;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="2-组合式api中的写法"><a href="#2-组合式api中的写法" class="headerlink" title="2. 组合式api中的写法"></a>2. <strong>组合式api中的写法</strong></h3><h5 id="Provider："><a href="#Provider：" class="headerlink" title="Provider："></a>Provider：</h5><blockquote><p>在 <code>setup()</code> 中使用 <code>provide</code> 时，我们首先从 <code>vue</code> 显式导入 <code>provide</code> 方法。这使我们能够调用 <code>provide</code> 时来定义每个 <code>property</code></p></blockquote><p><code>provide</code> 函数允许你通过两个参数定义 <code>property</code>：</p><ol><li><code>property</code> 的 <code>name</code> (&#96;&#96; 类型)</li><li><code>property</code> 的 <code>value</code></li></ol><p>使用 <code>MyMap</code> 组件，我们提供的值可以按如下方式重构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMap.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;MyMarker /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; provide &#125; from &#x27;vue&#x27;</span><br><span class="line">import MyMarker from &#x27;./MyMarker.vue</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    MyMarker</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    provide(&#x27;location&#x27;, &#x27;North Pole&#x27;)</span><br><span class="line">    provide(&#x27;geolocation&#x27;, &#123;</span><br><span class="line">      longitude: 90,</span><br><span class="line">      latitude: 135</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h5 id="Inject"><a href="#Inject" class="headerlink" title="Inject:"></a>Inject:</h5><blockquote><p>在 <code>setup()</code> 中使用 <code>inject</code> 时，还需要从 <code>vue</code> 显式导入它。一旦我们这样做了，我们就可以调用它来定义如何将它暴露给我们的组件。</p></blockquote><p><code>inject</code> 函数有两个参数：</p><ol><li>要注入的 <code>property</code> 的名称</li><li>一个默认的值 (<strong>可选</strong>)</li></ol><p>使用 <code>MyMarker</code> 组件，可以使用以下代码对其进行重构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- src/components/MyMarker.vue --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)</span><br><span class="line">    const userGeolocation = inject(&#x27;geolocation&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>Provider Inject 响应性</strong></p><p><strong>父组件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    provide,</span><br><span class="line">    ref,</span><br><span class="line">    reactive</span><br><span class="line">&#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">setup() &#123;</span><br><span class="line">        const location = ref(&#x27;北京&#x27;)</span><br><span class="line">        const geolocation = reactive(&#123;</span><br><span class="line">            longitude: 90,</span><br><span class="line">            latitude: 135</span><br><span class="line">        &#125;)</span><br><span class="line">        const updateLocation = () =&gt; &#123;</span><br><span class="line">            location.value = &#x27;上海&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">        provide(&#x27;location&#x27;, location);</span><br><span class="line">        provide(&#x27;geolocation&#x27;, geolocation);</span><br><span class="line">        return &#123;</span><br><span class="line">            updateLocation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;button @click=&quot;updateLocation&quot;&gt;改变location&lt;/button&gt;</span><br></pre></td></tr></table></figure><p><strong>子组件：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import &#123; inject &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const userLocation = inject(&#x27;location&#x27;, &#x27;The Universe&#x27;)</span><br><span class="line">    const userGeolocation = inject(&#x27;geolocation&#x27;)</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      userLocation,</span><br><span class="line">      userGeolocation</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Composition API&lt;/code&gt;也叫组合式API，是Vue3.x的新特性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue3-Composition Api 与  Options Api 有什么不同</title>
    <link href="http://example.com/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/"/>
    <id>http://example.com/2021/09/02/Vue/vue3-Composition%20Api%20%E4%B8%8E%20%20Options%20Api%20%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C/</id>
    <published>2021-09-02T09:23:09.000Z</published>
    <updated>2022-06-07T00:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>Composition API</code> 可以说是<code>Vue3</code>的最大特点，那么为什么要推出<code>Composition Api</code>，解决了什么问题？</p><p>通常使用<code>Vue2</code>开发的项目，普遍会存在以下问题：</p><ul><li>代码的可读性随着组件变大而变差</li><li>每一种代码复用的方式，都存在缺点</li><li>TypeScript支持有限</li></ul><p>以上通过使用<code>Composition Api</code>都能迎刃而解</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一、Options-Api"><a href="#一、Options-Api" class="headerlink" title="一、Options Api"></a>一、Options Api</h3><p><code>Options API</code>，即大家常说的选项API，即以<code>vue</code>为后缀的文件，通过定义<code>methods</code>，<code>computed</code>，<code>watch</code>，<code>data</code>等属性与方法，共同处理页面逻辑</p><p>如下图：</p><p><img src="https://static.vue-js.com/9bf6d9d0-6048-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><p>可以看到<code>Options</code>代码编写方式，如果是组件状态，则写在<code>data</code>属性上，如果是方法，则写在<code>methods</code>属性上…</p><p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效</p><p>然而，当组件变得复杂，导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解</p><h3 id="二、Composition-Api"><a href="#二、Composition-Api" class="headerlink" title="二、Composition Api"></a>二、Composition Api</h3><p>在 Vue3 Composition API 中，组件根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p>即使项目很大，功能很多，我们都能快速的定位到这个功能所用到的所有 API</p><p><img src="https://static.vue-js.com/acee9200-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p><h3 id="三、对比"><a href="#三、对比" class="headerlink" title="三、对比"></a>三、对比</h3><p>下面对<code>Composition Api</code>与<code>Options Api</code>进行两大方面的比较</p><ul><li>逻辑组织</li><li>逻辑复用</li></ul><h4 id="逻辑组织"><a href="#逻辑组织" class="headerlink" title="逻辑组织"></a>逻辑组织</h4><h5 id="Options-API"><a href="#Options-API" class="headerlink" title="Options API"></a>Options API</h5><p>假设一个组件是一个大型组件，其内部有很多处理逻辑关注点（对应下图不用颜色）</p><p><img src="https://static.vue-js.com/dc83d070-6048-11eb-ab90-d9ae814b240d.png" alt="img"></p><p>可以看到，这种碎片化使得理解和维护复杂组件变得困难</p><p>选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块</p><h5 id="Compostion-API"><a href="#Compostion-API" class="headerlink" title="Compostion API"></a>Compostion API</h5><p>而<code>Compositon API</code>正是解决上述问题，将某个逻辑关注点相关的代码全都放在一个函数里，这样当需要修改一个功能时，就不再需要在文件中跳来跳去</p><p>下面举个简单例子，将处理<code>count</code>属性相关的代码放在同一个函数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="title function_">ref</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> double = <span class="title function_">computed</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleConut</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        count.<span class="property">value</span> = count.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count,</span><br><span class="line">        double,</span><br><span class="line">        handleConut,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件上中使用<code>count</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; count, double, handleConut &#125; = <span class="title function_">useCount</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            count,</span><br><span class="line">            double,</span><br><span class="line">            handleConut</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>再来一张图进行对比，可以很直观地感受到 <code>Composition API</code>在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可</p><p><img src="https://static.vue-js.com/e5804bc0-5c58-11eb-85f6-6fac77c0c9b3.png" alt="img"></p><h4 id="逻辑复用"><a href="#逻辑复用" class="headerlink" title="逻辑复用"></a>逻辑复用</h4><p>在<code>Vue2</code>中，我们是用过<code>mixin</code>去复用相同的逻辑</p><p>下面举个例子，我们会另起一个<code>mixin.js</code>文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">MoveMixin</span> = &#123;</span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">handleKeyup</span>(<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">      <span class="comment">// 上下左右 x y</span></span><br><span class="line">      <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">y</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>--;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">          <span class="variable language_">this</span>.<span class="property">x</span>++;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, <span class="variable language_">this</span>.<span class="property">handleKeyup</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> mousePositionMixin <span class="keyword">from</span> <span class="string">&#x27;./mouse&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">mixins</span>: [mousePositionMixin]</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>使用单个<code>mixin</code>似乎问题不大，但是当我们一个组件混入大量不同的 <code>mixins</code> 的时候</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mixins</span>: [mousePositionMixin, fooMixin, barMixin, otherMixin]</span><br></pre></td></tr></table></figure><p>会存在两个非常明显的问题：</p><ul><li>命名冲突</li><li>数据来源不清晰</li></ul><p>现在通过<code>Compositon API</code>这种方式改写上面的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onMounted, onUnmounted, reactive &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useMove</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleKeyup</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">code</span>);</span><br><span class="line">    <span class="comment">// 上下左右 x y</span></span><br><span class="line">    <span class="keyword">switch</span> (e.<span class="property">code</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowUp&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value--;</span></span><br><span class="line">        position.<span class="property">y</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowDown&quot;</span>:</span><br><span class="line">        <span class="comment">// y.value++;</span></span><br><span class="line">        position.<span class="property">y</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowLeft&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value--;</span></span><br><span class="line">        position.<span class="property">x</span>--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;ArrowRight&quot;</span>:</span><br><span class="line">        <span class="comment">// x.value++;</span></span><br><span class="line">        position.<span class="property">x</span>++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;keyup&quot;</span>, handleKeyup);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; position &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Mouse position: x &#123;&#123; x &#125;&#125; / y &#123;&#123; y &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; useMove &#125; <span class="keyword">from</span> <span class="string">&quot;./useMove&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; position &#125; = <span class="title function_">useMove</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> &#123; x, y &#125; = <span class="title function_">toRefs</span>(position);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      x,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      y,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>可以看到，整个数据来源清晰了，即使去编写更多的 hook 函数，也不会出现命名冲突的问题</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>在逻辑组织和逻辑复用方面，<code>Composition API</code>是优于<code>Options API</code></li><li>因为<code>Composition API</code>几乎是函数，会有更好的类型推断。</li><li><code>Composition API</code>对 <code>tree-shaking</code> 友好，代码也更容易压缩</li><li><code>Composition API</code>中见不到<code>this</code>的使用，减少了<code>this</code>指向不明的情况</li><li>如果是小型组件，可以继续使用<code>Options API</code>，也是十分友好的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开始之前&quot;&gt;&lt;a href=&quot;#开始之前&quot; class=&quot;headerlink&quot; title=&quot;开始之前&quot;&gt;&lt;/a&gt;开始之前&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Composition API&lt;/code&gt; 可以说是&lt;code&gt;Vue3&lt;/code&gt;的最大特点，那么为什么要</summary>
      
    
    
    
    <category term="框架" scheme="http://example.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="vue3" scheme="http://example.com/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Typescript总结</title>
    <link href="http://example.com/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2021/08/23/html+css+js+ts/5-Typescript%E6%80%BB%E7%BB%93/</id>
    <published>2021-08-23T02:31:24.000Z</published>
    <updated>2022-06-07T00:45:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><h2 id="1-1-什么是-TypeScript"><a href="#1-1-什么是-TypeScript" class="headerlink" title="1.1 什么是 TypeScript"></a>1.1 什么是 TypeScript</h2><ul><li><code>TypeScript</code> 是 <code>JavaScript</code> 的一个超集，主要提供了类型系统和对 <code>ES6</code>的支持</li><li><code>TypeScript</code> 是由微软开发的一款开源的编程语言</li><li><code>TypeScript</code> 是 <code>Javascript</code> 的超级，遵循最新的 <code>ES6</code>、<code>Es5</code> 规范。<code>TypeScript</code> 扩展了 <code>JavaScript</code> 的语法</li><li><code>TypeScript</code> 更像后端 <code>java</code>、<code>C#</code>这样的面向对象语言可以让 <code>js</code> 开发大型企业项目</li></ul><h2 id="1-2-为什么选择-TypeScript"><a href="#1-2-为什么选择-TypeScript" class="headerlink" title="1.2 为什么选择 TypeScript"></a>1.2 为什么选择 TypeScript</h2><blockquote><p><code>Typescript</code>和<code>es6</code>、<code>es5</code>关系</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/583.png" alt="img"></p><p><strong>TypeScript 增加了代码的可读性和可维护性</strong></p><ul><li>类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了</li><li>可以在编译阶段就发现大部分错误，这总比在运行时候出错好</li><li>增强了编辑器和 <code>IDE</code> 的功能，包括代码补全、接口提示、跳转到定义、重构等</li></ul><p><strong>TypeScript 非常包容</strong></p><ul><li><code>TypeScript</code> 是 <code>JavaScript</code> 的超集，<code>.js</code> 文件可以直接重命名为 <code>.ts</code> 即可</li><li>即使不显式的定义类型，也能够自动做出类型推论</li><li>可以定义从简单到复杂的几乎一切类型</li><li>即使 <code>TypeScript</code> 编译报错，也可以生成 <code>JavaScript</code> 文件</li><li>兼容第三方库，即使第三方库不是用 <code>TypeScript</code> 写的，也可以编写单独的类型文件供 <code>TypeScript</code> 读取</li></ul><p><strong>TypeScript 拥有活跃的社区</strong></p><ul><li>大部分第三方库都有提供给 <code>TypeScript</code> 的类型定义文件</li><li><code>Google</code> 开发的<code>Angular2</code> 就是使用 <code>TypeScript</code> 编写的</li><li><code>TypeScript</code> 拥抱了 <code>ES6</code> 规范，也支持部分 <code>ESNext</code> 草案的规范</li><li>最新的 <code>Vue</code> 、<code>React</code> 也可以集成 <code>TypeScript</code></li></ul><p><strong>TypeScript 的缺点</strong></p><ul><li>有一定的学习成本，需要理解接口（<code>Interfaces</code>）、泛型（<code>Generics</code>）、类（<code>Classes</code>）、枚举类型（<code>Enums</code>）等前端工程师可能不是很熟悉的概念</li><li>短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，<code>TypeScript</code> 能够减少其维护成本</li><li>集成到构建流程需要一些工作量</li><li>可能和一些库结合的不是很完美</li></ul><h2 id="1-3-安装-TypeScript"><a href="#1-3-安装-TypeScript" class="headerlink" title="1.3 安装 TypeScript"></a>1.3 安装 TypeScript</h2><p><strong>typescript 安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><blockquote><p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure><blockquote><p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p></blockquote><blockquote><p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/584.png" alt="img"></p><blockquote><p>这个<code>json</code>文件里有很多选项</p></blockquote><ul><li><code>target</code>是选择编译到什么语法</li><li><code>module</code>则是模块类型</li><li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li></ul><blockquote><p>更多细节 <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p></blockquote><blockquote><p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/585.png" alt="img"></p><h2 id="1-4-Hello-TypeScript"><a href="#1-4-Hello-TypeScript" class="headerlink" title="1.4 Hello TypeScript"></a>1.4 Hello TypeScript</h2><blockquote><p>将以下代码复制到 <code>hello.ts</code> 中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(person: string) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br><span class="line">tsc hello.ts</span><br><span class="line">//这时候会生成一个编译好的文件 hello.js：</span><br><span class="line"></span><br><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &#x27;Hello, &#x27; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user = &#x27;poetries&#x27;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure><blockquote><p><code>TypeScript</code> 中，使用 <code>:</code> 指定变量的类型，<code>:</code> 的前后有没有空格都可以</p></blockquote><ul><li><code>TypeScript</code> 只会进行静态检查，如果发现有错误，编译的时候就会报错</li><li><code>TypeScript</code> 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件</li></ul><h1 id="二、基础"><a href="#二、基础" class="headerlink" title="二、基础"></a>二、基础</h1><h2 id="2-1-原始数据类型"><a href="#2-1-原始数据类型" class="headerlink" title="2.1 原始数据类型"></a>2.1 原始数据类型</h2><blockquote><p><code>JavaScript</code> 的类型分为两种：原始数据类型（<code>Primitive data types</code>）和对象类型（<code>Object types</code>）。</p></blockquote><ul><li>原始数据类型包括：<code>布尔值</code>、<code>数值</code>、<code>字符串</code>、<code>null</code>、<code>undefined</code> 以及 <code>ES6</code>中的新类型 <code>Symbol</code>。</li></ul><blockquote><p>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用</p></blockquote><h3 id="2-1-1-布尔值"><a href="#2-1-1-布尔值" class="headerlink" title="2.1.1 布尔值"></a>2.1.1 布尔值</h3><blockquote><p>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let isDone: boolean = false;</span><br><span class="line"></span><br><span class="line">// 编译通过</span><br><span class="line">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span><br></pre></td></tr></table></figure><blockquote><p>注意，使用构造函数 <code>Boolean</code> 创造的对象不是布尔值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.</span><br><span class="line">// 后面约定，注释中标出了编译报错的代码片段，表示编译未通过</span><br></pre></td></tr></table></figure><ul><li>事实上 <code>new Boolean()</code> 返回的是一个 <code>Boolean</code> 对象：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br></pre></td></tr></table></figure><ul><li>直接调用 <code>Boolean</code> 也可以返回一个 <code>boolean</code> 类型：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let createdByBoolean: boolean = Boolean(1);</span><br></pre></td></tr></table></figure><ul><li>在 <code>TypeScript</code> 中，<code>boolean</code>是 <code>JavaScript</code> 中的基本类型，而 <code>Boolean</code> 是 <code>JavaScript</code>中的构造函数。其他基本类型（除了 <code>null</code> 和 <code>undefined</code>）一样</li></ul><h3 id="2-1-2-数值"><a href="#2-1-2-数值" class="headerlink" title="2.1.2 数值"></a>2.1.2 数值</h3><blockquote><p>使用 <code>number</code> 定义数值类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">//编译结果：</span><br><span class="line"></span><br><span class="line">var decLiteral = 6;</span><br><span class="line">var hexLiteral = 0xf00d;</span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">var binaryLiteral = 10;</span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">var octalLiteral = 484;</span><br><span class="line">var notANumber = NaN;</span><br><span class="line">var infinityNumber = Infinity;</span><br></pre></td></tr></table></figure><blockquote><p>其中 <code>0b101</code>0 和 <code>0o744</code>是 <code>ES6</code> 中的二进制和八进制表示法，它们会被编译为十进制数字</p></blockquote><h3 id="2-1-3-字符串"><a href="#2-1-3-字符串" class="headerlink" title="2.1.3 字符串"></a>2.1.3 字符串</h3><blockquote><p>使用 <code>string</code> 定义字符串类型：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">let myAge: number = 25;</span><br><span class="line"></span><br><span class="line">// 模板字符串</span><br><span class="line">let sentence: string = `Hello, my name is $&#123;myName&#125;.</span><br><span class="line">I&#x27;ll be $&#123;myAge + 1&#125; years old next month.`;</span><br></pre></td></tr></table></figure><h3 id="2-1-4-空值"><a href="#2-1-4-空值" class="headerlink" title="2.1.4 空值"></a>2.1.4 空值</h3><blockquote><p><code>JavaScript</code> 没有空值（<code>Void</code>）的概念，在 <code>TypeScript</code> 中，可以用 <code>void</code> 表示没有任何返回值的函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>声明一个 <code>void</code> 类型的变量没有什么用，因为你只能将它赋值为 <code>undefined</code>和 <code>null</code>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let unusable: void = undefined;</span><br></pre></td></tr></table></figure><h3 id="2-1-5-Null-和-Undefined"><a href="#2-1-5-Null-和-Undefined" class="headerlink" title="2.1.5 Null 和 Undefined"></a>2.1.5 Null 和 Undefined</h3><blockquote><p>在 <code>TypeScript</code> 中，可以使用 <code>null</code> 和 <code>undefined</code>来定义这两个原始数据类型：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined` 类型的变量只能被赋值为 `undefined`，`null` 类型的变量只能被赋值为 `null</span><br></pre></td></tr></table></figure></blockquote><ul><li>与 <code>void</code> 的区别是，<code>undefined</code>和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 这样不会报错</span><br><span class="line">let num: number = undefined;</span><br><span class="line"></span><br><span class="line">// 这样也不会报错</span><br><span class="line">let u: undefined;</span><br><span class="line">let num: number = u;</span><br></pre></td></tr></table></figure><blockquote><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let u: void;</span><br><span class="line">let num: number = u;</span><br><span class="line"></span><br><span class="line">// index.ts(2,5): error TS2322: Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><h2 id="2-2-任意值Any"><a href="#2-2-任意值Any" class="headerlink" title="2.2 任意值Any"></a>2.2 任意值Any</h2><blockquote><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: any = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure><p><strong>任意值的属性和方法</strong></p><p>在任意值上访问任何属性都是允许的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(anyThing.myName);</span><br><span class="line">console.log(anyThing.myName.firstName);</span><br></pre></td></tr></table></figure><p><strong>也允许调用任何方法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let anyThing: any = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;);</span><br><span class="line">anyThing.setName(&#x27;Jerry&#x27;).sayHello();</span><br><span class="line">anyThing.myName.setFirstName(&#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</p></blockquote><p><strong>未声明类型的变量</strong></p><blockquote><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let something: any;</span><br><span class="line">something = &#x27;seven&#x27;;</span><br><span class="line">something = 7;</span><br><span class="line"></span><br><span class="line">something.setName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><h2 id="2-3-类型推论"><a href="#2-3-类型推论" class="headerlink" title="2.3 类型推论"></a>2.3 类型推论</h2><blockquote><p>如果没有明确的指定类型，那么 <code>TypeScript</code> 会依照类型推论（<code>Type Inference</code>）的规则推断出一个类型</p></blockquote><p><strong>什么是类型推论</strong></p><p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure><p>事实上，它等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure><p><code>TypeScript</code> 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论</p><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber;</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure><h2 id="2-4-联合类型"><a href="#2-4-联合类型" class="headerlink" title="2.4 联合类型"></a>2.4 联合类型</h2><blockquote><p>联合类型（<code>Union Types</code>）表示取值可以为多种类型中的一种</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 简单例子</span><br><span class="line"></span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = true;</span><br><span class="line"></span><br><span class="line">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><ul><li>联合类型使用 <code>|</code> 分隔每个类型。</li><li>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型</li></ul><p><strong>访问联合类型的属性或方法</strong></p><blockquote><p>当 <code>TypeScript</code> 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// length 不是 string 和 number 的共有属性，所以会报错</span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(myFavoriteNumber.length); // 5</span><br><span class="line"></span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line">console.log(myFavoriteNumber.length); // 编译时报错</span><br><span class="line"></span><br><span class="line">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</li><li>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了</li></ul><h2 id="2-5-对象的类型——接口"><a href="#2-5-对象的类型——接口" class="headerlink" title="2.5 对象的类型——接口"></a>2.5 对象的类型——接口</h2><h3 id="2-5-1-简单例子"><a href="#2-5-1-简单例子" class="headerlink" title="2.5.1 简单例子"></a>2.5.1 简单例子</h3><blockquote><p>在 <code>TypeScript</code> 中，我们使用接口（<code>Interfaces</code>）来定义对象的类型</p></blockquote><p><strong>什么是接口</strong></p><ul><li>在面向对象语言中，接口（<code>Interfaces</code>）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（<code>classes</code>）去实现（<code>implements</code>）。</li><li><code>TypeScript</code> 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（<code>Shape</code>）」进行描述。</li></ul><p>接口一般首字母大写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个接口 <code>Person</code>，接着定义了一个变量 <code>tom</code>，它的类型是 <code>Person</code>。这样，我们就约束了 <code>tom</code> 的形状必须和接口 <code>Person</code> 一致</p></blockquote><p><strong>定义的变量比接口少了一些属性是不允许的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(6,5): error TS2322: Type &#x27;&#123; name: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27;.</span><br></pre></td></tr></table></figure><p><strong>多一些属性也是不允许的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>可见，赋值的时候，变量的形状必须和接口的形状保持一致。</p></blockquote><h3 id="2-5-2-可选属性"><a href="#2-5-2-可选属性" class="headerlink" title="2.5.2 可选属性"></a>2.5.2 可选属性</h3><blockquote><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性</p></blockquote><p>可选属性的含义是该属性可以不存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-5-3-任意属性"><a href="#2-5-3-任意属性" class="headerlink" title="2.5.3 任意属性"></a>2.5.3 任意属性</h3><blockquote><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值</li><li>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="line">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Index signatures are incompatible.</span><br><span class="line">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="line">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code>不是 <code>string</code> 的子属性，所以报错了。</li><li>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code>的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合</li></ul><h3 id="2-5-4-只读属性"><a href="#2-5-4-只读属性" class="headerlink" title="2.5.4 只读属性"></a>2.5.4 只读属性</h3><blockquote><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code>定义只读属性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 9527;</span><br><span class="line"></span><br><span class="line">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure><blockquote><p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了</p></blockquote><p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757;</span><br><span class="line"></span><br><span class="line">// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.</span><br><span class="line">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure><ul><li>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</li><li>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了</li></ul><h2 id="2-6-数组的类型"><a href="#2-6-数组的类型" class="headerlink" title="2.6 数组的类型"></a>2.6 数组的类型</h2><blockquote><p>在 <code>TypeScript</code> 中，数组类型有多种定义方式，比较灵活。</p></blockquote><h3 id="2-6-1「类型-方括号」表示法"><a href="#2-6-1「类型-方括号」表示法" class="headerlink" title="2.6.1「类型 + 方括号」表示法"></a>2.6.1「类型 + 方括号」表示法</h3><blockquote><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure><blockquote><p>数组的项中不允许出现其他的类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;(number | string)[]&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Type &#x27;number | string&#x27; is not assignable to type &#x27;number&#x27;.</span><br><span class="line">//     Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上例中，<code>[1, &#39;1&#39;, 2, 3, 5]</code> 的类型被推断为 <code>(number | string)[]</code>，这是联合类型和数组的结合。</li><li>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,16): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>string</code> 类型的参数，所以报错了</p></blockquote><h3 id="2-6-2-数组泛型"><a href="#2-6-2-数组泛型" class="headerlink" title="2.6.2 数组泛型"></a>2.6.2 数组泛型</h3><blockquote><p>也可以使用数组泛型（<code>Array Generic</code>）<code>Array</code>来表示数组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure><h3 id="2-6-3-用接口表示数组"><a href="#2-6-3-用接口表示数组" class="headerlink" title="2.6.3 用接口表示数组"></a>2.6.3 用接口表示数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NumberArray` 表示：只要 `index` 的类型是 `number`，那么值的类型必须是 `number</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-6-4-any-在数组中的应用"><a href="#2-6-4-any-在数组中的应用" class="headerlink" title="2.6.4 any 在数组中的应用"></a>2.6.4 any 在数组中的应用</h3><blockquote><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [&#x27;poetries&#x27;, 22, &#123; website: &#x27;http://blog.poetries.top&#x27; &#125;];</span><br></pre></td></tr></table></figure><h3 id="2-6-5-类数组"><a href="#2-6-5-类数组" class="headerlink" title="2.6.5 类数组"></a>2.6.5 类数组</h3><blockquote><p>类数组（<code>Array-like Object</code>）不是数组类型，比如 <code>arguments</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,7): error TS2322: Type &#x27;IArguments&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Property &#x27;push&#x27; is missing in type &#x27;IArguments&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>事实上常见的类数组都有自己的接口定义，如 <code>IArguments</code>, <code>NodeList</code>, <code>HTMLCollection</code> 等：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7-函数的类型"><a href="#2-7-函数的类型" class="headerlink" title="2.7 函数的类型"></a>2.7 函数的类型</h2><h3 id="2-7-1-函数声明"><a href="#2-7-1-函数声明" class="headerlink" title="2.7.1 函数声明"></a>2.7.1 函数声明</h3><blockquote><p>在 <code>JavaScript</code> 中，有两种常见的定义函数的方式——函数声明（<code>Function Declaration</code>）和函数表达式（<code>Function Expression</code>）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明（Function Declaration）</span><br><span class="line">function sum(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式（Function Expression）</span><br><span class="line">let mySum = function (x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>一个函数有输入和输出，要在 <code>TypeScript</code> 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，输入多余的（或者少于要求的）参数，是不被允许的：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1);</span><br><span class="line"></span><br><span class="line">// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.</span><br></pre></td></tr></table></figure><h3 id="2-7-2-函数表达式"><a href="#2-7-2-函数表达式" class="headerlink" title="2.7.2 函数表达式"></a>2.7.2 函数表达式</h3><blockquote><p>如果要我们现在写一个对函数表达式（<code>Function Expression</code>）的定义，可能会写成这样</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是可以通过编译的，不过事实上，上面的代码只对等号右侧的匿名函数进行了类型定义，而等号左边的 <code>mySum</code>，是通过赋值操作进行类型推论而推断出来的。如果需要我们手动给 <code>mySum</code> 添加类型，则应该是这样</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// =&gt;左边 (x: number, y: number) 是输入类型 </span><br><span class="line">// =&gt;右边number是输出类型</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意不要混淆了 TypeScript 中的 &#x3D;&gt; 和 ES6 中的 &#x3D;&gt;</strong></p><blockquote><p>在 <code>TypeScript</code> 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p></blockquote><h3 id="2-7-3-用接口定义函数的形状"><a href="#2-7-3-用接口定义函数的形状" class="headerlink" title="2.7.3 用接口定义函数的形状"></a>2.7.3 用接口定义函数的形状</h3><blockquote><p>我们也可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的是，可选参数必须接在必需参数后面。换句话说，可选参数后面不允许再出现必须参数了</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName?: string, lastName: string) &#123;</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span><br></pre></td></tr></table></figure><h3 id="2-7-4-参数默认值"><a href="#2-7-4-参数默认值" class="headerlink" title="2.7.4 参数默认值"></a>2.7.4 参数默认值</h3><blockquote><p>在 <code>ES6</code>中，我们允许给函数的参数添加默认值，<code>TypeScript</code> 会将添加了默认值的参数识别为可选参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><p><strong>此时就不受「可选参数必须接在必需参数后面」的限制了</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string = &#x27;Tom&#x27;, lastName: string) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let cat = buildName(undefined, &#x27;Cat&#x27;);</span><br></pre></td></tr></table></figure><h3 id="2-7-5-剩余参数"><a href="#2-7-5-剩余参数" class="headerlink" title="2.7.5 剩余参数"></a>2.7.5 剩余参数</h3><blockquote><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（<code>rest</code> 参数）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array, ...items) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure><blockquote><p>事实上，items 是一个数组。所以我们可以用数组的类型来定义它</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure><blockquote><p>注意，rest 参数只能是最后一个参数</p></blockquote><h3 id="2-7-6-函数重载"><a href="#2-7-6-函数重载" class="headerlink" title="2.7.6 函数重载"></a>2.7.6 函数重载</h3><ul><li>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</li></ul><blockquote><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code></p></blockquote><p><strong>利用联合类型，我们可以这么实现</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串</p></blockquote><p><strong>这时，我们可以使用重载定义多个 reverse 的函数类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。</li></ul><blockquote><p><strong>注意</strong>，<code>TypeScript</code> 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面</p></blockquote><h2 id="2-8-类型断言"><a href="#2-8-类型断言" class="headerlink" title="2.8 类型断言"></a>2.8 类型断言</h2><blockquote><p>类型断言（<code>Type Assertion</code>）可以用来手动指定一个值的类型。</p></blockquote><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;值</span><br><span class="line"></span><br><span class="line">// 或</span><br><span class="line"></span><br><span class="line">值 as 类型</span><br></pre></td></tr></table></figure><blockquote><p>在 <code>tsx</code> 语法（<code>React</code> 的 <code>jsx</code> 语法的 <code>ts</code> 版）中必须用后一种</p></blockquote><p><strong>例子：将一个联合类型的变量指定为一个更加具体的类型</strong></p><blockquote><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，比如</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if (something.length) &#123;</span><br><span class="line">        return something.length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br><span class="line">// index.ts(3,26): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span><br><span class="line">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上例中，获取 <code>something.length</code>的时候会报错</p></blockquote><p><strong>此时可以使用类型断言，将 something 断言成 string</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类型断言的用法如上，在需要断言的变量前加上 &#96;&#96; 即可</p></blockquote><p><strong>类型断言不是类型转换，断言成一个联合类型中不存在的类型是不允许的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function toBoolean(something: string | number): boolean &#123;</span><br><span class="line">    return &lt;boolean&gt;something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,10): error TS2352: Type &#x27;string | number&#x27; cannot be converted to type &#x27;boolean&#x27;.</span><br><span class="line">//   Type &#x27;number&#x27; is not comparable to type &#x27;boolean&#x27;.</span><br></pre></td></tr></table></figure><h2 id="2-9-声明文件"><a href="#2-9-声明文件" class="headerlink" title="2.9 声明文件"></a>2.9 声明文件</h2><blockquote><p>当使用第三方库时，我们需要引用它的声明文件</p></blockquote><h3 id="2-9-1-声明-declare-语句"><a href="#2-9-1-声明-declare-语句" class="headerlink" title="2.9.1 声明(declare)语句"></a>2.9.1 声明(declare)语句</h3><blockquote><p>假如我们想使用第三方库，比如 <code>jQuery</code>，我们通常这样获取一个 <code>id</code> 是 <code>foo</code> 的元素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&#x27;#foo&#x27;);</span><br><span class="line">// or</span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p>但是在 <code>TypeScript</code> 中，我们并不知道 <code>$</code> 或 <code>jQuery</code>是什么东西</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery(&#x27;#foo&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,1): error TS2304: Cannot find name &#x27;jQuery&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>这时，我们需要使用 <code>declare</code> 关键字来定义它的类型，帮助<code>TypeScript</code> 判断我们传入的参数类型对不对</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">declare var jQuery: (selector: string) =&gt; any;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure><blockquote><p><code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure><h3 id="2-9-2-声明文件-约定-d-ts后缀"><a href="#2-9-2-声明文件-约定-d-ts后缀" class="headerlink" title="2.9.2 声明文件(约定.d.ts后缀)"></a>2.9.2 声明文件(约定.d.ts后缀)</h3><blockquote><p>通常我们会把类型声明放到一个单独的文件中，这就是声明文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// jQuery.d.ts</span><br><span class="line"></span><br><span class="line">declare var jQuery: (string) =&gt; any;</span><br></pre></td></tr></table></figure><ul><li>我们约定声明文件以 <code>.d.ts</code> 为后缀。</li><li>然后在使用到的文件的开头，用<code>「三斜线指令」///</code>表示引用了声明文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;reference path=&quot;./jQuery.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">jQuery(&#x27;#foo&#x27;);</span><br></pre></td></tr></table></figure><h3 id="2-9-3-第三方声明文件"><a href="#2-9-3-第三方声明文件" class="headerlink" title="2.9.3 第三方声明文件"></a>2.9.3 第三方声明文件</h3><blockquote><p>当然，<code>jQuery</code> 的声明文件不需要我们定义了，已经有人帮我们定义好了：<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts">jQuery in DefinitelyTyped</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/jquery/index.d.ts</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 引入声明文件</span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure><ul><li>我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件- 社区已经有多种方式引入声明文件，不过 <code>TypeScript 2.0</code>推荐使用 <code>@types</code> 来管理。</li><li><code>@types</code> 的使用方式很简单，直接用 <code>npm</code> 安装对应的声明模块即可，以 <code>jQuery</code> 举例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/jquery --save-dev</span><br></pre></td></tr></table></figure><p><strong>可以在这个页面搜索你需要的声明文件</strong></p><blockquote><p><a href="http://microsoft.github.io/TypeSearch/">http://microsoft.github.io/TypeSearch/</a></p></blockquote><h2 id="2-10-内置对象"><a href="#2-10-内置对象" class="headerlink" title="2.10 内置对象"></a>2.10 内置对象</h2><blockquote><p><code>JavaScript</code> 中有很多内置对象，它们可以直接在 <code>TypeScript</code> 中当做定义好了的类型</p></blockquote><blockquote><p>内置对象是指根据标准在全局作用域（<code>Global</code>）上存在的对象。这里的标准是指 <code>ECMAScript</code> 和其他环境（比如 <code>DOM</code>）的标准</p></blockquote><h3 id="2-10-1-ECMAScript-的内置对象"><a href="#2-10-1-ECMAScript-的内置对象" class="headerlink" title="2.10.1 ECMAScript 的内置对象"></a>2.10.1 ECMAScript 的内置对象</h3><p><strong>ECMAScript 标准提供的内置对象有</strong></p><blockquote><p><code>Boolean</code>、<code>Error</code>、<code>Date</code>、<code>RegExp</code> 等</p></blockquote><p>我们可以在 <code>TypeScript</code> 中将变量定义为这些类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let b: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">let e: Error = new Error(&#x27;Error occurred&#x27;);</span><br><span class="line"></span><br><span class="line">let d: Date = new Date();</span><br><span class="line"></span><br><span class="line">let r: RegExp = /[a-z]/;</span><br></pre></td></tr></table></figure><blockquote><p>更多的内置对象，可以查看 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN 的文档</a></p></blockquote><blockquote><p>而他们的定义文件，则在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p></blockquote><h3 id="2-10-2-DOM-和-BOM-的内置对象"><a href="#2-10-2-DOM-和-BOM-的内置对象" class="headerlink" title="2.10.2 DOM 和 BOM 的内置对象"></a>2.10.2 DOM 和 BOM 的内置对象</h3><p><strong>DOM 和 BOM 提供的内置对象有</strong></p><blockquote><p><code>Document</code>、<code>HTMLElement</code>、<code>Event</code>、<code>NodeList</code> 等。</p></blockquote><blockquote><p>TypeScript 中会经常用到这些类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let body: HTMLElement = document.body;</span><br><span class="line">let allDiv: NodeList = document.querySelectorAll(&#x27;div&#x27;);</span><br><span class="line"></span><br><span class="line">document.addEventListener(&#x27;click&#x27;, function(e: MouseEvent) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>它们的定义文件同样在 <a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库的定义文件中</a></p></blockquote><h3 id="2-10-3-TypeScript-核心库的定义文件"><a href="#2-10-3-TypeScript-核心库的定义文件" class="headerlink" title="2.10.3 TypeScript 核心库的定义文件"></a>2.10.3 TypeScript 核心库的定义文件</h3><blockquote><p><a href="https://github.com/Microsoft/TypeScript/tree/master/src/lib">TypeScript 核心库</a>的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的</p></blockquote><blockquote><p>当你在使用一些常用的方法的时候，<code>TypeScript</code> 实际上已经帮你做了很多类型判断的工作了，比如</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(10, &#x27;2&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(1,14): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>Math.pow</code> 必须接受两个 <code>number</code> 类型的参数。事实上 <code>Math.pow</code>的类型定义如下</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Math &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns the value of a base expression taken to a specified power.</span><br><span class="line">     * @param x The base value of the expression.</span><br><span class="line">     * @param y The exponent value of the expression.</span><br><span class="line">     */</span><br><span class="line">    pow(x: number, y: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>再举一个 <code>DOM</code> 中的例子</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">    console.log(e.targetCurrent);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,17): error TS2339: Property &#x27;targetCurrent&#x27; does not exist on type &#x27;MouseEvent&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>addEventListener</code> 方法是在 <code>TypeScript</code> 核心库中定义的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Document extends Node, GlobalEventHandlers, NodeSelector, DocumentEvent &#123;</span><br><span class="line">    addEventListener(type: string, listener: (ev: MouseEvent) =&gt; any, useCapture?: boolean): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>所以 <code>e</code> 被推断成了 <code>MouseEvent</code>，而 <code>MouseEvent</code> 是没有 <code>targetCurrent</code> 属性的，所以报错了</p></blockquote><p><strong>注意，TypeScript 核心库的定义中不包含 Node.js 部分</strong></p><h3 id="2-10-4-用-TypeScript-写-Node-js"><a href="#2-10-4-用-TypeScript-写-Node-js" class="headerlink" title="2.10.4 用 TypeScript 写 Node.js"></a>2.10.4 用 TypeScript 写 Node.js</h3><blockquote><p><code>Node.js</code> 不是内置对象的一部分，如果想用 <code>TypeScript</code> 写 <code>Node.js</code>，则需要引入第三方声明文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @types/node --save-dev</span><br></pre></td></tr></table></figure><h1 id="三、进阶"><a href="#三、进阶" class="headerlink" title="三、进阶"></a>三、进阶</h1><h2 id="3-1-类型别名"><a href="#3-1-类型别名" class="headerlink" title="3.1 类型别名"></a>3.1 类型别名</h2><blockquote><p>类型别名用来给一个类型起个新名字</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line"></span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line"></span><br><span class="line">type NameOrResolver = Name | NameResolver; // 联合类型</span><br><span class="line"></span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中，我们使用 <code>type</code> 创建类型别名。</p><blockquote><p>类型别名常用于联合类型</p></blockquote><h2 id="3-2-字符串字面量类型"><a href="#3-2-字符串字面量类型" class="headerlink" title="3.2 字符串字面量类型"></a>3.2 字符串字面量类型</h2><blockquote><p>字符串字面量类型用来约束取值只能是某几个字符串中的一个</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;;</span><br><span class="line">function handleEvent(ele: Element, event: EventNames) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;);  // 没问题</span><br><span class="line">handleEvent(document.getElementById(&#x27;world&#x27;), &#x27;dbclick&#x27;); // 报错，event 不能为 &#x27;dbclick&#x27;</span><br><span class="line"></span><br><span class="line">// index.ts(7,47): error TS2345: Argument of type &#x27;&quot;dbclick&quot;&#x27; is not assignable to parameter of type &#x27;EventNames&#x27;.</span><br></pre></td></tr></table></figure><ul><li>上例中，我们使用 <code>type</code> 定了一个字符串字面量类型 <code>EventNames</code>，它只能取三种字符串中的一种。</li></ul><p><strong>注意，类型别名与字符串字面量类型都是使用 type 进行定</strong></p><h2 id="3-3-元组"><a href="#3-3-元组" class="headerlink" title="3.3 元组"></a>3.3 元组</h2><ul><li>数组合并了相同类型的对象，而元组（<code>Tuple</code>）合并了不同类型的对象。</li><li>元组起源于函数编程语言,在这些语言中频繁使用元组。</li></ul><h3 id="3-3-1-简单的例子"><a href="#3-3-1-简单的例子" class="headerlink" title="3.3.1 简单的例子"></a>3.3.1 简单的例子</h3><blockquote><p>定义一对值分别为 <code>string</code> 和 <code>number</code>的元组</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number] = [&#x27;poetries&#x27;, 22];</span><br></pre></td></tr></table></figure><blockquote><p>当赋值或访问一个已知索引的元素时，会得到正确的类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br><span class="line">user[1] = 22;</span><br><span class="line"></span><br><span class="line">user[0].slice(1);</span><br><span class="line">user[1].toFixed(2);</span><br></pre></td></tr></table></figure><blockquote><p>也可以只赋值其中一项</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user[0] = &#x27;poetries&#x27;;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-越界的元素"><a href="#3-3-2-越界的元素" class="headerlink" title="3.3.2 越界的元素"></a>3.3.2 越界的元素</h3><blockquote><p>当添加越界的元素时，它的类型会被限制为元组中每个类型的联合类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let user: [string, number];</span><br><span class="line">user = [&#x27;poetries&#x27;, 22];</span><br><span class="line">user.push(&#x27;http://blog.poetries.top&#x27;);</span><br><span class="line">user.push(true);</span><br><span class="line"></span><br><span class="line">// index.ts(4,14): error TS2345: Argument of type &#x27;boolean&#x27; is not assignable to parameter of type &#x27;string | number&#x27;.</span><br><span class="line">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure><h2 id="3-4-枚举"><a href="#3-4-枚举" class="headerlink" title="3.4 枚举"></a>3.4 枚举</h2><blockquote><p>枚举（<code>Enum</code>）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等</p></blockquote><h3 id="3-4-1-简单的例子"><a href="#3-4-1-简单的例子" class="headerlink" title="3.4.1 简单的例子"></a>3.4.1 简单的例子</h3><blockquote><p>枚举使用 <code>enum</code> 关键字来定义：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>枚举成员会被赋值为从 <code>0</code> 开始递增的数字，同时也会对枚举值到枚举名进行反向映射</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 0); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br><span class="line"></span><br><span class="line">console.log(Days[0] === &quot;Sun&quot;); // true</span><br><span class="line">console.log(Days[1] === &quot;Mon&quot;); // true</span><br><span class="line">console.log(Days[2] === &quot;Tue&quot;); // true</span><br><span class="line">console.log(Days[6] === &quot;Sat&quot;); // true</span><br></pre></td></tr></table></figure><blockquote><p>事实上，上面的例子会被编译为</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 0] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><h3 id="3-4-2-手动赋值"><a href="#3-4-2-手动赋值" class="headerlink" title="3.4.2 手动赋值"></a>3.4.2 手动赋值</h3><blockquote><p>我们也可以给枚举项手动赋值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，未手动赋值的枚举项会接着上一个枚举项递增</p></blockquote><p>如果未手动赋值的枚举项与手动赋值的重复了，<code>TypeScript</code> 是不会察觉到这一点的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 3, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 3); // true</span><br><span class="line">console.log(Days[&quot;Wed&quot;] === 3); // true</span><br><span class="line">console.log(Days[3] === &quot;Sun&quot;); // false</span><br><span class="line">console.log(Days[3] === &quot;Wed&quot;); // true</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，递增到 <code>3</code> 的时候与前面的 <code>Sun</code> 的取值重复了，但是 <code>TypeScript</code> 并没有报错，导致 <code>Days[3]</code>的值先是 <code>&quot;Sun&quot;</code>，而后又被 <code>&quot;Wed&quot;</code> 覆盖了。编译的结果是</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 3] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 1] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 2] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 3] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 4] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 5] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = 6] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><p>所以使用的时候需要注意，最好不要出现这种覆盖的情况。</p><blockquote><p>手动赋值的枚举项可以不是数字，此时需要使用类型断言来让 <code>tsc</code> 无视类型检查 (编译出的 <code>js</code> 仍然是可用的)：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon, Tue, Wed, Thu, Fri, Sat = &lt;any&gt;&quot;S&quot;&#125;;</span><br><span class="line">var Days;</span><br><span class="line">(function (Days) &#123;</span><br><span class="line">    Days[Days[&quot;Sun&quot;] = 7] = &quot;Sun&quot;;</span><br><span class="line">    Days[Days[&quot;Mon&quot;] = 8] = &quot;Mon&quot;;</span><br><span class="line">    Days[Days[&quot;Tue&quot;] = 9] = &quot;Tue&quot;;</span><br><span class="line">    Days[Days[&quot;Wed&quot;] = 10] = &quot;Wed&quot;;</span><br><span class="line">    Days[Days[&quot;Thu&quot;] = 11] = &quot;Thu&quot;;</span><br><span class="line">    Days[Days[&quot;Fri&quot;] = 12] = &quot;Fri&quot;;</span><br><span class="line">    Days[Days[&quot;Sat&quot;] = &quot;S&quot;] = &quot;Sat&quot;;</span><br><span class="line">&#125;)(Days || (Days = &#123;&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>当然，手动赋值的枚举项也可以为小数或负数，此时后续未手动赋值的项的递增步长仍为 <code>1</code>：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Days &#123;Sun = 7, Mon = 1.5, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 7); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1.5); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2.5); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6.5); // true</span><br></pre></td></tr></table></figure><h3 id="3-4-3-常数项和计算所得项"><a href="#3-4-3-常数项和计算所得项" class="headerlink" title="3.4.3 常数项和计算所得项"></a>3.4.3 常数项和计算所得项</h3><blockquote><p>枚举项有两种类型：常数项（<code>constant member</code>）和计算所得项（<code>computed member</code>）</p></blockquote><p>前面我们所举的例子都是常数项，一个典型的计算所得项的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>&quot;blue&quot;.length</code> 就是一个计算所得项。</p></blockquote><p>上面的例子不会报错，但是如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red = &quot;red&quot;.length, Green, Blue&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,33): error TS1061: Enum member must have initializer.</span><br><span class="line">// index.ts(1,40): error TS1061: Enum member must have initializer.</span><br></pre></td></tr></table></figure><h3 id="3-4-4-常数枚举"><a href="#3-4-4-常数枚举" class="headerlink" title="3.4.4 常数枚举"></a>3.4.4 常数枚举</h3><blockquote><p>常数枚举是使用 <code>const enum</code> 定义的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><blockquote><p>常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//上例的编译结果是：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br><span class="line">// 假如包含了计算成员，则会在编译阶段报错：</span><br><span class="line"></span><br><span class="line">const enum Color &#123;Red, Green, Blue = &quot;blue&quot;.length&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(1,38): error TS2474: In &#x27;const&#x27; enum declarations member initializer must be constant expression.</span><br></pre></td></tr></table></figure><h3 id="3-4-5-外部枚举"><a href="#3-4-5-外部枚举" class="headerlink" title="3.4.5 外部枚举"></a>3.4.5 外部枚举</h3><blockquote><p>外部枚举（<code>Ambient Enums</code>）是使用 <code>declare enum</code> 定义的枚举类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><ul><li>之前提到过，<code>declare</code> 定义的类型只会用于编译时的检查，编译结果中会被删除。</li></ul><p>上例的编译结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br></pre></td></tr></table></figure><ul><li>外部枚举与声明语句一样，常出现在声明文件中。</li><li>同时使用 <code>declare</code> 和 <code>const</code> 也是可以的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare const enum Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];</span><br><span class="line">// 编译结果：</span><br><span class="line"></span><br><span class="line">var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];</span><br></pre></td></tr></table></figure><h2 id="3-5-类"><a href="#3-5-类" class="headerlink" title="3.5 类"></a>3.5 类</h2><h3 id="3-5-1-类的概念"><a href="#3-5-1-类的概念" class="headerlink" title="3.5.1 类的概念"></a>3.5.1 类的概念</h3><blockquote><p>类相关的概念做一个简单的介绍</p></blockquote><ul><li>类(<code>Class</code>)：定义了一件事物的抽象特点，包含它的属性和方法</li><li>对象（<code>Object</code>）：类的实例，通过 <code>new</code> 生成</li><li>面向对象（<code>OOP</code>）的三大特性：封装、继承、多态</li><li>封装（<code>Encapsulation</code>）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li><li>继承（<code>Inheritance</code>）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li><li>多态（<code>Polymorphism</code>）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code>还是 <code>Dog</code>，就可以直接调用 <code>eat</code>方法，程序会自动判断出来应该如何执行 <code>eat</code></li><li>存取器（<code>getter &amp; setter</code>）：用以改变属性的读取和赋值行为</li><li>修饰符（<code>Modifiers</code>）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li><li>抽象类（<code>Abstract Class</code>）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li><li>接口（<code>Interfaces</code>）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（<code>implements</code>）。一个类只能继承自另一个类，但是可以实现多个接口</li></ul><h3 id="3-5-2-public-private-和-protected"><a href="#3-5-2-public-private-和-protected" class="headerlink" title="3.5.2 public private 和 protected"></a>3.5.2 public private 和 protected</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TypeScript` 可以使用三种访问修饰符（`Access Modifiers`），分别是 `public`、`private` 和 `protected</span><br></pre></td></tr></table></figure></blockquote><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line">console.log(a.name); // Tom</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p></blockquote><p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lass Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br><span class="line"></span><br><span class="line">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br><span class="line">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子编译后的代码是：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.name);</span><br><span class="line">a.name = &#x27;Tom&#x27;;</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    private name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    protected name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name);</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-3-抽象类"><a href="#3-5-3-抽象类" class="headerlink" title="3.5.3 抽象类"></a>3.5.3 抽象类</h3><blockquote><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p></blockquote><p><strong>什么是抽象类？</strong></p><blockquote><p>首先，抽象类是不允许被实例化的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p></blockquote><p>其次，抽象类中的抽象方法必须被子类实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public eat() &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; is eating.`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p></blockquote><p>下面是一个正确使用抽象类的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    public name;</span><br><span class="line">    public constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    public sayHi() &#123;</span><br><span class="line">        console.log(`Meow, My name is $&#123;this.name&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p><blockquote><p>需要注意的是，即使是抽象方法，<code>TypeScript</code> 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var __extends = (this &amp;&amp; this.__extends) || function (d, b) &#123;</span><br><span class="line">    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    function __() &#123; this.constructor = d; &#125;</span><br><span class="line">    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());</span><br><span class="line">&#125;;</span><br><span class="line">var Animal = (function () &#123;</span><br><span class="line">    function Animal(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    return Animal;</span><br><span class="line">&#125;());</span><br><span class="line">var Cat = (function (_super) &#123;</span><br><span class="line">    __extends(Cat, _super);</span><br><span class="line">    function Cat() &#123;</span><br><span class="line">        _super.apply(this, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    Cat.prototype.sayHi = function () &#123;</span><br><span class="line">        console.log(&#x27;Meow, My name is &#x27; + this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    return Cat;</span><br><span class="line">&#125;(Animal));</span><br><span class="line">var cat = new Cat(&#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><h3 id="3-5-4-类的类型"><a href="#3-5-4-类的类型" class="headerlink" title="3.5.4 类的类型"></a>3.5.4 类的类型</h3><blockquote><p>给类加上 <code>TypeScript</code> 的类型很简单，与接口类似：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): string &#123;</span><br><span class="line">      return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: Animal = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br></pre></td></tr></table></figure><h2 id="3-6-类与接口"><a href="#3-6-类与接口" class="headerlink" title="3.6 类与接口"></a>3.6 类与接口</h2><h3 id="3-6-1-类实现接口"><a href="#3-6-1-类实现接口" class="headerlink" title="3.6.1 类实现接口"></a>3.6.1 类实现接口</h3><blockquote><p>实现（<code>implements</code>）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（<code>interfaces</code>），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性</p></blockquote><p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Door &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SecurityDoor extends Door implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;SecurityDoor alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个类可以实现多个接口</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Car implements Alarm, Light &#123;</span><br><span class="line">    alert() &#123;</span><br><span class="line">        console.log(&#x27;Car alert&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOn() &#123;</span><br><span class="line">        console.log(&#x27;Car light on&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    lightOff() &#123;</span><br><span class="line">        console.log(&#x27;Car light off&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code>接口，既能报警，也能开关车灯</p></blockquote><h3 id="3-6-2-接口继承接口"><a href="#3-6-2-接口继承接口" class="headerlink" title="3.6.2 接口继承接口"></a>3.6.2 接口继承接口</h3><blockquote><p>接口与接口之间可以是继承关系</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface LightableAlarm extends Alarm &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm</code></p></blockquote><h3 id="3-6-3-接口继承类"><a href="#3-6-3-接口继承类" class="headerlink" title="3.6.3 接口继承类"></a>3.6.3 接口继承类</h3><blockquote><p>接口也可以继承类：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">    z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-6-4-混合类型"><a href="#3-6-4-混合类型" class="headerlink" title="3.6.4 混合类型"></a>3.6.4 混合类型</h3><blockquote><p>可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>有时候，一个函数还可以有自己的属性和方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">    (start: number): string;</span><br><span class="line">    interval: number;</span><br><span class="line">    reset(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getCounter(): Counter &#123;</span><br><span class="line">    let counter = &lt;Counter&gt;function (start: number) &#123; &#125;;</span><br><span class="line">    counter.interval = 123;</span><br><span class="line">    counter.reset = function () &#123; &#125;;</span><br><span class="line">    return counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = getCounter();</span><br><span class="line">c(10);</span><br><span class="line">c.reset();</span><br><span class="line">c.interval = 5.0;</span><br></pre></td></tr></table></figure><h2 id="3-7-泛型"><a href="#3-7-泛型" class="headerlink" title="3.7 泛型"></a>3.7 泛型</h2><blockquote><p>泛型（<code>Generics</code>）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性</p></blockquote><h3 id="3-7-1-简单的例子"><a href="#3-7-1-简单的例子" class="headerlink" title="3.7.1 简单的例子"></a>3.7.1 简单的例子</h3><blockquote><p>首先，我们来实现一个函数 <code>createArray</code>，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray(length: number, value: any): Array&lt;any&gt; &#123;</span><br><span class="line">    let result = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure><ul><li>上例中，我们使用了之前提到过的数组泛型来定义返回值的类型。</li><li>这段代码编译不会报错，但是一个显而易见的缺陷是，它并没有准确的定义返回值的类型：<code>Array</code> 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的<code>value</code> 的类型。</li></ul><blockquote><p>这时候，泛型就派上用场了：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们在函数名后添加了 &#96;&#96;，其中 <code>T</code> 用来指代任意输入的类型，在后面的输入 <code>value: T</code>和输出 <code>Array</code>中即可使用了</p></blockquote><p>接着在调用的时候，可以指定它具体的类型为 <code>string</code>。当然，也可以不手动指定，而让类型推论自动推算出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure><h3 id="3-7-2-多个类型参数"><a href="#3-7-2-多个类型参数" class="headerlink" title="3.7.2 多个类型参数"></a>3.7.2 多个类型参数</h3><blockquote><p>定义泛型的时候，可以一次定义多个类型参数：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123;</span><br><span class="line">    return [tuple[1], tuple[0]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7]</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们定义了一个 <code>swap</code> 函数，用来交换输入的元组</p></blockquote><h3 id="3-7-3-泛型约束"><a href="#3-7-3-泛型约束" class="headerlink" title="3.7.3 泛型约束"></a>3.7.3 泛型约束</h3><blockquote><p>在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(2,19): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;T&#x27;.</span><br></pre></td></tr></table></figure><blockquote><p>上例中，泛型 <code>T</code> 不一定包含属性 <code>length</code>，所以编译的时候报错了。</p></blockquote><blockquote><p>这时，我们可以对泛型进行约束，只允许这个函数传入那些包含<code>length</code> 属性的变量。这就是泛型约束</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用了 <code>extends</code>约束了泛型 <code>T</code> 必须符合接口 <code>Lengthwise</code> 的形状，也就是必须包含 <code>length</code> 属性。</p></blockquote><blockquote><p>此时如果调用 <code>loggingIdentity</code> 的时候，传入的 <code>arg</code>不包含 <code>length</code>，那么在编译阶段就会报错了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(7);</span><br><span class="line"></span><br><span class="line">// index.ts(10,17): error TS2345: Argument of type &#x27;7&#x27; is not assignable to parameter of type &#x27;Lengthwise&#x27;.</span><br></pre></td></tr></table></figure><p><strong>多个类型参数之间也可以互相约束：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123;</span><br><span class="line">    for (let id in source) &#123;</span><br><span class="line">        target[id] = (&lt;T&gt;source)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">copyFields(x, &#123; b: 10, d: 20 &#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上例中，我们使用了两个类型参数，其中要求 <code>T</code> 继承 <code>U</code>，这样就保证了<code>U</code> 上不会出现 <code>T</code> 中不存在的字段</p></blockquote><h3 id="3-7-4-泛型接口"><a href="#3-7-4-泛型接口" class="headerlink" title="3.7.4 泛型接口"></a>3.7.4 泛型接口</h3><blockquote><p>可以使用接口的方式来定义一个函数需要符合的形状</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source: string, subString: string) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然也可以使用含有泛型的接口来定义函数的形状</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc &#123;</span><br><span class="line">    &lt;T&gt;(length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure><blockquote><p>进一步，我们可以把泛型参数提前到接口名上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface CreateArrayFunc&lt;T&gt; &#123;</span><br><span class="line">    (length: number, value: T): Array&lt;T&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let createArray: CreateArrayFunc&lt;any&gt;;</span><br><span class="line">createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;]</span><br></pre></td></tr></table></figure><blockquote><p>注意，此时在使用泛型接口的时候，需要定义泛型的类型</p></blockquote><h3 id="3-7-5-泛型类"><a href="#3-7-5-泛型类" class="headerlink" title="3.7.5 泛型类"></a>3.7.5 泛型类</h3><blockquote><p>与泛型接口类似，泛型也可以用于类的类型定义中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line"></span><br><span class="line">myGenericNumber.zeroValue = 0;</span><br><span class="line">myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure><h3 id="3-7-6-泛型参数的默认类型"><a href="#3-7-6-泛型参数的默认类型" class="headerlink" title="3.7.6 泛型参数的默认类型"></a>3.7.6 泛型参数的默认类型</h3><blockquote><p>在 <code>TypeScript 2.3</code>以后，我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123;</span><br><span class="line">    let result: T[] = [];</span><br><span class="line">    for (let i = 0; i &lt; length; i++) &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-8-声明合并"><a href="#3-8-声明合并" class="headerlink" title="3.8 声明合并"></a>3.8 声明合并</h2><blockquote><p>如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型</p></blockquote><h3 id="3-8-1-函数的合并"><a href="#3-8-1-函数的合并" class="headerlink" title="3.8.1 函数的合并"></a>3.8.1 函数的合并</h3><blockquote><p>我们可以使用重载定义多个函数类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function reverse(x: number): number;</span><br><span class="line">function reverse(x: string): string;</span><br><span class="line"></span><br><span class="line">function reverse(x: number | string): number | string &#123;</span><br><span class="line">    if (typeof x === &#x27;number&#x27;) &#123;</span><br><span class="line">        return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;));</span><br><span class="line">    &#125; else if (typeof x === &#x27;string&#x27;) &#123;</span><br><span class="line">        return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-2-接口的合并"><a href="#3-8-2-接口的合并" class="headerlink" title="3.8.2 接口的合并"></a>3.8.2 接口的合并</h3><blockquote><p>接口中的属性在合并时会简单的合并到一个接口中</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>相当于：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意，合并的属性的类型必须是唯一的</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    price: string;  // 类型不一致，会报错</span><br><span class="line">    weight: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable &#x27;price&#x27; must be of type &#x27;number&#x27;, but here has type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure><p><strong>接口中方法的合并，与函数的合并一样</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">&#125;</span><br><span class="line">interface Alarm &#123;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Alarm &#123;</span><br><span class="line">    price: number;</span><br><span class="line">    weight: number;</span><br><span class="line">    alert(s: string): string;</span><br><span class="line">    alert(s: string, n: number): string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-3-类的合并"><a href="#3-8-3-类的合并" class="headerlink" title="3.8.3 类的合并"></a>3.8.3 类的合并</h3><blockquote><p>类的合并与接口的合并规则一致</p></blockquote><h1 id="四、工程"><a href="#四、工程" class="headerlink" title="四、工程"></a>四、工程</h1><h2 id="4-1-tsconfig-json"><a href="#4-1-tsconfig-json" class="headerlink" title="4.1 tsconfig.json"></a>4.1 tsconfig.json</h2><p><strong>编译选项</strong></p><blockquote><p>你可以通过 <code>compilerOptions</code> 来定制你的编译选项</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line"></span><br><span class="line">    /* 基本选项 */</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;</span><br><span class="line">    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件</span><br><span class="line">    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件</span><br><span class="line">    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;</span><br><span class="line">    &quot;declaration&quot;: true,                   // 生成相应的 &#x27;.d.ts&#x27; 文件</span><br><span class="line">    &quot;sourceMap&quot;: true,                     // 生成相应的 &#x27;.map&#x27; 文件</span><br><span class="line">    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件</span><br><span class="line">    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录</span><br><span class="line">    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.</span><br><span class="line">    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释</span><br><span class="line">    &quot;noEmit&quot;: true,                        // 不生成输出文件</span><br><span class="line">    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数</span><br><span class="line">    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.</span><br><span class="line"></span><br><span class="line">    /* 严格的类型检查选项 */</span><br><span class="line">    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错</span><br><span class="line">    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查</span><br><span class="line">    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误</span><br><span class="line">    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;</span><br><span class="line"></span><br><span class="line">    /* 额外的检查 */</span><br><span class="line">    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误</span><br><span class="line">    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误</span><br><span class="line">    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误</span><br><span class="line">    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）</span><br><span class="line"></span><br><span class="line">    /* 模块解析选项 */</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)</span><br><span class="line">    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录</span><br><span class="line">    &quot;paths&quot;: &#123;&#125;,                           // 模块名到基于 baseUrl 的路径映射的列表</span><br><span class="line">    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容</span><br><span class="line">    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表</span><br><span class="line">    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。</span><br><span class="line"></span><br><span class="line">    /* Source Map Options */</span><br><span class="line">    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置</span><br><span class="line">    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置</span><br><span class="line">    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件</span><br><span class="line">    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性</span><br><span class="line"></span><br><span class="line">    /* 其他选项 */</span><br><span class="line">    &quot;experimentalDecorators&quot;: true,        // 启用装饰器</span><br><span class="line">    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-TypeScript-编译"><a href="#4-2-TypeScript-编译" class="headerlink" title="4.2 TypeScript 编译"></a>4.2 TypeScript 编译</h2><blockquote><p>运行 <code>tsc -p ./path-to-project-directory</code> 。<code>tsc -w</code>来启用 <code>TypeScript</code>编译器的观测模式，在检测到文件改动之后，它将重新编译</p></blockquote><p><strong>指定需要编译的文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;./some/file.ts&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 include 和 exclude 选项来指定需要包含的文件，和排除的文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;./folder&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;./folder/**/*.spec.ts&quot;,</span><br><span class="line">    &quot;./folder/someSubFolder&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、一些例子演示"><a href="#五、一些例子演示" class="headerlink" title="五、一些例子演示"></a>五、一些例子演示</h1><h2 id="5-1-定义ajax请求数据接口"><a href="#5-1-定义ajax请求数据接口" class="headerlink" title="5.1 定义ajax请求数据接口"></a>5.1 定义ajax请求数据接口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">interface Config&#123;</span><br><span class="line">    type:string;</span><br><span class="line">    url:string;</span><br><span class="line">    data?:string;</span><br><span class="line">    dataType:string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//原生js封装的ajax </span><br><span class="line">function ajax(config:Config)&#123;</span><br><span class="line"></span><br><span class="line">   var xhr=new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">   xhr.open(config.type,config.url,true);</span><br><span class="line"></span><br><span class="line">   xhr.send(config.data);</span><br><span class="line"></span><br><span class="line">   xhr.onreadystatechange=function()&#123;</span><br><span class="line"></span><br><span class="line">        if(xhr.readyState==4 &amp;&amp; xhr.status==200)&#123;</span><br><span class="line">            console.log(&#x27;chengong&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if(config.dataType==&#x27;json&#x27;)&#123;</span><br><span class="line"></span><br><span class="line">                console.log(JSON.parse(xhr.responseText));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                console.log(xhr.responseText)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ajax(&#123;</span><br><span class="line">    type:&#x27;get&#x27;,</span><br><span class="line">    data:&#x27;name=zhangsan&#x27;,</span><br><span class="line">    url:&#x27;http://a.itying.com/api/productlist&#x27;, //api</span><br><span class="line">    dataType:&#x27;json&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="5-2-函数类型接口-对方法约束"><a href="#5-2-函数类型接口-对方法约束" class="headerlink" title="5.2 函数类型接口-对方法约束"></a>5.2 函数类型接口-对方法约束</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 函数类型接口:对方法传入的参数 以及返回值进行约束   批量约束</span><br><span class="line"></span><br><span class="line">// 加密的函数类型接口</span><br><span class="line"></span><br><span class="line">interface encrypt&#123;</span><br><span class="line">    (key:string,value:string):string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var md5:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line">        //模拟操作</span><br><span class="line">        return key+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(md5(&#x27;name&#x27;,&#x27;zhangsan&#x27;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var sha1:encrypt=function(key:string,value:string):string&#123;</span><br><span class="line"></span><br><span class="line">    //模拟操作</span><br><span class="line">    return key+&#x27;----&#x27;+value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sha1(&#x27;name&#x27;,&#x27;lisi&#x27;));</span><br></pre></td></tr></table></figure><h2 id="5-3-可索引接口：数组、对象的约束（不常用）"><a href="#5-3-可索引接口：数组、对象的约束（不常用）" class="headerlink" title="5.3 可索引接口：数组、对象的约束（不常用）"></a>5.3 可索引接口：数组、对象的约束（不常用）</h2><h3 id="5-3-1-可索引接口-对数组的约束"><a href="#5-3-1-可索引接口-对数组的约束" class="headerlink" title="5.3.1 可索引接口-对数组的约束"></a>5.3.1 可索引接口-对数组的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface UserArr&#123;</span><br><span class="line">    [index:number]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr:UserArr=[&#x27;aaa&#x27;,&#x27;bbb&#x27;];</span><br><span class="line"></span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure><h3 id="5-3-2-可索引接口-对对象的约束"><a href="#5-3-2-可索引接口-对对象的约束" class="headerlink" title="5.3.2 可索引接口-对对象的约束"></a>5.3.2 可索引接口-对对象的约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface UserObj&#123;</span><br><span class="line">    [index:string]:string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr:UserObj=&#123;name:&#x27;张三&#x27;&#125;;</span><br></pre></td></tr></table></figure><h3 id="5-3-3-类类型接口-对类的约束"><a href="#5-3-3-类类型接口-对类的约束" class="headerlink" title="5.3.3 类类型接口:对类的约束"></a>5.3.3 类类型接口:对类的约束</h3><ul><li>抽象类抽象有点相似</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(str:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog implements Animal&#123;</span><br><span class="line"></span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃粮食&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var d=new Dog(&#x27;小黑&#x27;);</span><br><span class="line">d.eat();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cat implements Animal&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line"></span><br><span class="line">        this.name=name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    eat(food:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;吃&#x27;+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c=new Cat(&#x27;小花&#x27;);</span><br><span class="line">c.eat(&#x27;老鼠&#x27;);</span><br></pre></td></tr></table></figure><h2 id="5-4-接口的扩展"><a href="#5-4-接口的扩展" class="headerlink" title="5.4 接口的扩展"></a>5.4 接口的扩展</h2><blockquote><p>接口继承接口 类实现接口</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person extends Animal&#123;</span><br><span class="line"></span><br><span class="line">    work():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Programmer&#123;</span><br><span class="line"></span><br><span class="line">    public name:string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    coding(code:string)&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+code)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Web extends Programmer implements Person&#123;</span><br><span class="line">    </span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">       super(name)</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;喜欢吃馒头&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    work()&#123;</span><br><span class="line"></span><br><span class="line">        console.log(this.name+&#x27;写代码&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var w=new Web(&#x27;小李&#x27;);</span><br><span class="line"></span><br><span class="line">// w.eat();</span><br><span class="line"></span><br><span class="line">w.coding(&#x27;写ts代码&#x27;);</span><br></pre></td></tr></table></figure><h2 id="5-5-泛型类接口"><a href="#5-5-泛型类接口" class="headerlink" title="5.5 泛型类接口"></a>5.5 泛型类接口</h2><h3 id="5-5-1-泛型类-泛型方法"><a href="#5-5-1-泛型类-泛型方法" class="headerlink" title="5.5.1 泛型类 泛型方法"></a>5.5.1 泛型类 泛型方法</h3><ul><li>泛型：软件工程中，我们不仅要创建一致的定义良好的<code>API</code>，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</li><li>在像<code>C#</code>和<code>Java</code>这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</li><li>通俗理解：泛型就是解决类接口方法的复用性、以及对不特定数据类型的支持(类型校验)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line">//同时返回 string类型 和number类型  any可以解决这个问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> function getData(value:any):any&#123;</span><br><span class="line">    return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData(123);</span><br><span class="line">getData(&#x27;str&#x27;);</span><br><span class="line">//any放弃了类型检查,传入什么 返回什么。比如:传入number 类型必须返回number类型  传入 string类型必须返回string类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//传入的参数类型和返回的参数类型可以不一致</span><br><span class="line">function getData(value:any):any&#123;</span><br><span class="line">  return &#x27;哈哈哈&#x27;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>T</code>表示泛型，具体什么类型是调用这个方法的时候决定的</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">   return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(&#x27;2112&#x27;);       /*错误的写法*/</span><br><span class="line">function getData&lt;T&gt;(value:T):any&#123;</span><br><span class="line">   return &#x27;2145214214&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData&lt;number&gt;(123);  //参数必须是number</span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;这是一个泛型&#x27;);</span><br></pre></td></tr></table></figure><p><strong>泛型类</strong></p><blockquote><p>泛型类：比如有个最小堆算法，需要同时支持返回数字和字符串 <code>a - z</code>两种类型。 通过类的泛型来实现</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 基本写法 但是不能传入字符串</span><br><span class="line">class MinClass&#123;</span><br><span class="line">    public list:number[]=[];</span><br><span class="line">    add(num:number)&#123;</span><br><span class="line">        this.list.push(num)</span><br><span class="line">    &#125;</span><br><span class="line">    min():number&#123;</span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m=new MinClass();</span><br><span class="line"></span><br><span class="line">m.add(3);</span><br><span class="line">m.add(22);</span><br><span class="line">m.add(23);</span><br><span class="line">m.add(6);</span><br><span class="line"></span><br><span class="line">m.add(7);</span><br><span class="line">alert(m.min());</span><br></pre></td></tr></table></figure><p><strong>类的泛型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 通过泛型改写 可以同时传入number 字符串等</span><br><span class="line">//类的泛型</span><br><span class="line">class MinClas&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">    public list:T[]=[];</span><br><span class="line"></span><br><span class="line">    add(value:T):void&#123;</span><br><span class="line"></span><br><span class="line">        this.list.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    min():T&#123;        </span><br><span class="line">        var minNum=this.list[0];</span><br><span class="line">        for(var i=0;i&lt;this.list.length;i++)&#123;</span><br><span class="line">            if(minNum&gt;this.list[i])&#123;</span><br><span class="line">                minNum=this.list[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var m1=new MinClas&lt;number&gt;();   /*实例化类 并且制定了类的T代表的类型是number*/</span><br><span class="line">m1.add(11);</span><br><span class="line">m1.add(3);</span><br><span class="line">m1.add(2);</span><br><span class="line">alert(m1.min())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var m2=new MinClas&lt;string&gt;();   /*实例化类 并且制定了类的T代表的类型是string*/</span><br><span class="line"></span><br><span class="line">m2.add(&#x27;c&#x27;);</span><br><span class="line">m2.add(&#x27;a&#x27;);</span><br><span class="line">m2.add(&#x27;v&#x27;);</span><br><span class="line">alert(m2.min())</span><br></pre></td></tr></table></figure><h3 id="5-5-2-泛型接口"><a href="#5-5-2-泛型接口" class="headerlink" title="5.5.2 泛型接口"></a>5.5.2 泛型接口</h3><p><strong>1. 方式1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&#123;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure><p><strong>2. 方式2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface ConfigFn&lt;T&gt;&#123;</span><br><span class="line">    (value:T):T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var myGetData:ConfigFn&lt;string&gt;=getData;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">myGetData(&#x27;20&#x27;);  /*正确*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// myGetData(20)  //错误</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;h2 id=&quot;1-1-什么是-TypeScript&quot;&gt;&lt;a href=&quot;#1-1-什么是-TypeScript&quot; class=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript实践总结[基础+工程+实践]</title>
    <link href="http://example.com/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93[%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5]/"/>
    <id>http://example.com/2021/08/15/html+css+js+ts/5-Typescript%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93[%E5%9F%BA%E7%A1%80+%E5%B7%A5%E7%A8%8B+%E5%AE%9E%E8%B7%B5]/</id>
    <published>2021-08-15T06:31:08.000Z</published>
    <updated>2022-06-07T00:44:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-基础篇"><a href="#第一章-基础篇" class="headerlink" title="第一章 基础篇"></a>第一章 基础篇</h1><blockquote><p>TS基础篇</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/base-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-8.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-9.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/base-10.webp" alt="img"></p><h2 id="一、基本类型"><a href="#一、基本类型" class="headerlink" title="一、基本类型"></a>一、基本类型</h2><ul><li><code>JavaScript</code> 的类型分为两种：原始数据类型和对象类型。</li><li>原始数据类型包括：布尔值、数值、字符串、<code>null</code>、<code>undefined</code> 以及 ES6 中的新类型 <code>Symbol</code></li><li>本节主要介绍前五种原始数据类型在 <code>TypeScript</code> 中的应用。</li><li>布尔值是最基础的数据类型，在 <code>TypeScript</code> 中，使用 <code>boolean</code> 定义布尔值类型</li></ul><p><strong>ES6数据类型</strong></p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Array</code></li><li><code>Function</code></li><li><code>Object</code></li><li><code>Symbol</code></li><li><code>undefined</code></li><li><code>null</code></li></ul><p><strong>Typescript数据类型</strong></p><ul><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Array</code></li><li><code>Function</code></li><li><code>Object</code></li><li><code>Symbol</code></li><li><code>undefined</code></li><li><code>null</code></li><li><code>void</code></li><li><code>any</code></li><li><code>never</code></li><li>元组</li><li>枚举</li><li>高级类型</li></ul><p><strong>正确的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 布尔值</span><br><span class="line">let isDone: boolean = false;  </span><br><span class="line"></span><br><span class="line">// 事实上 `new Boolean()` 返回的是一个 `Boolean` 对象</span><br><span class="line">let createdByNewBoolean: Boolean = new Boolean(1);</span><br><span class="line"></span><br><span class="line">//(直接调用 `Boolean` 也可以返回一个 `boolean` 类型) </span><br><span class="line">let createdByBoolean: boolean = Boolean(1); </span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 数值</span><br><span class="line">let decLiteral: number = 6;</span><br><span class="line">let hexLiteral: number = 0xf00d;</span><br><span class="line"></span><br><span class="line">// ES6 中的二进制表示法</span><br><span class="line">let binaryLiteral: number = 0b1010;</span><br><span class="line"></span><br><span class="line">// ES6 中的八进制表示法</span><br><span class="line">let octalLiteral: number = 0o744;</span><br><span class="line">let notANumber: number = NaN;</span><br><span class="line">let infinityNumber: number = Infinity;</span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = &#x27;Tom&#x27;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;</span><br><span class="line">    alert(&#x27;My name is Tom&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = undefined;</span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = undefined;</span><br><span class="line">let n: null = null;</span><br></pre></td></tr></table></figure><p><strong>错误的写法</strong></p><blockquote><p>注意:正确的很好记,大多数人都会写正确的,关键是要记住这些错误的!!!</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖布尔➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 注意，使用构造函数 `Boolean` 创造的对象不是布尔值</span><br><span class="line">let createdByNewBoolean: boolean = new Boolean(1);❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖数值➖➖➖➖➖➖➖➖➖</span><br><span class="line">let decLiteral: number = &quot;6&quot;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖字符串➖➖➖➖➖➖➖➖➖</span><br><span class="line">let myName: string = 999;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖空值➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 没有返回值的函数为void</span><br><span class="line">function alertName(): void &#123;❌</span><br><span class="line">   return 666;</span><br><span class="line">&#125;</span><br><span class="line">//声明一个 void 类型的只能将它赋值为 undefined 和 null</span><br><span class="line">let unusable: void = &#x27;I love you&#x27;;❌</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖Null 和 Undefined➖➖➖➖➖➖➖➖➖</span><br><span class="line">// undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null</span><br><span class="line">let u: undefined = 888;❌</span><br><span class="line">let n: null = 999;❌</span><br></pre></td></tr></table></figure><h2 id="二、任意值"><a href="#二、任意值" class="headerlink" title="二、任意值"></a>二、任意值</h2><p><strong>正确的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 顾名思义,可以被任何值赋值</span><br><span class="line">let anyThing: any = &#x27;hello&#x27;;</span><br><span class="line">let anyThing: any = 888;</span><br><span class="line">let anyThing: any = true;</span><br><span class="line">let anyThing: any = null;</span><br><span class="line">let anyThing: any = undefined;</span><br><span class="line"></span><br><span class="line">// 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：</span><br><span class="line">let any;</span><br><span class="line">any =true;</span><br></pre></td></tr></table></figure><h2 id="三、类型推论"><a href="#三、类型推论" class="headerlink" title="三、类型推论"></a>三、类型推论</h2><p><strong>正确的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;  </span><br><span class="line">//等价于</span><br><span class="line">let myFavoriteNumber :string= &#x27;seven&#x27;;</span><br></pre></td></tr></table></figure><p><strong>错误的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 第一句已经被推论为String类型了</span><br><span class="line">let myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;❌</span><br></pre></td></tr></table></figure><h2 id="四、联合类型"><a href="#四、联合类型" class="headerlink" title="四、联合类型"></a>四、联合类型</h2><p><strong>正确的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 联合类型（Union Types）表示取值可以为多种类型中的一种。</span><br><span class="line">// 当你允许某个变量被赋值多种类型的时候,使用联合类型,管道符进行连接</span><br><span class="line">let myFavoriteNumber: string | number;</span><br><span class="line">myFavoriteNumber = &#x27;seven&#x27;;</span><br><span class="line">myFavoriteNumber = 7;</span><br><span class="line"></span><br><span class="line">// 也可用于方法的参数定义, 都有toString方法,访问 string 和 number 的共有属性是没问题的</span><br><span class="line">function getString(something: string | number): string &#123;</span><br><span class="line">    return something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// number类型没有length属性.所以编译错误,因为我们只能访问此联合类型的所有类型里共有的属性或方法：</span><br><span class="line">function getLength(something: string | number): number &#123;❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、对象的类型——接口"><a href="#五、对象的类型——接口" class="headerlink" title="五、对象的类型——接口"></a>五、对象的类型——接口</h2><p><strong>正确的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 赋值的时候，变量的形状必须和接口的形状保持一致(不能多也不能少,类型还必须一致)</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IUserInfo&#123;</span><br><span class="line">  age : any;//定义一个任何变量的 age.</span><br><span class="line">  userName :string;//定义一个 username.</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo(user : IUserInfo):string&#123;</span><br><span class="line">    return user.age+&quot;======&quot;+user.userName; </span><br><span class="line">&#125;</span><br><span class="line">  ➖➖➖➖➖➖➖➖➖可选属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number; // 表示这个属性可有可无</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">// 可索引签名</span><br><span class="line">interface StringArrary &#123;</span><br><span class="line">  [index]: string // 数字索引。通过数字索引，返回string类型</span><br><span class="line">  [string]: string // 字符串索引签名。两者不能混用，一起使用的前提是数字索引是字符串索引的子集</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myArr: StringArrary</span><br><span class="line">myArr = [&#x27;test1&#x27;,&#x27;test2&#x27;]</span><br><span class="line">let myString = myArr[0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  ➖➖➖➖➖➖➖➖➖任意属性➖➖➖➖➖➖➖➖➖</span><br><span class="line"></span><br><span class="line">//希望一个接口允许有任意的属性，可以使用如下方式：旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27; // 可以加其他的属性</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number; // </span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757, // 只读</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>错误的写法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;❌</span><br><span class="line">&#125;;</span><br><span class="line">上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖只读属性➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757; // 不能被二次赋值❌</span><br></pre></td></tr></table></figure><p><strong>数组只读属性</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myARr:readonlyArrary&lt;number&gt; = [1,2,3]</span><br></pre></td></tr></table></figure><h2 id="六、数组的类型"><a href="#六、数组的类型" class="headerlink" title="六、数组的类型"></a>六、数组的类型</h2><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖用接口表示数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖any 在数组中的应用➖➖➖➖➖➖➖➖➖</span><br><span class="line">let list: any[] = [&#x27;Xcat Liu&#x27;, 25, &#123; website: &#x27;http://xcatliu.com&#x27; &#125;];</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖类数组➖➖➖➖➖➖➖➖➖</span><br><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 数组的项中不允许出现其他的类型：</span><br><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];❌</span><br><span class="line"></span><br><span class="line">// push 方法只允许传入 number 类型的参数，但是却传了一个 string 类型的参数，所以报错了。</span><br><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);❌</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 类数组（Array-like Object）不是数组类型，比如 arguments</span><br><span class="line">function sum() &#123;❌</span><br><span class="line">    let args: number[] = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、函数的类型"><a href="#七、函数的类型" class="headerlink" title="七、函数的类型"></a>七、函数的类型</h2><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 需要把输入和输出都考虑到</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖函数表达式➖➖➖➖➖➖➖➖➖</span><br><span class="line">let mySum = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">// 不要混淆了 TypeScript 中的 =&gt; 和 ES6 中的 =&gt;</span><br><span class="line">let mySum: (x: number, y: number) =&gt; number = function (x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;;</span><br><span class="line">➖➖➖➖➖➖➖➖➖接口定义函数的形状➖➖➖➖➖➖➖➖➖</span><br><span class="line">interface SearchFunc &#123;</span><br><span class="line">    (source: string, subString: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let mySearch: SearchFunc;</span><br><span class="line">mySearch = function(source, subString) &#123;</span><br><span class="line">    return source.search(subString) !== -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖可选参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName?: string) &#123;</span><br><span class="line">    if (lastName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(&#x27;Tom&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖参数默认值➖➖➖➖➖➖➖➖➖</span><br><span class="line">function buildName(firstName: string, lastName: string = &#x27;Cat&#x27;) &#123;</span><br><span class="line">    return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">➖➖➖➖➖➖➖➖➖剩余参数➖➖➖➖➖➖➖➖➖</span><br><span class="line">// rest 参数只能是最后一个参数，关于 rest 参数,是一个数组</span><br><span class="line">function push(array: any[], ...items: any[]) &#123;</span><br><span class="line">    items.forEach(function(item) &#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = [];</span><br><span class="line">push(a, 1, 2, 3);</span><br></pre></td></tr></table></figure><p><strong>错误的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3); ❌</span><br><span class="line">sum(1);❌</span><br><span class="line"></span><br><span class="line">// 输入多余的（或者少于要求的）参数，是不被允许的：</span><br><span class="line">function sum(x: number, y: number): number &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">sum(1, 2, 3);</span><br><span class="line"></span><br><span class="line">// 可选参数后面不允许再出现必须参数了：</span><br><span class="line">function buildName(firstName?: string, lastName: string) &#123;❌</span><br><span class="line">    if (firstName) &#123;</span><br><span class="line">        return firstName + &#x27; &#x27; + lastName;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);</span><br><span class="line">let tom = buildName(undefined, &#x27;Tom&#x27;);</span><br></pre></td></tr></table></figure><h3 id="7-1-函数相关知识点梳理"><a href="#7-1-函数相关知识点梳理" class="headerlink" title="7.1 函数相关知识点梳理"></a>7.1 函数相关知识点梳理</h3><p><strong>四种声明方式：</strong></p><ul><li>通过<code>function</code></li><li>通过变量</li><li>通过接口</li><li>通过类型别名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数定义</span><br><span class="line">function add1(x: number, y: number) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过变量</span><br><span class="line">let add2: (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">let add3 = (x: number, y: number) =&gt; number</span><br><span class="line"></span><br><span class="line">// 通过类型别名</span><br><span class="line">interface add4 &#123;</span><br><span class="line">    (x: number, y: number): number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用interface定义函数和用type定义函数有区别?</strong></p><ul><li><code>type</code>：不是创建新的类型，只是为一个给定的类型起一个名字。<code>type</code>还可以进行联合、交叉等操作，引用起来更简洁</li><li><code>interface</code>：创建新的类型，接口之间还可以继承、声明合并</li><li>如果可能，建议优先使用 <code>interface</code>。</li><li>混合接口一般是为第三方类库写声明文件时会用到，很多类库名称可以直接当函数调用，也可以有些属性和方法。例子可以看一下<code>@types/jest/index.d.ts</code> 里面有一些混合接口。</li><li>用混合接口声明函数和用接口声明类的区别是，接口不能声明类的构造函数（既不带名称的函数），但混合接口可以，其他都一样。</li></ul><p><strong>函数重载</strong></p><p>函数名相同，返回类型不同</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add8(...rest: number[]): number;</span><br><span class="line">function add8(...rest: string[]): string;</span><br><span class="line">function add8(...rest: any[]): any &#123;</span><br><span class="line">    let first = rest[0];</span><br><span class="line">    if(typeof first === &#x27;string&#x27;) &#123;</span><br><span class="line">        return rest.join(&#x27;&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    if(typeof first === &#x27;number&#x27;) &#123;</span><br><span class="line">        return rest.reduce((pre, cur) =&gt; pre + cur)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、类型断言"><a href="#八、类型断言" class="headerlink" title="八、类型断言"></a>八、类型断言</h2><ul><li>有时候你会遇到这样的情况，你会比 <code>TypeScript</code> 更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</li><li>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 <code>TypeScript</code> 会假设你，程序员，已经进行了必须的检查。</li></ul><p>类型断言有两种形式。 其一是“尖括号”语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (&lt;string&gt;someValue).length</span><br></pre></td></tr></table></figure><blockquote><p>另一个为 <code>as</code> 语法：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let someValue: any = &#x27;this is a string&#x27;</span><br><span class="line"></span><br><span class="line">let strLength: number = (someValue as string).length</span><br></pre></td></tr></table></figure><blockquote><p>两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 <code>TypeScript</code> 里使用 <code>JSX</code>时，只有<code>as</code> 语法断言是被允许</p></blockquote><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 可以使用类型断言，将 something 断言成 string</span><br><span class="line">function getLength(something: string | number): number &#123;</span><br><span class="line">    if ((&lt;string&gt;something).length) &#123;</span><br><span class="line">        return (&lt;string&gt;something).length;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return something.toString().length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 只能访问此联合类型的所有类型里共有的属性或方法</span><br><span class="line">function getLength(something: string | number): number &#123; ❌</span><br><span class="line">    return something.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="九、类型别名"><a href="#九、类型别名" class="headerlink" title="九、类型别名"></a>九、类型别名</h2><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 使用 type 创建类型别名,类型别名常用于联合类型</span><br><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = Name | NameResolver;</span><br><span class="line">function getName(n: NameOrResolver): Name &#123;</span><br><span class="line">    if (typeof n === &#x27;string&#x27;) &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、枚举"><a href="#十、枚举" class="headerlink" title="十、枚举"></a>十、枚举</h2><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天</span><br><span class="line">// 枚举就是枚举值到枚举名进行反向映射</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 0</span><br><span class="line">console.log(Days[0]); // &#x27;Sun&#x27;</span><br><span class="line"></span><br><span class="line">enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line">console.log(Days[&quot;Sun&quot;]); // 7</span><br></pre></td></tr></table></figure><h2 id="十一、类"><a href="#十一、类" class="headerlink" title="十一、类"></a>十一、类</h2><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">➖➖➖➖➖➖➖➖➖类➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return `My name is $&#123;this.name&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">console.log(a.sayHi()); // My name is Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖继承➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        super(name); // 调用父类的 constructor(name)</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi() &#123;</span><br><span class="line">        return &#x27;Meow, &#x27; + super.sayHi(); // 调用父类的 sayHi()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let c = new Cat(&#x27;Tom&#x27;); // Tom</span><br><span class="line">console.log(c.sayHi()); // Meow, My name is Tom</span><br><span class="line">➖➖➖➖➖➖➖➖➖存储器➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    constructor(name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    get name() &#123;</span><br><span class="line">        return &#x27;Jack&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    set name(value) &#123;</span><br><span class="line">        console.log(&#x27;setter: &#x27; + value);</span><br><span class="line">        this.name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Kitty&#x27;); // setter: Kitty</span><br><span class="line">a.name = &#x27;Tom&#x27;; // setter: Tom</span><br><span class="line">console.log(a.name); // Jack</span><br><span class="line">➖➖➖➖➖➖➖➖➖静态方法➖➖➖➖➖➖➖➖➖</span><br><span class="line">class Animal &#123;</span><br><span class="line">    static isAnimal(a) &#123;</span><br><span class="line">        return a instanceof Animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = new Animal(&#x27;Jack&#x27;);</span><br><span class="line">Animal.isAnimal(a); // true</span><br><span class="line">// 只能通过类名调用</span><br><span class="line">a.isAnimal(a); // TypeError: a.isAnimal is not a function ❌</span><br><span class="line">➖➖➖➖➖➖➖➖➖抽象类➖➖➖➖➖➖➖➖➖</span><br><span class="line">// 只能被继承，不能被实例化</span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    console.log(&#x27;eat&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">  abstract sleep(): void</span><br><span class="line">&#125;</span><br><span class="line">// 子类必须实现抽象类的抽象方法</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        super()</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;dog sleep&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog = new Dog(&#x27;wang&#x27;)</span><br><span class="line">dog.eat()</span><br></pre></td></tr></table></figure><h3 id="11-1类与接口的关系"><a href="#11-1类与接口的关系" class="headerlink" title="11.1类与接口的关系"></a>11.1类与接口的关系</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">interface Human &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实现接口中声明的属性</span><br><span class="line">class Person implements Human &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    name: string;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 接口可以像类一样实现继承</span><br><span class="line">interface Man extends Human &#123;</span><br><span class="line">    run(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Child &#123;</span><br><span class="line">    cry(): voild</span><br><span class="line">&#125;</span><br><span class="line">interface Boy extends Man,Child &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 添加被继承过来的属性</span><br><span class="line">let body: Boy = &#123;</span><br><span class="line">    name: &#x27;xx&#x27;,</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    eat() &#123;&#125;,</span><br><span class="line">    cry() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十二、public-private-和-protected"><a href="#十二、public-private-和-protected" class="headerlink" title="十二、public private 和 protected"></a>十二、public private 和 protected</h2><ul><li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li><li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li></ul><h2 id="十三、泛型"><a href="#十三、泛型" class="headerlink" title="十三、泛型"></a>十三、泛型</h2><blockquote><p>更多详情 <a href="http://blog.poetries.top/ts-axios/chapter2/generic.html">http://blog.poetries.top/ts-axios/chapter2/generic.html</a></p></blockquote><blockquote><p>泛型就是解决 类 接口 方法的复用性、以及对不特定数据类型的支持。<strong>泛型理解为代表类型的参数，只是另一个维度的参数</strong></p></blockquote><p><strong>正确的做法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//只能返回string类型的数据</span><br><span class="line">function getData(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//同时返回 string类型 和number类型  （代码冗余）</span><br><span class="line">function getData1(value:string):string&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">function getData2(value:number):number&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;使用泛型后就可以解决这个问题</span><br><span class="line">// T表示泛型，具体什么类型是调用这个方法的时候决定的</span><br><span class="line">// 表示参数是什么类型就返回什么类型~~~</span><br><span class="line">function getData&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;number&gt;(123);</span><br><span class="line">getData&lt;string&gt;(&#x27;1214231&#x27;);</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">interface ConfigFn&#123;</span><br><span class="line">    &lt;T&gt;(value:T):T;</span><br><span class="line">&#125;</span><br><span class="line">var getData:ConfigFn=function&lt;T&gt;(value:T):T&#123;</span><br><span class="line">  return value;</span><br><span class="line">&#125;</span><br><span class="line">getData&lt;string&gt;(&#x27;张三&#x27;);</span><br><span class="line">getData&lt;string&gt;(1243);  //错误</span><br></pre></td></tr></table></figure><h3 id="13-1-泛型函数和接口"><a href="#13-1-泛型函数和接口" class="headerlink" title="13.1 泛型函数和接口"></a>13.1 泛型函数和接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 这两个等价的，使用时无需指定类型</span><br><span class="line">type Log = &lt;T&gt;(value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 只约束改成员</span><br><span class="line">interface Log &#123;</span><br><span class="line">  &lt;T&gt;(value: T):T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这两个等价的，使用时必须指定类型</span><br><span class="line">type Log&lt;T&gt; = (value: T) =&gt; T;</span><br><span class="line"></span><br><span class="line">// 约束接口的所有成员</span><br><span class="line">interface Log&lt;T&gt; &#123;</span><br><span class="line">  (value: T):T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="13-2-泛型类与泛型约束"><a href="#13-2-泛型类与泛型约束" class="headerlink" title="13.2 泛型类与泛型约束"></a>13.2 泛型类与泛型约束</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 把泛型放到类的后面，就可以约束所有成员</span><br><span class="line">class Log&lt;T&gt; &#123;</span><br><span class="line">    run(value: T) &#123;</span><br><span class="line">        return value</span><br><span class="line">    &#125;</span><br><span class="line">    // 不能约束静态成员</span><br><span class="line">   // static eat() // 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化类 传入类型</span><br><span class="line">let log1 = new Log&lt;number&gt;()</span><br><span class="line">log1.run(1)</span><br><span class="line"></span><br><span class="line">// 不指定类型参数传任意都允许</span><br><span class="line">let log2 = new Log()</span><br><span class="line">log2.run(&#x27;1&#x27;)</span><br></pre></td></tr></table></figure><p><strong>类型约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Length &#123;</span><br><span class="line">    length: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// T继承了接口 约束了不是任意类型都可传。传入的参数必须有length属性</span><br><span class="line">function log&lt;T extends Length&gt;(value: T): T &#123;</span><br><span class="line">    console.log(value, value.length)</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 如数组、字符串、对象都有length属性</span><br><span class="line">log([1])</span><br><span class="line">log(&#x27;1&#x27;)</span><br><span class="line">log(&#123;a:1&#125;)</span><br></pre></td></tr></table></figure><ul><li>函数和类可以轻松支持多种类型，增强程序的扩展性</li><li>不必写多条函数重载</li><li>灵活控制类型之间的约束</li></ul><p><strong>对象属性约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 泛型约束对象中的属性</span><br><span class="line">function getProp&lt;T,K extends keyof T&gt;(obj:T,key: K) &#123;</span><br><span class="line">    return obj[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十四、类型检查机制"><a href="#十四、类型检查机制" class="headerlink" title="十四、类型检查机制"></a>十四、类型检查机制</h2><h3 id="14-1-类型检查机制"><a href="#14-1-类型检查机制" class="headerlink" title="14.1 类型检查机制"></a>14.1 类型检查机制</h3><blockquote><p>编译器在做类型检查时，秉承的一些原则，表现出的一些行为</p></blockquote><p>作用：辅助开发，提高开发效率</p><ul><li>类型推断</li><li>类型兼容性</li><li>类型保护</li></ul><blockquote><p>所谓类型推断：不需要指定变量的类型（函数的返回值类型），TS可以根据某些规则自动的为其推断出一个类型</p></blockquote><ul><li>基础类型推断</li><li>最佳通用类型推断</li><li>上下文类型推断</li></ul><blockquote><p>基础类型推断，从右向左。但是有些是从左向右推断</p></blockquote><p>如事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// ts 根据onkeydown推断出类型</span><br><span class="line">window.onkeydown = event=&gt;&#123;</span><br><span class="line">    console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过类型断言阻断TS的类型推断</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">    bar: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//let foo = &#123;&#125; as Foo</span><br><span class="line">//foo.bar = 1</span><br><span class="line"></span><br><span class="line">let foo: Foo = &#123;</span><br><span class="line">    bar: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-2-类型保护机制"><a href="#14-2-类型保护机制" class="headerlink" title="14.2 类型保护机制"></a>14.2 类型保护机制</h3><blockquote><p>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员</p></blockquote><p><strong>不同的判断方法有不同的使用场景：</strong></p><ul><li><code>typeof</code>：判断一个变量的类型</li><li><code>instanceof</code>：判断一个实例是否属于某个类</li><li><code>in</code>：判断一个属性是否属于某个对象</li><li>类型保护函数：某些判断可能不是一条语句能够搞定的，需要更多复杂的逻辑，适合封装到一个函数内</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function getLanguage(type: Type) &#123;</span><br><span class="line">    let lang = type === type.Strong ? new Java(): new Javascript()</span><br><span class="line">    </span><br><span class="line">    // 类型保护instanceof</span><br><span class="line">    if(lang instanceof Java)&#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // in</span><br><span class="line">    if(&#x27;java&#x27; in lang) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 类型保护函数方式</span><br><span class="line">    if(isJava(lang)) &#123;</span><br><span class="line">        lang.hellJava()</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        lang.hellJavaScript()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建一种类型保护函数</span><br><span class="line">function isJava(lang: Java | Javascript): lang is Java &#123;</span><br><span class="line">    // 类型断言</span><br><span class="line">    return (lang as Java).lang.helloJava !== undefined</span><br><span class="line">&#125;</span><br><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">// 每一个成员访问都会报错</span><br><span class="line">if (pet.swim) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125; else if (pet.fly) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让这段代码工作，我们要使用类型断言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let pet = getSmallPet()</span><br><span class="line"></span><br><span class="line">if ((pet as Fish).swim) &#123;</span><br><span class="line">  (pet as Fish).swim()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  (pet as Bird).fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-2-1-用户自定义的类型保护"><a href="#14-2-1-用户自定义的类型保护" class="headerlink" title="14.2.1 用户自定义的类型保护"></a>14.2.1 用户自定义的类型保护</h4><ul><li>这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 <code>pet</code> 的类型的话就好了。</li><li><code>TypeScript</code> 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function isFish(pet: Fish | Bird): pet is Fish &#123;</span><br><span class="line">  return (pet as Fish).swim !== undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这个例子里，<code>pet is Fish</code> 就是类型谓词。谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</li><li>每当使用一些变量调用 <code>isFish</code> 时，TypeScript 会将变量缩减为那个具体的类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (isFish(pet)) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 TypeScript 不仅知道在 <code>if</code> 分支里 <code>pet</code> 是 <code>Fish</code> 类型；它还清楚在<code>else</code> 分支里，一定不是 <code>Fish</code>类型而是 <code>Bird</code> 类型</p></blockquote><h4 id="14-2-2-typeof-类型保护"><a href="#14-2-2-typeof-类型保护" class="headerlink" title="14.2.2 typeof 类型保护"></a>14.2.2 typeof 类型保护</h4><p>我们可以像下面这样利用类型断言来写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function isNumber (x: any):x is string &#123;</span><br><span class="line">  return typeof x === &#x27;number&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isString (x: any): x is string &#123;</span><br><span class="line">  return typeof x === &#x27;string&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (isNumber(padding)) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (isString(padding)) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 <code>typeof x === &#39;number&#39;</code>抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function padLeft (value: string, padding: string | number) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这些 <code>typeof</code> 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code>必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>，<code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。</p></blockquote><h4 id="14-2-3-instanceof-类型保护"><a href="#14-2-3-instanceof-类型保护" class="headerlink" title="14.2.3 instanceof 类型保护"></a>14.2.3 instanceof 类型保护</h4><ul><li>如果你已经阅读了 <code>typeof</code> 类型保护并且对 JavaScript 里的 <code>instanceof</code> 操作符熟悉的话，你可能已经猜到了这节要讲的内容。</li><li><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Bird &#123;</span><br><span class="line">  fly () &#123;</span><br><span class="line">    console.log(&#x27;bird fly&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;bird lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Fish &#123;</span><br><span class="line">  swim () &#123;</span><br><span class="line">    console.log(&#x27;fish swim&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  layEggs () &#123;</span><br><span class="line">    console.log(&#x27;fish lay eggs&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getRandomPet () &#123;</span><br><span class="line">  return Math.random() &gt; 0.5 ? new Bird() : new Fish()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getRandomPet()</span><br><span class="line"></span><br><span class="line">if (pet instanceof Bird) &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br><span class="line">if (pet instanceof Fish) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十五、高级类型"><a href="#十五、高级类型" class="headerlink" title="十五、高级类型"></a>十五、高级类型</h2><h3 id="15-1-交叉类型（取并集）"><a href="#15-1-交叉类型（取并集）" class="headerlink" title="15.1 交叉类型（取并集）"></a>15.1 交叉类型（取并集）</h3><blockquote><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Loggable</code> 同时是 <code>Person</code> 和 <code>Loggable</code>。就是说这个类型的对象同时拥有了这两种类型的成员。</p></blockquote><blockquote><p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript里发生这种情况的场合很多！）下面是如何创建混入的一个简单例子</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">function extend&lt;T, U&gt; (first: T, second: U): T &amp; U &#123;</span><br><span class="line">  let result = &#123;&#125; as T &amp; U</span><br><span class="line">  for (let id in first) &#123;</span><br><span class="line">    result[id] = first[id] as any</span><br><span class="line">  &#125;</span><br><span class="line">  for (let id in second) &#123;</span><br><span class="line">    if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">      result[id] = second[id] as any</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">  constructor (public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Loggable &#123;</span><br><span class="line">  log (): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">  log () &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var jim = extend(new Person(&#x27;Jim&#x27;), new ConsoleLogger())</span><br><span class="line">var n = jim.name</span><br><span class="line">jim.log()</span><br><span class="line">interface DogInterface &#123;</span><br><span class="line">    run(): void</span><br><span class="line">&#125;</span><br><span class="line">interface CatInterface &#123;</span><br><span class="line">    jump(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pet 具备两个接口的所有方法</span><br><span class="line">let pet: DogInterface &amp; CatInterface = &#123;</span><br><span class="line">    run() &#123;&#125;,</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">let a: number | string = 1</span><br><span class="line">let b: &#x27;a&#x27; | &#x27;b&#x27; | &#x27;c&#x27; // 字面量联合类型</span><br><span class="line">let c: 1 | 2 | 3 // 数字联合类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog implements DogInterface &#123;</span><br><span class="line">    run() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Cat  implements CatInterface &#123;</span><br><span class="line">    jump() &#123;&#125;</span><br><span class="line">    eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">enum Master &#123; Boy, Girl &#125;</span><br><span class="line">function getPet(master: Master) &#123;</span><br><span class="line">    let pet = master === Master.Boy ? new Dog() : new Cat();</span><br><span class="line">    // pet.run()</span><br><span class="line">    // pet.jump()</span><br><span class="line">    pet.eat()</span><br><span class="line">    return pet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Square &#123;</span><br><span class="line">    kind: &quot;square&quot;;</span><br><span class="line">    size: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Rectangle &#123;</span><br><span class="line">    kind: &quot;rectangle&quot;;</span><br><span class="line">    width: number;</span><br><span class="line">    height: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">    kind: &quot;circle&quot;;</span><br><span class="line">    radius: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Shape = Square | Rectangle | Circle</span><br><span class="line"></span><br><span class="line">function area(s: Shape) &#123;</span><br><span class="line">    switch (s.kind) &#123;</span><br><span class="line">        case &quot;square&quot;:</span><br><span class="line">            return s.size * s.size;</span><br><span class="line">        case &quot;rectangle&quot;:</span><br><span class="line">            return s.height * s.width;</span><br><span class="line">        case &#x27;circle&#x27;:</span><br><span class="line">            return Math.PI * s.radius ** 2</span><br><span class="line">        default:</span><br><span class="line">            return ((e: never) =&gt; &#123;throw new Error(e)&#125;)(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(area(&#123;kind: &#x27;circle&#x27;, radius: 1&#125;))</span><br></pre></td></tr></table></figure><h3 id="15-2-索引类型"><a href="#15-2-索引类型" class="headerlink" title="15.2 索引类型"></a>15.2 索引类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// function getValues(obj: any, keys: string[]) &#123;</span><br><span class="line">//     return keys.map(key =&gt; obj[key])</span><br><span class="line">// &#125;</span><br><span class="line">function getValues&lt;T, K extends keyof T&gt;(obj: T, keys: K[]): T[K][] &#123;</span><br><span class="line">    return keys.map(key =&gt; obj[key])</span><br><span class="line">&#125;</span><br><span class="line">console.log(getValues(obj, [&#x27;a&#x27;, &#x27;b&#x27;]))</span><br><span class="line">// console.log(getValues(obj, [&#x27;d&#x27;, &#x27;e&#x27;]))</span><br><span class="line"></span><br><span class="line">// keyof T</span><br><span class="line">interface Obj &#123;</span><br><span class="line">    a: number;</span><br><span class="line">    b: string;</span><br><span class="line">&#125;</span><br><span class="line">let key: keyof Obj</span><br><span class="line"></span><br><span class="line">// T[K]</span><br><span class="line">let value: Obj[&#x27;a&#x27;]</span><br><span class="line"></span><br><span class="line">// T extends U</span><br></pre></td></tr></table></figure><h3 id="15-3-映射类型"><a href="#15-3-映射类型" class="headerlink" title="15.3 映射类型"></a>15.3 映射类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">interface Obj &#123;</span><br><span class="line">    a: string;</span><br><span class="line">    b: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使得每个成员属性变为只读</span><br><span class="line">type ReadonlyObj = Readonly&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 把一个接口属性变为可选</span><br><span class="line">type PartialObj = Partial&lt;Obj&gt;</span><br><span class="line"></span><br><span class="line">// 抽取obj的子集</span><br><span class="line">type PickObj = Pick&lt;Obj, &#x27;a&#x27; | &#x27;b&#x27;&gt;</span><br><span class="line"></span><br><span class="line">type RecordObj = Record&lt;&#x27;x&#x27; | &#x27;y&#x27;, Obj&gt;</span><br></pre></td></tr></table></figure><h3 id="15-4-条件类型"><a href="#15-4-条件类型" class="headerlink" title="15.4 条件类型"></a>15.4 条件类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// T extends U ? X : Y</span><br><span class="line"></span><br><span class="line">type TypeName&lt;T&gt; =</span><br><span class="line">    T extends string ? &quot;string&quot; :</span><br><span class="line">    T extends number ? &quot;number&quot; :</span><br><span class="line">    T extends boolean ? &quot;boolean&quot; :</span><br><span class="line">    T extends undefined ? &quot;undefined&quot; :</span><br><span class="line">    T extends Function ? &quot;function&quot; :</span><br><span class="line">    &quot;object&quot;;</span><br><span class="line">type T1 = TypeName&lt;string&gt;</span><br><span class="line">type T2 = TypeName&lt;string[]&gt;</span><br><span class="line"></span><br><span class="line">// (A | B) extends U ? X : Y</span><br><span class="line">// (A extends U ? X : Y) | (B extends U ? X : Y)</span><br><span class="line">type T3 = TypeName&lt;string | string[]&gt;</span><br><span class="line"></span><br><span class="line">type Diff&lt;T, U&gt; = T extends U ? never : T</span><br><span class="line">type T4 = Diff&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// Diff&lt;&quot;a&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;b&quot;, &quot;a&quot; | &quot;e&quot;&gt; | Diff&lt;&quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line">// never | &quot;b&quot; | &quot;c&quot;</span><br><span class="line">// &quot;b&quot; | &quot;c&quot;</span><br><span class="line"></span><br><span class="line">type NotNull&lt;T&gt; = Diff&lt;T, null | undefined&gt;</span><br><span class="line">type T5 = NotNull&lt;string | number | undefined | null&gt;</span><br><span class="line"></span><br><span class="line">// Exclude&lt;T, U&gt;</span><br><span class="line">// NonNullable&lt;T&gt;</span><br><span class="line"></span><br><span class="line">// Extract&lt;T, U&gt;</span><br><span class="line">type T6 = Extract&lt;&quot;a&quot; | &quot;b&quot; | &quot;c&quot;, &quot;a&quot; | &quot;e&quot;&gt;</span><br><span class="line"></span><br><span class="line">// ReturnType&lt;T&gt;</span><br><span class="line">type T8 = ReturnType&lt;() =&gt; string&gt;</span><br></pre></td></tr></table></figure><h3 id="15-5-联合类型"><a href="#15-5-联合类型" class="headerlink" title="15.5 联合类型"></a>15.5 联合类型</h3><blockquote><p>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 <code>number</code> 或 <code>string</code> 类型的参数。 例如下面的函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: any) &#123;</span><br><span class="line">  if (typeof padding === &#x27;number&#x27;) &#123;</span><br><span class="line">    return Array(padding + 1).join(&#x27; &#x27;) + value</span><br><span class="line">  &#125;</span><br><span class="line">  if (typeof padding === &#x27;string&#x27;) &#123;</span><br><span class="line">    return padding + value</span><br><span class="line">  &#125;</span><br><span class="line">  throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(&#x27;Hello world&#x27;, 4) // returns &quot;    Hello world&quot;</span><br></pre></td></tr></table></figure><blockquote><p>padLeft 存在一个问题，padding 参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number 也不是 string 类型的参数，但是 TypeScript 却不报错</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段通过，运行时报错</span><br></pre></td></tr></table></figure><blockquote><p>为了解决这个问题，我们可以使用 联合类型做为 <code>padding</code> 的参数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function padLeft(value: string, padding: string | number) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let indentedString = padLeft(&#x27;Hello world&#x27;, true) // 编译阶段报错</span><br></pre></td></tr></table></figure><ul><li>联合类型表示一个值可以是几种类型之一。我们用竖线（<code>|</code>）分隔每个类型，所以 <code>number | string</code> 表示一个值可以是 <code>number</code>或<code>string</code>。</li></ul><blockquote><p>如果一个值是联合类型，<strong>我们只能访问此联合类型的所有类型里共有的成员</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getSmallPet(): Fish | Bird &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let pet = getSmallPet()</span><br><span class="line">pet.layEggs() // okay</span><br><span class="line">pet.swim()    // error</span><br></pre></td></tr></table></figure><blockquote><p>这里的联合类型可能有点复杂：如果一个值的类型是 <code>A | B</code>，我们能够确定的是它包含了 <code>A</code> 和 <code>B</code> 中共有的成员。这个例子里，Fish 具有一个 <code>swim</code> 方法，我们不能确定一个 <code>Bird | Fish</code>类型的变量是否有 <code>swim</code>方法。 如果变量在运行时是 Bird 类型，那么调用 <code>pet.swim()</code>就出错了</p></blockquote><h2 id="十六、初学者的困惑"><a href="#十六、初学者的困惑" class="headerlink" title="十六、初学者的困惑"></a>十六、初学者的困惑</h2><h3 id="16-1-如何优雅的声明类型"><a href="#16-1-如何优雅的声明类型" class="headerlink" title="16.1 如何优雅的声明类型"></a>16.1 如何优雅的声明类型</h3><h4 id="16-1-1-基础"><a href="#16-1-1-基础" class="headerlink" title="16.1.1 基础"></a>16.1.1 基础</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Basic &#123;</span><br><span class="line">  num: number;</span><br><span class="line">  str: string | null;</span><br><span class="line">  bol?: boolean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>五种 JS 值类型就声明好了。那数组、函数呢？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Func &#123;</span><br><span class="line">  func(str: string): void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Arr &#123;</span><br><span class="line">  str: string[];</span><br><span class="line">  mixed: Array&lt;string | number&gt;;</span><br><span class="line">  fixedStructure: [string, number];</span><br><span class="line">  basics: Basic[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>枚举类型也是很常用的，比如声明一个状态机的各个状态</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Draft,</span><br><span class="line">  Published</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 也可指定值</span><br><span class="line">enum Status &#123;</span><br><span class="line">  Draft = &#x27;Draft&#x27;,</span><br><span class="line">  Published = &#x27;Published&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-1-2-糅合"><a href="#16-1-2-糅合" class="headerlink" title="16.1.2 糅合"></a>16.1.2 糅合</h4><p><strong>独立声明</strong></p><blockquote><p>一个 <code>ts</code> 文件只声明一个类型或者接口，文件名为需要暴露的类型名称，方便检索和管理</p></blockquote><p><strong>就近声明</strong></p><blockquote><p>当一个声明没有被外部引用或者依赖时，可以考虑就近放在使用的地方，典型的场景是 <code>React</code> 组件的 <code>Props</code> 和 <code>State</code> 的类型声明</p></blockquote><p><strong>按职责分组</strong></p><ul><li>在项目中，需要声明类型的可大致分为两类：一类是 <code>model</code>，也就是接口请求相关的，包括入参和出参；另一类是 <code>view</code>，界面渲染相关的。因此，我在 独立声明 的基础上，可以类型按照<code>model</code> 和 <code>view</code> 的维度进行分组，相互独立。</li><li>那么问题来了，如果是独立的类型声明的话，怎么把 model 的数据应用到 <code>view</code> 呢？ 可能你需要一个 <code>adapter</code> 来做类型的的转换：<code>DTOTypes</code> -&gt; <code>adapter</code> -&gt; <code>ViewTypes</code>, 完成类似于将接口中的字符串映射成枚举类型这之类的转换</li></ul><p><strong>any</strong></p><blockquote><p>当遇到确实解决不了的类型报错的时候，<code>as any</code> 能带给你不一样的快感，但是不建议使用啊</p></blockquote><h3 id="16-2-如何引用外部库"><a href="#16-2-如何引用外部库" class="headerlink" title="16.2 如何引用外部库"></a>16.2 如何引用外部库</h3><blockquote><p>在 <code>JS</code> 中，<code>npm</code> 上有丰富的海量的库帮我们完成日常的编码，可能并不是所有的库都能完全被应用到 <code>TS</code> 中，因为有些缺少类型声明</p></blockquote><p>比如，在 <code>TS</code> 中使用 <code>react</code>, 你会得到这样的一个类型检查错误：</p><p><img src="https://pic2.zhimg.com/80/v2-fdfb8e5f2be67d8c978e216254b80a9d_hd.jpg" alt="img"></p><ul><li>因为 react 的库中并没有类型声明</li><li>现在比较通用的做法是，实现和类型实现独立成两个库，也就是你需要再安装类型声明的库: <code>@types/react</code></li><li>当遇到上述问题的时候，尝试安装一下 <code>@types/[package]</code></li><li>然而，并不是所有的库都有类型声明的实现，也会有很多不支持 TS 的存在，然而又必须得使用这个库的时候该怎么办？</li></ul><p><strong>自己写声明</strong></p><blockquote><p>以 <code>progressbar.js</code>为例，基本使用方法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import * as ProgressBar from &#x27;progressbar.js&#x27;;</span><br><span class="line"></span><br><span class="line">new ProgressBar.Circle(this.$progress, &#123;</span><br><span class="line">  strokeWidth: 8,</span><br><span class="line">  trailColor: &#x27;#e5e4e5&#x27;,</span><br><span class="line">  trailWidth: 8,</span><br><span class="line">  easing: &#x27;easeInOut&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们需要对库中暴露出的 api 去做声明，对上述例子做个分解：暴露了 Circle 类，Circle 构造函数包含两个参数，一个 HTMLElement，一个 options. OK</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 首先声明一下模块：</span><br><span class="line">declare module &#x27;progressbar.js&#x27; &#123;</span><br><span class="line">  // 模块中暴露了 Circle 类</span><br><span class="line">  export class Circle &#123;</span><br><span class="line">    constructor(container: HTMLElement, options: Options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 构造函数的 Options 需要单独声明 </span><br><span class="line">  interface Options &#123;</span><br><span class="line">    easing?: string;</span><br><span class="line">    strokeWidth?: number;</span><br><span class="line">    trailColor?: string;</span><br><span class="line">    trailWidth?: number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如此我们便完成了一个简单的声明，当然实际使用中的 API 肯定比上述情况复杂，根据使用情况，用了哪些 API 或者参数，就补充那些的声明即可</p></blockquote><h3 id="16-3-如何组织一个-TS-项目"><a href="#16-3-如何组织一个-TS-项目" class="headerlink" title="16.3 如何组织一个 TS 项目"></a>16.3 如何组织一个 TS 项目</h3><ul><li>TS 项目的目录组织上，跟 JS 项目一样，补充好 types 的声明就可以了</li><li>需要注意的是，将你希望对外暴露的能力相关的类型声明都暴露出去，不友好的声明会让接入你项目的人非常的痛苦，同时，在 package.json 中需要指定 type 的 path, 比如：”types”: “dist&#x2F;types&#x2F;index.d.ts”</li><li>另外，务必加上 tslint, 更规范的去用 TS 实现功能，对于入门而言尤为重要</li></ul><h3 id="16-4-TSX-和-JSX"><a href="#16-4-TSX-和-JSX" class="headerlink" title="16.4 TSX 和 JSX"></a>16.4 TSX 和 JSX</h3><ul><li>之前我们在用 <code>JavaScript</code> 写 <code>React</code> 时，对文件的扩展名没有什么特别的要求，<code>.js</code> 或者 <code>.jsx</code> 都行。</li><li>但在 <code>TypeScript</code> 中，如果你要使用 <code>JSX</code> 语法，就不能使用 <code>.ts</code>，必须使用 <code>.tsx</code>。如果你不知道，或者忘了这么做，那么你会在使用了 <code>JSX</code> 代码的地方收到类型报错，但代码本身怎么看都没有问题。这也是刚上手 <code>TypeScript + React</code> 时几乎每个人都会遇到的坑。</li><li>关于这一点，<code>TypeScript</code> 只是在官方教程的示例代码中直接用了 <code>*.tsx</code>，但并没有明确说明这一问题</li></ul><h3 id="16-5-变量的-Type-怎么找"><a href="#16-5-变量的-Type-怎么找" class="headerlink" title="16.5 变量的 Type 怎么找"></a>16.5 变量的 Type 怎么找</h3><ul><li>上手 <code>TypeScript</code> 之后很快我们就发现，即便是原生的 <code>DOM</code>、或是 <code>React</code> 的 <code>API</code>，也经常会要我们手动指定类型。但这些结构并不是简单的 <code>JavaScript</code>原始类型，在使用 <code>JavaScript</code> 编写相关代码时候由于没有这种需要，我们也没关心过这些东西的类型，突然问起来，还真不知道这些类型叫什么名字。</li><li>不光是这些标准类型，同样的问题在很多第三方的库中也会遇到，比如一些组件库会检查你传入的 <code>Props</code></li><li>在我看来，这中间其实缺少了一部分的文档，来指导新用户如何找到所需要的类型。既然社区没有提供，那就我来吧。</li><li>当然，让每个开发者都熟记所有的类型肯定是不现实的，总不能每接触一个新的库，就要去记一堆类型吧。放心，世界还是美好的，这种事情，当然是有方法的。</li><li>最直白的方法就是去看库的 <code>Types Definition</code>，也就是那些 <code>.*d.ts</code> 文件。如果你刚好有在用 <code>VS Code</code> 的话，有一个非常方便的操作：把鼠标移动到你想知道它类型的代码上（比如某个变量、某个函数调用，或是某个 JSX 标签、某个组件的 props），右键选择「Go to Definition」（或者光标选中后按 F12），就可以跳转到它的类型定义文件了。</li><li>如果你更习惯使用 VS Code 之外的编辑器，我相信时至今日，它们应该也都早就对 <code>TypeScript</code> 提供了支持。具体操作我不太熟悉，你可以自己探索下（我一直用 VS Code，其它的不太熟）</li><li>一般来说，这个操作可以直接把你带到你想要的地方，但考虑到类型是可以继承的，有时候一次跳转可能不太够，遇到这种情况，那就需要你随机应变一下，沿着继承关系多跳几次，直到找到你想要的内容。</li><li>对于不熟悉的类型，可以通过这个方法去寻找，慢慢熟悉以后，你会发现，一些常见的类型还是很好找的，稍微联想一下英文的表达方式，配合自动补全的提示，一般都不难找到</li></ul><h3 id="16-6-常见-Types-之-DOM"><a href="#16-6-常见-Types-之-DOM" class="headerlink" title="16.6 常见 Types 之 DOM"></a>16.6 常见 Types 之 DOM</h3><ul><li><code>TypeScript</code> 自带了一些基本的类型定义，包括 ECMAScript 和 DOM 的类型定义，所有你需要的类型都可以从这里找到。如果你想做一些「纯 TypeScript 开发」的话，有这些就够了</li><li>比如下面这张截图，就是对 &#96;&#96; 标签的类型定义。我们可以看到，它继承了更加通用的 <code>HTMLElement</code> 类型，并且扩展了一个即将被废弃的 <code>align</code> 属性，以及两组 <code>addEventListener</code> 和 <code>removeEventListener</code>，注意这里使用了重载。</li></ul><p><img src="https://poetries1.gitee.io/img-repo/20190903/3.png" alt="img"></p><blockquote><p>这里的命名也不是随便起的，都是在 MDN 上可以查到的。还是以 &#96;&#96; 为例，我们已经知道它继承自 <code>HTMLElement</code>，其实再往上，<code>HTMLElement</code> 继承自 <code>Element</code>，<code>Element</code> 又继承自 <code>Node</code>，顺着这条路，你可以挖掘出所有 <code>HTML</code> 标签的类型</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/4.png" alt="img"></p><blockquote><p>对于一些 DOM 相关的属性，比如 <code>onclick</code>、<code>onchange</code> 等，你都可以如法炮制，找到它们的定义。</p></blockquote><h3 id="16-7-常见-Types-之-React"><a href="#16-7-常见-Types-之-React" class="headerlink" title="16.7 常见 Types 之 React"></a>16.7 常见 Types 之 React</h3><ul><li>关于 TypeScript 的问题，有不少其实是在使用第三方库的时候遇到的，React 就是其中比较典型的一个</li><li>其实方法都一样，只不过相关的类型定义不在 <code>TypeScript</code> 中，而是在 <code>@types/react</code> 中。</li><li><code>React</code> 的类型定义的名称其实也很直观，比如我们常见的 <code>React.Component</code>，在定义 <code>Class</code> 组件时，我们需要对 <code>Props</code> 和 <code>State</code> 预先进行类型定义，为什么呢？答案就在它的类型定义中</li></ul><p><img src="https://poetries1.gitee.io/img-repo/20190903/5.png" alt="img"></p><ul><li>再比如，当我们在写一些组件时，我们可能会需要向下传递 <code>this.props.children</code>，但 <code>children</code> 并没有被设为默认值，需要我们自己定义到 <code>props</code> 上，那么它的类型应该是什么呢</li><li>到类型定义中搜一下关键字 <code>children</code>，很快我们就找到了下面的定义</li></ul><p><img src="https://poetries1.gitee.io/img-repo/20190903/6.png" alt="img"></p><blockquote><p>所有 <code>React</code> 中 <code>JSX</code> 所代表的内容，无论是 <code>render()</code> 的返回，还是 <code>children</code>，我们都可以定义为一个 <code>ReactNode</code>。那这个 <code>ReactNode</code> 长什么样呢？我们通过右键继续寻找</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/7.png" alt="img"></p><blockquote><p>看到这里，我们不光找到了我们想要的类型，还顺带明白了为什么 <code>render()</code> 可以返回 <code>boolean</code>、<code>null</code>、<code>undefined</code> 表示不渲染任何内容。<br>那么事件呢？当我们给组件定义事件处理函数的时候，也经常会被要求指定类型。还是老办法，找不到咱就搜，比如 <code>onClick</code> 不清楚，那我们就以它为关键字去搜</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/8.png" alt="img"></p><blockquote><p>据此我们找到一个叫 <code>MouseEventHandler</code> 的定义，这名字，够直白吧。好了，我们找到想要的了。不过既然来了，不如继续看一下，看看还能发现什么。我们右键 <code>MouseEventHandler</code> 急需往下看：</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/9.png" alt="img"></p><blockquote><p>看到了吗，所有的事件处理函数都有对应的定义，每个都需要一个泛型参数，传递了事件的类型，名称也挺直白的</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/20190903/10.png" alt="img"></p><blockquote><p>事件的类型也被我们挖出来了，以后如果需要单独定义一个事件相关的类型，就可以直接用了。以此类推，不管是什么东西的类型，都可以去它们对应的 <code>@types/xxx</code>里，按关键字搜</p></blockquote><h3 id="16-8-多重-extends"><a href="#16-8-多重-extends" class="headerlink" title="16.8 多重 extends"></a>16.8 多重 extends</h3><ul><li>我们知道 <code>Interface</code> 是可以多继承的，<code>extends</code> 后面可以跟多个其它 <code>Interface</code>，我们不能保证被继承的多个 <code>Interface</code> 一定没有重复的属性，那么当属性重复，但类型定义不同时，最终的结果会怎么样呢？</li><li>在 <code>TypeScript</code> 中，<code>Interface</code> 会按照从右往左的顺序去合并多个被继承的 <code>Interface</code>，也就是说，同名属性，左边的会覆盖右边的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface A &#123;</span><br><span class="line">  value?: string</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">  value: string</span><br><span class="line">&#125;</span><br><span class="line">interface C &#123;</span><br><span class="line">  value: number</span><br><span class="line">&#125;</span><br><span class="line">interface D extends A, B &#123;&#125;// value?: string</span><br><span class="line">interface E extends B, C &#123;&#125;// value: string</span><br></pre></td></tr></table></figure><h3 id="16-9-obj-prop-无法访问怎么办"><a href="#16-9-obj-prop-无法访问怎么办" class="headerlink" title="16.9 obj[prop] 无法访问怎么办"></a>16.9 obj[prop] 无法访问怎么办</h3><ul><li>有时候我们会定义一些集合型的数据，例如对象、枚举等，但在调用的时候，我们未必会直接通过 <code>obj.prop</code> 的形式去调用，可能会是以 <code>obj[prop]</code> 这种动态索引的形式去访问，但通过动态索引的方式就无法确定最终访问的元素是否存在，因此在 <code>TypeScript</code> 中，默认是不允许这种操作的</li><li>但这又是个非常合理，而且非常常见的场景，怎么办呢？<code>TypeScript</code> 允许为类型添加索引，以实现这一点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Foo &#123;</span><br><span class="line">  x: string,</span><br><span class="line">  y: number</span><br><span class="line">  [index: string]: string | number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个方法虽然有效，但每次都要手动为类型加索引，重复多了也挺心累的。包括在一些「配置对象」中，我们甚至无法确定有哪些类型，有没有一种更加通用、更加一劳永逸的方法。</li><li>其实在 <code>TypeScript</code>的官方文档中就有提到这个方案，官方管它叫 <code>OptionBag</code>，大概就是指 <code>config</code>、o<code>ption</code> 等用于提供配置信息的这么一类参数。我不是很确定这到底是个常规的英文单词，还是 <code>TypeScript</code> 中特定的术语（个人感觉是前者），反正就这么个意思吧。<br>简单说来，我们可以定义下面这样一个类型：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface OptionBag &#123;</span><br><span class="line">  [index: string]: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这是一个非常通用的结构，以字符串为键，值可以是任何类型，并且支持索引 —— 这不就是 <code>Object</code> 么。</li><li>之后所有需要动态索引的结构，或是作为配置对象的结构，都可以直接指定为，或是继承 <code>OptionBag</code>。这个方案以牺牲一定的类型检查为代价，换取了操作上的便利。</li><li>理论上讲，<code>OptionBag</code> 可以适用于所有类似对象这样的结构，但不建议各位真就这么做。这个方案只能是用在一些对类型要求不那么严格，或是无法预知类型的场景中，能够确定的类型还是尽可能地写一下，否则就失去了使用 <code>TypeScript</code> 意义了</li></ul><h2 id="十七、其他技巧"><a href="#十七、其他技巧" class="headerlink" title="十七、其他技巧"></a>十七、其他技巧</h2><p><strong>1. 安全导航操作符 ( ?. )和非空断言操作符（!.）</strong></p><ul><li><strong>安全导航操作符 ( ?. ) 和空属性路径</strong>：</li></ul><blockquote><p>为了解决导航时变量值为null时，页面运行时出错的问题</p></blockquote><ul><li><strong>非空断言操作符</strong></li></ul><blockquote><p>能确定变量值一定不为空时使用。与安全导航操作符不同的是，非空断言操作符不会防止出现 <code>null</code> 或 <code>undefined</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let s = e!.name; // 断言e是非空并访问name属性</span><br></pre></td></tr></table></figure><h1 id="第二章-工程篇"><a href="#第二章-工程篇" class="headerlink" title="第二章 工程篇"></a>第二章 工程篇</h1><p><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-1.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-2.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-3.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-4.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-5.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-6.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-7.webp" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/gongcheng-8.webp" alt="img"></p><h2 id="一、使用命名空间"><a href="#一、使用命名空间" class="headerlink" title="一、使用命名空间"></a>一、使用命名空间</h2><blockquote><p>不要在一个模块中使用命名空间，最好在一个全局中使用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// a.ts</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    const pi = Math.PI</span><br><span class="line">    export function cricle(r: number) &#123;</span><br><span class="line">        return pi * r ** 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// b.ts</span><br><span class="line"></span><br><span class="line">// 三斜线引用a</span><br><span class="line">/// &lt;reference path=&quot;a.ts&quot; /&gt;</span><br><span class="line">namespace Shape &#123;</span><br><span class="line">    export function square(x: number) &#123;</span><br><span class="line">        return x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Shape.cricle(2))</span><br><span class="line">console.log(Shape.square(2))</span><br><span class="line"></span><br><span class="line">// 更方便使用 不是es6中的import</span><br><span class="line">import cricle = Shape.cricle</span><br><span class="line">console.log(cricle(2))</span><br></pre></td></tr></table></figure><h2 id="二、理解联合声明"><a href="#二、理解联合声明" class="headerlink" title="二、理解联合声明"></a>二、理解联合声明</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 接口声明合并</span><br><span class="line">interface A &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    // y: string;</span><br><span class="line">    foo(bar: number): number; // 5</span><br><span class="line">    foo(bar: &#x27;a&#x27;): string; // 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface A &#123;</span><br><span class="line">    y: number;</span><br><span class="line">    foo(bar: string): string; // 3</span><br><span class="line">    foo(bar: string[]): string[]; // 4</span><br><span class="line">    foo(bar: &#x27;b&#x27;): string; // 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a: A = &#123;</span><br><span class="line">    x: 1,</span><br><span class="line">    y: 2,</span><br><span class="line">    foo(bar: any) &#123;</span><br><span class="line">        return bar</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 命名空间和类声明合并--命名空间需要放到后面</span><br><span class="line">class C &#123;&#125;</span><br><span class="line">namespace C &#123;</span><br><span class="line">    export let state = 1</span><br><span class="line">&#125;</span><br><span class="line">console.log(C.state)</span><br><span class="line"></span><br><span class="line">// 命名空间和函数声明合并--命名空间需要放到后面</span><br><span class="line">function Lib() &#123;&#125;</span><br><span class="line">namespace Lib &#123;</span><br><span class="line">    export let version = &#x27;1.0&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Lib.version)</span><br><span class="line"></span><br><span class="line">// 命名空间和枚举声明合并--位置没有要求</span><br><span class="line">enum Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Yellow,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line">namespace Color &#123;</span><br><span class="line">    export function mix() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Color)</span><br></pre></td></tr></table></figure><h2 id="三、如何编写声明文件–引入类库"><a href="#三、如何编写声明文件–引入类库" class="headerlink" title="三、如何编写声明文件–引入类库"></a>三、如何编写声明文件–引入类库</h2><blockquote><p>类库分为三类：全局类库、模块类库、<code>UMD</code>类库</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">declare var // 声明全局变量</span><br><span class="line">declare function // 声明全局方法</span><br><span class="line">declare class // 声明全局类</span><br><span class="line">declare enum // 声明全局枚举类型</span><br><span class="line">declare global // 扩展全局变量</span><br><span class="line">declare module // 扩展模块</span><br></pre></td></tr></table></figure><blockquote><p>大多数的声明文件社区已经帮我们安装好了，使用<code>@types/包名</code>声明文件即可</p></blockquote><blockquote><p>Typescript声明文件查找 <a href="https://microsoft.github.io/TypeSearch/">https://microsoft.github.io/TypeSearch/</a></p></blockquote><p><strong>以jquery为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/jquery</span><br></pre></td></tr></table></figure><p><strong>引入了一个JS类库，但是社区又没有提供类型声明文件，我该如何去编写它的类型声明文件</strong></p><blockquote><p>先确定这个库的类型，全局库、模块库、还是UMD库，然后参照下面介绍的方法，把它的<code>API</code>声明逐步添加进来（暂时用不到的<code>API</code>也可以不写）</p></blockquote><h3 id="3-1-三种类库声明文件写法"><a href="#3-1-三种类库声明文件写法" class="headerlink" title="3.1 三种类库声明文件写法"></a>3.1 三种类库声明文件写法</h3><h4 id="3-1-1-全局库"><a href="#3-1-1-全局库" class="headerlink" title="3.1.1 全局库"></a>3.1.1 全局库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// global-lib.d.ts</span><br><span class="line">    </span><br><span class="line">declare function globalLib(options: globalLib.Options): void;</span><br><span class="line">// 函数和命名空间的声明合并 为这个函数提供了一些属性</span><br><span class="line">declare namespace globalLib &#123;</span><br><span class="line">    const version: string;</span><br><span class="line">    function doSomething(): void;</span><br><span class="line">    interface Options &#123;</span><br><span class="line">        [key: string]: any</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// global-lib.js</span><br><span class="line">// 和声明文件对应</span><br><span class="line">function globalLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">globalLib.version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">globalLib.doSomething = function() &#123;</span><br><span class="line">    console.log(&#x27;globalLib do something&#x27;);</span><br><span class="line">&#125;;</span><br><span class="line">// 全局使用 index.ts</span><br><span class="line">globalLib(&#123;x:1&#125;)</span><br><span class="line">globalLib.doSomething()</span><br></pre></td></tr></table></figure><h4 id="3-1-2-模块类库"><a href="#3-1-2-模块类库" class="headerlink" title="3.1.2 模块类库"></a>3.1.2 模块类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// module-lib.d.ts</span><br><span class="line">declare function moduleLib(options: Options): void</span><br><span class="line"></span><br><span class="line">interface Options &#123;</span><br><span class="line">    [key: string]: any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare namespace moduleLib &#123;</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export = moduleLib</span><br><span class="line">// module-lib.js</span><br><span class="line">const version = &#x27;1.0.0&#x27;;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">    console.log(&#x27;moduleLib do something&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function moduleLib(options) &#123;</span><br><span class="line">    console.log(options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">moduleLib.version = version;</span><br><span class="line">moduleLib.doSomething = doSomething;</span><br><span class="line"></span><br><span class="line">module.exports = moduleLib;</span><br><span class="line">// index.ts 使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line"></span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure><h4 id="3-1-3-UMD类库"><a href="#3-1-3-UMD类库" class="headerlink" title="3.1.3 UMD类库"></a>3.1.3 UMD类库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// umd-lib.d.ts</span><br><span class="line"></span><br><span class="line">declare namespace umdLib &#123;</span><br><span class="line">    // 省略了export</span><br><span class="line">    const version: string</span><br><span class="line">    function doSomething(): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UMD库不可缺少的语句</span><br><span class="line">export as namespace umdLib</span><br><span class="line"></span><br><span class="line">export = umdLib</span><br><span class="line">// umd-lib.js</span><br><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &quot;function&quot; &amp;&amp; define.amd) &#123;</span><br><span class="line">        define(factory);</span><br><span class="line">    &#125; else if (typeof module === &quot;object&quot; &amp;&amp; module.exports) &#123;</span><br><span class="line">        module.exports = factory();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        root.umdLib = factory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(this, function() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        // 需要为这两个成员编写声明文件</span><br><span class="line">        version: &#x27;1.0.0&#x27;,</span><br><span class="line">        doSomething() &#123;</span><br><span class="line">            console.log(&#x27;umdLib do something&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br><span class="line">// index.ts使用</span><br><span class="line">import umdLib from &#x27;./umd-lib&#x27;</span><br><span class="line">// 可以不用导入umd-lib模块。但是需要打开tsconfig.tson中的umd配置</span><br><span class="line">umdLib.doSomething()</span><br></pre></td></tr></table></figure><h3 id="3-2-两种插件声明文件写法"><a href="#3-2-两种插件声明文件写法" class="headerlink" title="3.2 两种插件声明文件写法"></a>3.2 两种插件声明文件写法</h3><h4 id="3-2-1-模块化插件declare-module"><a href="#3-2-1-模块化插件declare-module" class="headerlink" title="3.2.1 模块化插件declare module"></a>3.2.1 模块化插件declare module</h4><blockquote><p><code>declare module</code> 可以给类库添加一些自定义方法。 扩展模块</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 模块插件</span><br><span class="line">import m from &#x27;moment&#x27;;</span><br><span class="line">declare module &#x27;moment&#x27; &#123;</span><br><span class="line">    // 给moment自定义一些方法</span><br><span class="line">    export function myFunction(): void;</span><br><span class="line">&#125;</span><br><span class="line">m.myFunction = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-全局插件declare-global"><a href="#3-2-2-全局插件declare-global" class="headerlink" title="3.2.2 全局插件declare global"></a>3.2.2 全局插件declare global</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全局插件</span><br><span class="line">declare global &#123;</span><br><span class="line">    namespace globalLib &#123;</span><br><span class="line">        function doAnyting(): void</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 在全局变量添加方法</span><br><span class="line">// 会对全局变量造成污染 一般不这么做</span><br><span class="line">globalLib.doAnyting = () =&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-jquery声明文件示例"><a href="#3-3-jquery声明文件示例" class="headerlink" title="3.3 jquery声明文件示例"></a>3.3 jquery声明文件示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// index.d.ts入口</span><br><span class="line"></span><br><span class="line">// Type definitions for jquery 3.3</span><br><span class="line">// Project: https://jquery.com</span><br><span class="line">// Definitions by: Leonard Thieu &lt;https://github.com/leonard-thieu&gt;</span><br><span class="line">//                 Boris Yankov &lt;https://github.com/borisyankov&gt;</span><br><span class="line">//                 Christian Hoffmeister &lt;https://github.com/choffmeister&gt;</span><br><span class="line">//                 Steve Fenton &lt;https://github.com/Steve-Fenton&gt;</span><br><span class="line">//                 Diullei Gomes &lt;https://github.com/Diullei&gt;</span><br><span class="line">//                 Tass Iliopoulos &lt;https://github.com/tasoili&gt;</span><br><span class="line">//                 Jason Swearingen &lt;https://github.com/jasons-novaleaf&gt;</span><br><span class="line">//                 Sean Hill &lt;https://github.com/seanski&gt;</span><br><span class="line">//                 Guus Goossens &lt;https://github.com/Guuz&gt;</span><br><span class="line">//                 Kelly Summerlin &lt;https://github.com/ksummerlin&gt;</span><br><span class="line">//                 Basarat Ali Syed &lt;https://github.com/basarat&gt;</span><br><span class="line">//                 Nicholas Wolverson &lt;https://github.com/nwolverson&gt;</span><br><span class="line">//                 Derek Cicerone &lt;https://github.com/derekcicerone&gt;</span><br><span class="line">//                 Andrew Gaspar &lt;https://github.com/AndrewGaspar&gt;</span><br><span class="line">//                 Seikichi Kondo &lt;https://github.com/seikichi&gt;</span><br><span class="line">//                 Benjamin Jackman &lt;https://github.com/benjaminjackman&gt;</span><br><span class="line">//                 Poul Sorensen &lt;https://github.com/s093294&gt;</span><br><span class="line">//                 Josh Strobl &lt;https://github.com/JoshStrobl&gt;</span><br><span class="line">//                 John Reilly &lt;https://github.com/johnnyreilly&gt;</span><br><span class="line">//                 Dick van den Brink &lt;https://github.com/DickvdBrink&gt;</span><br><span class="line">//                 Thomas Schulz &lt;https://github.com/King2500&gt;</span><br><span class="line">//                 Terry Mun &lt;https://github.com/terrymun&gt;</span><br><span class="line">// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped</span><br><span class="line">// TypeScript Version: 2.3</span><br><span class="line"></span><br><span class="line">// 三斜线引入模块</span><br><span class="line"></span><br><span class="line">/// &lt;reference types=&quot;sizzle&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQueryStatic.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;JQuery.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;misc.d.ts&quot; /&gt;</span><br><span class="line">/// &lt;reference path=&quot;legacy.d.ts&quot; /&gt;</span><br><span class="line"></span><br><span class="line">export = jQuery;</span><br></pre></td></tr></table></figure><h2 id="四、配置tsconfig-json"><a href="#四、配置tsconfig-json" class="headerlink" title="四、配置tsconfig.json"></a>四、配置tsconfig.json</h2><h3 id="4-1-基础配置"><a href="#4-1-基础配置" class="headerlink" title="4.1 基础配置"></a>4.1 基础配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ===与文件相关的选项===</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">  </span><br><span class="line">  // ====与编译相关的选项====</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">      // &quot;incremental&quot;: true,                // 增量编译，再次编译会增量编译</span><br><span class="line">      // &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;,   // 增量编译文件的存储位置</span><br><span class="line">      // &quot;diagnostics&quot;: true,                // 打印诊断信息</span><br><span class="line"></span><br><span class="line">      // &quot;target&quot;: &quot;es5&quot;,           // 目标语言的版本</span><br><span class="line">      // &quot;module&quot;: &quot;commonjs&quot;,      // 生成代码的模块标准</span><br><span class="line">      // &quot;outFile&quot;: &quot;./app.js&quot;,     // 将多个相互依赖的文件生成一个文件，可以用在 AMD 模块中</span><br><span class="line">        </span><br><span class="line">       // 比如你需要使用es2019方法 需要在这里导入模块 &quot;lib&quot;: [&#x27;es2019.arrary&#x27;]</span><br><span class="line">      // &quot;lib&quot;: [],                 // TS 需要引用的库，即声明文件，es5 默认 &quot;dom&quot;, &quot;es5&quot;, &quot;scripthost&quot;</span><br><span class="line"></span><br><span class="line">      // &quot;allowJs&quot;: true,           // 允许编译 JS 文件（js、jsx）</span><br><span class="line">      // &quot;checkJs&quot;: true,           // 允许在 JS 文件中报错，通常与 allowJS 一起使用</span><br><span class="line">      // &quot;outDir&quot;: &quot;./out&quot;,         // 指定输出目录</span><br><span class="line">      // &quot;rootDir&quot;: &quot;./&quot;,           // 指定输入文件目录（用于输出）</span><br><span class="line"></span><br><span class="line">      // &quot;declaration&quot;: true,         // 生成声明文件</span><br><span class="line">      // &quot;declarationDir&quot;: &quot;./d&quot;,     // 声明文件的路径</span><br><span class="line">      // &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件</span><br><span class="line">      // &quot;sourceMap&quot;: true,           // 生成目标文件的 sourceMap</span><br><span class="line">      // &quot;inlineSourceMap&quot;: true,     // 生成目标文件的 inline sourceMap</span><br><span class="line">      // &quot;declarationMap&quot;: true,      // 生成声明文件的 sourceMap</span><br><span class="line">      // &quot;typeRoots&quot;: [],             // 声明文件目录，默认 node_modules/@types</span><br><span class="line">      // &quot;types&quot;: [],                 // 声明文件包</span><br><span class="line"></span><br><span class="line">      // &quot;removeComments&quot;: true,    // 删除注释</span><br><span class="line"></span><br><span class="line">      // &quot;noEmit&quot;: true,            // 不输出文件</span><br><span class="line">      // &quot;noEmitOnError&quot;: true,     // 发生错误时不输出文件</span><br><span class="line"></span><br><span class="line">      // &quot;noEmitHelpers&quot;: true,     // 不生成 helper 函数，需额外安装 ts-helpers</span><br><span class="line">      // &quot;importHelpers&quot;: true,     // 通过 tslib 引入 helper 函数，文件必须是模块</span><br><span class="line"></span><br><span class="line">      // &quot;downlevelIteration&quot;: true,    // 降级遍历器的实现（es3/5）</span><br><span class="line"></span><br><span class="line">      // &quot;strict&quot;: true,                        // 开启所有严格的类型检查</span><br><span class="line">      // &quot;alwaysStrict&quot;: false,                 // 在代码中注入 &quot;use strict&quot;;</span><br><span class="line">      // &quot;noImplicitAny&quot;: false,                // 不允许隐式的 any 类型</span><br><span class="line">      // &quot;strictNullChecks&quot;: false,             // 不允许把 null、undefined 赋值给其他类型变量</span><br><span class="line">      // &quot;strictFunctionTypes&quot;: false           // 不允许函数参数双向协变</span><br><span class="line">      // &quot;strictPropertyInitialization&quot;: false, // 类的实例属性必须初始化</span><br><span class="line">      // &quot;strictBindCallApply&quot;: false,          // 严格的 bind/call/apply 检查</span><br><span class="line">      // &quot;noImplicitThis&quot;: false,               // 不允许 this 有隐式的 any 类型</span><br><span class="line"></span><br><span class="line">      // &quot;noUnusedLocals&quot;: true,                // 检查只声明，未使用的局部变量</span><br><span class="line">      // &quot;noUnusedParameters&quot;: true,            // 检查未使用的函数参数</span><br><span class="line">      // &quot;noFallthroughCasesInSwitch&quot;: true,    // 防止 switch 语句贯穿</span><br><span class="line">      // &quot;noImplicitReturns&quot;: true,             // 每个分支都要有返回值</span><br><span class="line"></span><br><span class="line">      // &quot;esModuleInterop&quot;: true,               // 允许 export = 导出，由import from 导入</span><br><span class="line">      // &quot;allowUmdGlobalAccess&quot;: true,          // 允许在模块中访问 UMD 全局变量</span><br><span class="line">      // &quot;moduleResolution&quot;: &quot;node&quot;,            // 模块解析策略</span><br><span class="line">      // &quot;baseUrl&quot;: &quot;./&quot;,                       // 解析非相对模块的基地址</span><br><span class="line">      // &quot;paths&quot;: &#123;                             // 路径映射，相对于 baseUrl</span><br><span class="line">      //   &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;]</span><br><span class="line">      // &#125;,</span><br><span class="line">      // &quot;rootDirs&quot;: [&quot;src&quot;, &quot;out&quot;],            // 将多个目录放在一个虚拟目录下，用于运行时</span><br><span class="line"></span><br><span class="line">      // &quot;listEmittedFiles&quot;: true,        // 打印输出的文件</span><br><span class="line">      // &quot;listFiles&quot;: true,               // 打印编译的文件（包括引用的声明文件）</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>也可以把公共的抽离出来</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// tsconfig.base.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;files&quot; : [&#x27;src/index.ts&#x27;], // 编译的文件列表</span><br><span class="line">  &quot;include&quot;: [&#x27;src&#x27;], // 指定编译文件</span><br><span class="line">  &quot;exclude&quot;: [&#x27;src/lib&#x27;], // 排除编译文件</span><br><span class="line">&#125;</span><br><span class="line">&quot;extends&quot;: &#x27;./tsconfig.base&#x27;,</span><br><span class="line">&quot;exclude&quot;: [] // 覆盖之前的</span><br></pre></td></tr></table></figure><h3 id="4-2-工程引用配置多个项目"><a href="#4-2-工程引用配置多个项目" class="headerlink" title="4.2 工程引用配置多个项目"></a>4.2 工程引用配置多个项目</h3><blockquote><p>每个项目都有一份独立的<code>tsconfig.json</code>，继承一份公共的配置，最后可单独构建每个子项目工程</p></blockquote><blockquote><p>参考学习<code>typescript</code>项目 <a href="https://github.com/microsoft/TypeScript/tree/master/src">https://github.com/microsoft/TypeScript/tree/master/src</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 示例 项目入口</span><br><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    &quot;composite&quot;: true,</span><br><span class="line">    &quot;declaration&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 子工程1</span><br><span class="line">// src/client/tsconfig.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;, //继承基础配置</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/client&quot;, // 输出文件</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125; // 依赖文件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">// 子工程2</span><br><span class="line">// src/server/tsconfig.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;extends&quot;: &quot;../../tsconfig.json&quot;,</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;../../dist/server&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;references&quot;: [</span><br><span class="line">        &#123; &quot;path&quot;: &quot;../common&quot; &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、编译工具ts-loader、ts-lint"><a href="#五、编译工具ts-loader、ts-lint" class="headerlink" title="五、编译工具ts-loader、ts-lint"></a>五、编译工具ts-loader、ts-lint</h2><p><strong>如何选择Typescript编译器</strong></p><blockquote><ul><li>如果没有使用过<code>babel</code>，首选<code>Typescript</code>自身编译器(可配合<code>Ts-loader</code>使用)</li><li>如果项目中已经使用<code>babel</code>，安装<code>@babel/preset-typescript</code>(可配合tsc做类型检查)</li><li>两种编译工具不要混用</li></ul></blockquote><p><strong>typescript-eslint与babel-eslint区别</strong></p><blockquote><ul><li><code>babel-eslint</code>支持<code>typescript</code>没有额外的语法检查，抛弃<code>typescript</code>,不支持类型检查</li><li><code>typescript-eslint</code>基础typescript的AST,基于创建基于类型信息的规则（<code>tsconfig.json</code>）</li></ul></blockquote><ul><li>两者底层机制不一样，不要一起使用</li><li><code>babel</code>体系建议使用<code>babel-eslint</code>，否则使用<code>typescript-eslint</code></li></ul><p><strong>总结</strong></p><ul><li>编译工具<ul><li><code>ts-loader</code></li><li><code>@babel/preset-typescript</code></li></ul></li><li>代码检查工具<ul><li><code>babel-eslint</code></li><li><code>typescript-eslint</code></li></ul></li></ul><h2 id="六、使用jest进行单元测试"><a href="#六、使用jest进行单元测试" class="headerlink" title="六、使用jest进行单元测试"></a>六、使用jest进行单元测试</h2><ul><li>单元测试工具<ul><li><code>ts-jest</code> – 能够在测试用例中进行类型检查</li><li><code>babel-jest</code> – 没有进行类型检查</li></ul></li></ul><blockquote><p>生成配置文件 <code>ts-jest config:init</code></p></blockquote><h1 id="第三章-项目实战"><a href="#第三章-项目实战" class="headerlink" title="第三章 项目实战"></a>第三章 项目实战</h1><h2 id="一、思维导图"><a href="#一、思维导图" class="headerlink" title="一、思维导图"></a>一、思维导图</h2><p><img src="https://poetries1.gitee.io/img-repo/20190903/1.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/20190903/2.png" alt="img"></p><h2 id="二、React项目实践"><a href="#二、React项目实践" class="headerlink" title="二、React项目实践"></a>二、React项目实践</h2><h3 id="2-1-手动创建react项目"><a href="#2-1-手动创建react项目" class="headerlink" title="2.1 手动创建react项目"></a>2.1 手动创建react项目</h3><blockquote><p>项目代码 <a href="https://github.com/poetries/typescript-in-action/tree/master/ts-react">https://github.com/poetries/typescript-in-action/tree/master/ts-react</a></p></blockquote><p><strong>1. 安装依赖文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom</span><br></pre></td></tr></table></figure><p><strong>2. 修改tsconfig.json</strong>配置</p><blockquote><p>修改 <code>compilerOptions</code>中的<code>jsx</code>为<code>react</code></p></blockquote><h3 id="2-2-使用脚手架安装"><a href="#2-2-使用脚手架安装" class="headerlink" title="2.2 使用脚手架安装"></a>2.2 使用脚手架安装</h3><blockquote><p>项目代码 <a href="https://github.com/poetries/typescript-in-action/tree/master/ts-react-app">https://github.com/poetries/typescript-in-action/tree/master/ts-react-app</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app ts-react-app --typescript</span><br></pre></td></tr></table></figure><h4 id="2-2-1-函数组件"><a href="#2-2-1-函数组件" class="headerlink" title="2.2.1 函数组件"></a>2.2.1 函数组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const Hello = (props: Greeting) =&gt; &lt;Button&gt;Hello &#123;props.name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">// const Hello: React.FC&lt;Greeting&gt; = (&#123;</span><br><span class="line">//     name,</span><br><span class="line">//     firstName,</span><br><span class="line">//     lastName,</span><br><span class="line">//     children</span><br><span class="line">// &#125;) =&gt; &lt;Button&gt;Hello &#123;name&#125;&lt;/Button&gt;</span><br><span class="line"></span><br><span class="line">Hello.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Hello;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-类组件"><a href="#2-2-2-类组件" class="headerlink" title="2.2.2 类组件"></a>2.2.2 类组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName?: string;</span><br><span class="line">    lastName?: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface HelloState &#123;</span><br><span class="line">    count: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class HelloClass extends Component&lt;Greeting, HelloState&gt; &#123;</span><br><span class="line">    state: HelloState = &#123;</span><br><span class="line">        count: 0</span><br><span class="line">    &#125;</span><br><span class="line">    static defaultProps = &#123;</span><br><span class="line">        firstName: &#x27;&#x27;,</span><br><span class="line">        lastName: &#x27;&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;p&gt;你点击了 &#123;this.state.count&#125; 次&lt;/p&gt;</span><br><span class="line">                &lt;Button onClick=&#123;() =&gt; &#123;this.setState(&#123;count: this.state.count + 1&#125;)&#125;&#125;&gt;</span><br><span class="line">                    Hello &#123;this.props.name&#125;</span><br><span class="line">                &lt;/Button&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloClass;</span><br></pre></td></tr></table></figure><h4 id="2-2-3-高阶组件"><a href="#2-2-3-高阶组件" class="headerlink" title="2.2.3 高阶组件"></a>2.2.3 高阶组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">import HelloClass from &#x27;./HelloClass&#x27;;</span><br><span class="line"></span><br><span class="line">interface Loading &#123;</span><br><span class="line">    loading: boolean</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloHOC&lt;P&gt;(WrappedComponent: React.ComponentType&lt;P&gt;) &#123;</span><br><span class="line">    return class extends Component&lt;P &amp; Loading&gt; &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const &#123; loading, ...props &#125; = this.props;</span><br><span class="line">            return loading ? &lt;div&gt;Loading...&lt;/div&gt; : &lt;WrappedComponent &#123; ...props as P &#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHOC(HelloClass);</span><br></pre></td></tr></table></figure><h4 id="2-2-4-Hooks组件"><a href="#2-2-4-Hooks组件" class="headerlink" title="2.2.4 Hooks组件"></a>2.2.4 Hooks组件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Button &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">interface Greeting &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    firstName: string;</span><br><span class="line">    lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const HelloHooks = (props: Greeting) =&gt; &#123;</span><br><span class="line">    const [count, setCount] = useState(0);</span><br><span class="line">    const [text, setText] = useState&lt;string | null&gt;(null);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        if (count &gt; 5) &#123;</span><br><span class="line">            setText(&#x27;休息一下&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [count]);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;&gt;</span><br><span class="line">            &lt;p&gt;你点击了 &#123;count&#125; 次 &#123;text&#125;&lt;/p&gt;</span><br><span class="line">            &lt;Button onClick=&#123;() =&gt; &#123;setCount(count + 1)&#125;&#125;&gt;</span><br><span class="line">                Hello &#123;props.name&#125;</span><br><span class="line">            &lt;/Button&gt;</span><br><span class="line">        &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloHooks.defaultProps = &#123;</span><br><span class="line">    firstName: &#x27;&#x27;,</span><br><span class="line">    lastName: &#x27;&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default HelloHooks;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-事件处理与数据请求"><a href="#2-2-5-事件处理与数据请求" class="headerlink" title="2.2.5 事件处理与数据请求"></a>2.2.5 事件处理与数据请求</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState, useEffect &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Form, Input, Select, Button &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; FormComponentProps &#125; from &#x27;antd/lib/form&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; GET_EMPLOYEE_URL &#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line">import &#123; EmployeeRequest, EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">const &#123; Option &#125; = Select;</span><br><span class="line"></span><br><span class="line">interface Props extends FormComponentProps &#123;</span><br><span class="line">    onDataChange(data: EmployeeResponse): void</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const QueryFormHooks = (props: Props) =&gt; &#123;</span><br><span class="line">//     const [name, setName] = useState(&#x27;&#x27;);</span><br><span class="line">//     const [departmentId, setDepartmentId] = useState&lt;number | undefined&gt;();</span><br><span class="line"></span><br><span class="line">//     const handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">//         setName(e.currentTarget.value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">//         setDepartmentId(value)</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const handleSubmit = () =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     const queryEmployee = (param: EmployeeRequest) =&gt; &#123;</span><br><span class="line">//         get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">//             props.onDataChange(res.data);</span><br><span class="line">//         &#125;);</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     useEffect(() =&gt; &#123;</span><br><span class="line">//         queryEmployee(&#123;name, departmentId&#125;);</span><br><span class="line">//     &#125;, [])</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Input</span><br><span class="line">//                         placeholder=&quot;姓名&quot;</span><br><span class="line">//                         style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                         allowClear</span><br><span class="line">//                         value=&#123;name&#125;</span><br><span class="line">//                         onChange=&#123;handleNameChange&#125;</span><br><span class="line">//                     /&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                 &lt;Select</span><br><span class="line">//                     placeholder=&quot;部门&quot;</span><br><span class="line">//                     style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">//                     allowClear</span><br><span class="line">//                     value=&#123;departmentId&#125;</span><br><span class="line">//                     onChange=&#123;handleDepartmentChange&#125;</span><br><span class="line">//                 &gt;</span><br><span class="line">//                     &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">//                     &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">//                 &lt;/Select&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//                 &lt;Form.Item&gt;</span><br><span class="line">//                     &lt;Button type=&quot;primary&quot; onClick=&#123;handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">//                 &lt;/Form.Item&gt;</span><br><span class="line">//             &lt;/Form&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">class QueryForm extends Component&lt;Props, EmployeeRequest&gt; &#123;</span><br><span class="line">    state: EmployeeRequest = &#123;</span><br><span class="line">        name: &#x27;&#x27;,</span><br><span class="line">        departmentId: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    handleNameChange = (e: React.FormEvent&lt;HTMLInputElement&gt;) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            name: e.currentTarget.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleDepartmentChange = (value: number) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            departmentId: value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleSubmit = () =&gt; &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.queryEmployee(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    queryEmployee(param: EmployeeRequest) &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            this.props.onDataChange(res.data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;Form layout=&quot;inline&quot;&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Input</span><br><span class="line">                        placeholder=&quot;姓名&quot;</span><br><span class="line">                        style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                        allowClear</span><br><span class="line">                        value=&#123;this.state.name&#125;</span><br><span class="line">                        onChange=&#123;this.handleNameChange&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                &lt;Select</span><br><span class="line">                    placeholder=&quot;部门&quot;</span><br><span class="line">                    style=&#123;&#123; width: 120 &#125;&#125;</span><br><span class="line">                    allowClear</span><br><span class="line">                    value=&#123;this.state.departmentId&#125;</span><br><span class="line">                    onChange=&#123;this.handleDepartmentChange&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                    &lt;Option value=&#123;1&#125;&gt;技术部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;2&#125;&gt;产品部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;3&#125;&gt;市场部&lt;/Option&gt;</span><br><span class="line">                    &lt;Option value=&#123;4&#125;&gt;运营部&lt;/Option&gt;</span><br><span class="line">                &lt;/Select&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">                &lt;Form.Item&gt;</span><br><span class="line">                    &lt;Button type=&quot;primary&quot; onClick=&#123;this.handleSubmit&#125;&gt;查询&lt;/Button&gt;</span><br><span class="line">                &lt;/Form.Item&gt;</span><br><span class="line">            &lt;/Form&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const WrapQueryForm = Form.create&lt;Props&gt;(&#123;</span><br><span class="line">    name: &#x27;employee_query&#x27;</span><br><span class="line">&#125;)(QueryForm);</span><br><span class="line"></span><br><span class="line">export default WrapQueryForm;</span><br></pre></td></tr></table></figure><h4 id="2-2-6-列表渲染"><a href="#2-2-6-列表渲染" class="headerlink" title="2.2.6 列表渲染"></a>2.2.6 列表渲染</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, useState &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; Table &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">import QueryForm from &#x27;./QueryForm&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; employeeColumns &#125; from &#x27;./colums&#x27;;</span><br><span class="line">import &#123; EmployeeResponse &#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">// Hooks version</span><br><span class="line">// const Employee = () =&gt; &#123;</span><br><span class="line">//     const [employee, setEmployee] = useState&lt;EmployeeResponse&gt;(undefined);</span><br><span class="line"></span><br><span class="line">//     const getTotal = () =&gt; &#123;</span><br><span class="line">//         let total: number;</span><br><span class="line">//         if (typeof employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">//             total = employee.length</span><br><span class="line">//         &#125; else &#123;</span><br><span class="line">//             total = 0</span><br><span class="line">//         &#125;</span><br><span class="line">//         return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">//     &#125;</span><br><span class="line"></span><br><span class="line">//     return (</span><br><span class="line">//         &lt;&gt;</span><br><span class="line">//             &lt;QueryForm onDataChange=&#123;setEmployee&#125; /&gt;</span><br><span class="line">//             &#123;/* &#123;getTotal()&#125; */&#125;</span><br><span class="line">//             &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">//         &lt;/&gt;</span><br><span class="line">//     )</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">interface State &#123;</span><br><span class="line">    employee: EmployeeResponse</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Employee extends Component&lt;&#123;&#125;, State&gt; &#123;</span><br><span class="line">    state: State = &#123;</span><br><span class="line">        employee: undefined</span><br><span class="line">    &#125;</span><br><span class="line">    setEmployee = (employee: EmployeeResponse) =&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            employee</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    getTotal() &#123;</span><br><span class="line">        let total: number;</span><br><span class="line">        // 类型保护</span><br><span class="line">        if (typeof this.state.employee !== &#x27;undefined&#x27;) &#123;</span><br><span class="line">            total = this.state.employee.length</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            total = 0</span><br><span class="line">        &#125;</span><br><span class="line">        return &lt;p&gt;共 &#123;total&#125; 名员工&lt;/p&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;&gt;</span><br><span class="line">                &lt;QueryForm onDataChange=&#123;this.setEmployee&#125; /&gt;</span><br><span class="line">                &#123;/* &#123;this.getTotal()&#125; */&#125;</span><br><span class="line">                &lt;Table columns=&#123;employeeColumns&#125; dataSource=&#123;this.state.employee&#125; className=&quot;table&quot; /&gt;</span><br><span class="line">            &lt;/&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Employee;</span><br></pre></td></tr></table></figure><h4 id="2-2-7-Redux与类型"><a href="#2-2-7-Redux与类型" class="headerlink" title="2.2.7 Redux与类型"></a>2.2.7 Redux与类型</h4><blockquote><p>项目代码 <a href="https://github.com/poetries/typescript-in-action/tree/master/ts-redux">https://github.com/poetries/typescript-in-action/tree/master/ts-redux</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Dispatch &#125; from &#x27;redux&#x27;;</span><br><span class="line">import _ from &#x27;lodash&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123; get, post &#125; from &#x27;../../utils/request&#x27;;</span><br><span class="line">import &#123; department, level &#125; from &#x27;../../constants/options&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE_URL,</span><br><span class="line">    CREATE_EMPLOYEE_URL,</span><br><span class="line">    DELETE_EMPLOYEE_URL,</span><br><span class="line">    UPDATE_EMPLOYEE_URL</span><br><span class="line">&#125; from &#x27;../../constants/urls&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    GET_EMPLOYEE,</span><br><span class="line">    CREATE_EMPLOYEE,</span><br><span class="line">    DELETE_EMPLOYEE,</span><br><span class="line">    UPDATE_EMPLOYEE</span><br><span class="line">&#125; from &#x27;../../constants/actions&#x27;;</span><br><span class="line"></span><br><span class="line">import &#123;</span><br><span class="line">    EmployeeInfo,</span><br><span class="line">    EmployeeRequest,</span><br><span class="line">    EmployeeResponse,</span><br><span class="line">    CreateRequest,</span><br><span class="line">    DeleteRequest,</span><br><span class="line">    UpdateRequest</span><br><span class="line">&#125; from &#x27;../../interface/employee&#x27;;</span><br><span class="line"></span><br><span class="line">type State = Readonly&lt;&#123;</span><br><span class="line">    employeeList: EmployeeResponse</span><br><span class="line">&#125;&gt;</span><br><span class="line"></span><br><span class="line">type Action = &#123;</span><br><span class="line">    type: string;</span><br><span class="line">    payload: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const initialState: State = &#123;</span><br><span class="line">    employeeList: undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function getEmployee(param: EmployeeRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        get(GET_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: GET_EMPLOYEE,</span><br><span class="line">                payload: res.data</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function createEmployee(param: CreateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(CREATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: CREATE_EMPLOYEE,</span><br><span class="line">                payload: &#123;</span><br><span class="line">                    name: param.name,</span><br><span class="line">                    department: department[param.departmentId],</span><br><span class="line">                    departmentId: param.departmentId,</span><br><span class="line">                    hiredate: param.hiredate,</span><br><span class="line">                    level: level[param.levelId],</span><br><span class="line">                    levelId: param.levelId,</span><br><span class="line">                    ...res.data</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function deleteEmployee(param: DeleteRequest) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(DELETE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: DELETE_EMPLOYEE,</span><br><span class="line">                payload: param.id</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function updateEmployee(param: UpdateRequest, callback: () =&gt; void) &#123;</span><br><span class="line">    return (dispatch: Dispatch) =&gt; &#123;</span><br><span class="line">        post(UPDATE_EMPLOYEE_URL, param).then(res =&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: UPDATE_EMPLOYEE,</span><br><span class="line">                payload: param</span><br><span class="line">            &#125;);</span><br><span class="line">            callback();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function(state = initialState, action: Action) &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case GET_EMPLOYEE:</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: action.payload</span><br><span class="line">            &#125;</span><br><span class="line">        case CREATE_EMPLOYEE:</span><br><span class="line">            let newList = [action.payload, ...(state.employeeList as EmployeeInfo[])]</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: newList</span><br><span class="line">            &#125;</span><br><span class="line">        case DELETE_EMPLOYEE:</span><br><span class="line">            let reducedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            _.remove(reducedList, (item: EmployeeInfo) =&gt; &#123;</span><br><span class="line">                return item.id === action.payload</span><br><span class="line">            &#125;);</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: reducedList</span><br><span class="line">            &#125;</span><br><span class="line">        case UPDATE_EMPLOYEE:</span><br><span class="line">            let updatedList = [...(state.employeeList as EmployeeInfo[])];</span><br><span class="line">            let item: UpdateRequest = action.payload;</span><br><span class="line">            let index = _.findIndex(updatedList, &#123;</span><br><span class="line">                id: item.id</span><br><span class="line">            &#125;);</span><br><span class="line">            updatedList[index] = &#123;</span><br><span class="line">                id: item.id,</span><br><span class="line">                key: item.id,</span><br><span class="line">                name: item.name,</span><br><span class="line">                department: department[item.departmentId],</span><br><span class="line">                departmentId: item.departmentId,</span><br><span class="line">                hiredate: item.hiredate,</span><br><span class="line">                level: level[item.levelId],</span><br><span class="line">                levelId: item.levelId</span><br><span class="line">            &#125;</span><br><span class="line">            return &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                employeeList: updatedList</span><br><span class="line">            &#125;</span><br><span class="line">        default:</span><br><span class="line">            return state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-服务端使用Typescript"><a href="#2-3-服务端使用Typescript" class="headerlink" title="2.3 服务端使用Typescript"></a>2.3 服务端使用Typescript</h3><blockquote><p>项目地址 <a href="https://github.com/poetries/typescript-in-action/tree/master/ts-express">https://github.com/poetries/typescript-in-action/tree/master/ts-express</a></p></blockquote><h2 id="三、Vue项目实践"><a href="#三、Vue项目实践" class="headerlink" title="三、Vue项目实践"></a>三、Vue项目实践</h2><blockquote><p>项目代码 <a href="https://github.com/poetries/typescript-in-action/tree/master/ts-vue">https://github.com/poetries/typescript-in-action/tree/master/ts-vue</a></p></blockquote><blockquote><p>TS不能识别<code>.vue</code>文件，需要声明文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// vue-shims.d.ts</span><br><span class="line"></span><br><span class="line">declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">    import Vue from &#x27;vue&#x27;</span><br><span class="line">    export default Vue</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/poetries/poetries.github.io/edit/dev/source/_posts/ts-in-action.md">原文地址</a></p></blockquote><h1 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h1><ul><li><a href="http://blog.poetries.top/ts-axios/chapter1/">TypeScript 从零实现 axios</a></li><li><a href="http://blog.poetries.top/2018/12/29/ts-intro-and-use-in-react/">Typescript基础及结合React实践(一)</a></li><li><a href="http://blog.poetries.top/2018/12/30/ts-summary/">Typescript总结篇（二）</a></li><li><a href="http://blog.poetries.top/2018/12/31/ts-react-template/">Typescript+React模板搭建（三）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-基础篇&quot;&gt;&lt;a href=&quot;#第一章-基础篇&quot; class=&quot;headerlink&quot; title=&quot;第一章 基础篇&quot;&gt;&lt;/a&gt;第一章 基础篇&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;TS基础篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript基础总结</title>
    <link href="http://example.com/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2021/08/03/html+css+js+ts/5-Typescript%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-03T13:18:43.000Z</published>
    <updated>2022-06-07T00:43:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、typescript-安装"><a href="#一、typescript-安装" class="headerlink" title="一、typescript 安装"></a>一、typescript 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i typescript -g</span><br></pre></td></tr></table></figure><blockquote><p>全局安装完成后，我们新建一个<code>hello.ts</code>的<code>ts</code>文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.ts内容</span><br><span class="line">let a = &quot;poet&quot;</span><br></pre></td></tr></table></figure><blockquote><p>接下来我们在命令行输入<code>tsc hello.ts</code>来编译这个<code>ts</code>文件，然后会在同级目录生成一个编译好了的<code>hello.js</code>文件</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// hello.js内容</span><br><span class="line">var = &quot;poet&quot;</span><br></pre></td></tr></table></figure><blockquote><p>那么我们每次都要输<code>tsc hello.ts</code>命令来编译，这样很麻烦，能否让它自动编译？答案是可以的，使用<code>vscode</code>来开发，需要配置一下<code>vscode</code>就可以。</p></blockquote><blockquote><p>首先我们在命令行执行<code>tsc --init</code>来生成配置文件，然后我们在目录下看到生成了一个<code>tsconfig.json</code>文件</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/545.png" alt="img"></p><blockquote><p>这个<code>json</code>文件里有很多选项</p></blockquote><ul><li><code>target</code>是选择编译到什么语法</li><li><code>module</code>则是模块类型</li><li><code>outDir</code>则是输出目录，可以指定这个参数到指定目录</li></ul><blockquote><p>更多细节 <a href="https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html">https://zhongsp.gitbooks.io/typescript-handbook/content/doc/handbook/tsconfig.json.html</a></p></blockquote><blockquote><p>接下来我们需要开启监控了，在<code>vscode</code>任务栏中</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/546.png" alt="img"></p><p><strong>Typescript在线编辑器</strong></p><blockquote><p>建议使用在线编辑器练习 <a href="http://www.typescriptlang.org/play/index.html">http://www.typescriptlang.org/play/index.html</a></p></blockquote><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><blockquote><p><code>js</code>是弱类型语言，强弱类语言有什么区别呢？<code>typescript</code>最大的优点就是类型检查，可以帮你检查你定义的类型和赋值的类型。</p></blockquote><h3 id="2-1-布尔类型boolean"><a href="#2-1-布尔类型boolean" class="headerlink" title="2.1 布尔类型boolean"></a>2.1 布尔类型boolean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 在js中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">let isFlag = true;</span><br><span class="line">// 但是我们也可以重新给它赋值为字符串</span><br><span class="line">isFlag = &quot;hello swr&quot;;</span><br><span class="line"></span><br><span class="line">// 在ts中，定义isFlag为true，为布尔类型boolean</span><br><span class="line">// 在变量名后加冒号和类型，如  :boolean</span><br><span class="line">let isFlag:boolean = true</span><br><span class="line">// 重新赋值到字符串类型会报错</span><br><span class="line">isFlag = &quot;hello swr&quot; </span><br><span class="line"></span><br><span class="line">// 在java中，一般是这样定义，要写变量名也要写类型名</span><br><span class="line">// int a = 10; </span><br><span class="line">// string name = &quot;poetries&quot;</span><br></pre></td></tr></table></figure><h3 id="2-2-数字类型number"><a href="#2-2-数字类型number" class="headerlink" title="2.2 数字类型number"></a>2.2 数字类型number</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let age:number = 28;</span><br><span class="line">age = 29;</span><br></pre></td></tr></table></figure><h3 id="2-3-字符串类型string"><a href="#2-3-字符串类型string" class="headerlink" title="2.3 字符串类型string"></a>2.3 字符串类型string</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name:string = &quot;poetries&quot;</span><br><span class="line">name = &quot;iamswr&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上<code>boolean</code>、<code>number</code>、<code>string</code>类型有个共性，就是可以通过<code>typeof</code>来获取到是什么类型，是基本数据类型</p></blockquote><p>那么复杂的数据类型是怎么处理的呢？</p><h3 id="2-4-数组-Array"><a href="#2-4-数组-Array" class="headerlink" title="2.4 数组 Array"></a>2.4 数组 Array</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 数组</span><br><span class="line">// 这是一个字符串数组，只能往里面放字符串，写别的类型会报错</span><br><span class="line">let persion:string[] = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line">// 另一个写法 </span><br><span class="line">let persions:Array&lt;string&gt; = [&#x27;poetries&#x27;, &#x27;jing&#x27;]</span><br><span class="line"></span><br><span class="line">// 如果数组里放对象呢</span><br><span class="line">let persionObject:Array&lt;object&gt; = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line">let persionObjects:object[] = [&#123;name:&#x27;poetries&#x27;,age:22&#125;]</span><br><span class="line"></span><br><span class="line">// 在数组中放string、number、boolean、object</span><br><span class="line">let arr:Array&lt;number|object|string|boolean&gt; = [22, &#x27;test&#x27;, true, &#123;name:&#x27;poetries&#x27;&#125;]</span><br><span class="line"></span><br><span class="line">// 数组中放什么都可以</span><br><span class="line">let arrAny:Array&lt;any&gt; = [&#x27;test&#x27;,12,false]</span><br></pre></td></tr></table></figure><h3 id="2-5-元组类型tuple"><a href="#2-5-元组类型tuple" class="headerlink" title="2.5 元组类型tuple"></a>2.5 元组类型tuple</h3><ul><li>什么是元组类型？其实元组是数组的一种。</li><li>有点类似解构赋值，但是又不完全是解构赋值，比如元组类型必须一一对应上</li><li>元组类型是一个不可变的数组，长度、类型是不可变的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 元组类型tuple</span><br><span class="line">// 什么是元组类型？其实元组是数组的一种</span><br><span class="line">let per :[string,number,object] = [&#x27;poetries&#x27;,22,&#123;love: &#x27;coding&#x27;&#125;]</span><br></pre></td></tr></table></figure><h3 id="2-6-枚举类型enum"><a href="#2-6-枚举类型enum" class="headerlink" title="2.6 枚举类型enum"></a>2.6 枚举类型enum</h3><blockquote><p>什么是枚举？枚举有点类似一一列举，一个一个数出来。一般用于值是某几个固定的值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 枚举类型enum</span><br><span class="line"></span><br><span class="line">enum sex &#123;</span><br><span class="line">    BOY=&#x27;男孩&#x27;,</span><br><span class="line">    GIRL=&#x27;女孩&#x27;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sex)</span><br><span class="line">// 转化为es5语法</span><br><span class="line">// 我们顺便看看实现的原理</span><br><span class="line"></span><br><span class="line">var sex;</span><br><span class="line">(function (sex) &#123;</span><br><span class="line">// 首先这里是一个自执行函数</span><br><span class="line">// 并且把sex定义为对象，传参进给自执行函数</span><br><span class="line">// 然后给sex对象添加属性并且赋值</span><br><span class="line">    sex[&quot;BOY&quot;] = &quot;\u7537\u5B69&quot;;</span><br><span class="line">    sex[&quot;GIRL&quot;] = &quot;\u5973\u5B69&quot;;</span><br><span class="line">&#125;)(sex || (sex = &#123;&#125;));</span><br><span class="line">console.log(sex);</span><br></pre></td></tr></table></figure><blockquote><p>比如我们实际项目中，特别是商城类，订单会存在很多状态流转，那么非常适合用枚举</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum orderStatus &#123;</span><br><span class="line">    WAIT_FOR_PAY = &quot;待支付&quot;,</span><br><span class="line">    UNDELIVERED = &quot;完成支付，待发货&quot;,</span><br><span class="line">    DELIVERED = &quot;已发货&quot;,</span><br><span class="line">    COMPLETED = &quot;已确认收货&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里，我们会有一个疑虑，为什么我们不这样写呢？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let orderStatus2 = &#123;</span><br><span class="line">    WAIT_FOR_PAY : &quot;待支付&quot;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果我们直接写对象的键值对方式，是可以在外部修改这个值的，而我们通过<code>enum</code>则不能修改定义好的值了</p></blockquote><h3 id="2-7-任意类型-any"><a href="#2-7-任意类型-any" class="headerlink" title="2.7 任意类型 any"></a>2.7 任意类型 any</h3><blockquote><p><code>any</code>有好处也有坏处，特别是前端，很多时候写类型的时候，几乎分不清楚类型，任意去写，写起来很爽，但是对于后续的重构、迭代等是非常不友好的，会暴露出很多问题，某种程度来说，<code>any</code>类型就是放弃了类型检查了</p></blockquote><p>比如我们有这样一个场景，就是需要获取某一个dom节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let btn = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br></pre></td></tr></table></figure><blockquote><p>此时我们发现在<code>ts</code>中会报错</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/547.png" alt="img"></p><ul><li>因为我们取这个<code>dom</code>节点，有可能取到，也有可能没取到，当没取到的时候，相当于是<code>null</code>，是没有<code>style</code>这个属性的。</li><li>那么我们可以给它添加一个类型为<code>any</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个any类型，此时就不会报错了，但是也相当于放弃了类型检查了</span><br><span class="line">let btn:any = document.getElementById(&#x27;btn&#x27;);</span><br><span class="line">btn.style.color = &quot;blue&quot;;</span><br><span class="line">// 可以赋值任何类型的值</span><br><span class="line">// 跟以前我们var let声明的一模一样的</span><br><span class="line">let person:any = &quot;poetries&quot;</span><br><span class="line">person = 22</span><br></pre></td></tr></table></figure><h3 id="2-8-null-undefined类型"><a href="#2-8-null-undefined类型" class="headerlink" title="2.8 null undefined类型"></a>2.8 null undefined类型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// (string | number | null | undefined) 相当于这几种类型</span><br><span class="line">// 是 string 或 number 或 null 或 undefined</span><br><span class="line"></span><br><span class="line">let str:(string | number | null | undefined)</span><br><span class="line"></span><br><span class="line">str = &#x27;poetries&#x27;</span><br><span class="line">str = 28</span><br><span class="line">str = null </span><br><span class="line">str = undefined</span><br></pre></td></tr></table></figure><h3 id="2-9-void类型"><a href="#2-9-void类型" class="headerlink" title="2.9 void类型"></a>2.9 void类型</h3><blockquote><p><code>void</code>表示没有任何类型，一般是定义函数没有返回值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// void 不能再函数里写return</span><br><span class="line">// 怎么理解叫没有返回值呢？此时我们给函数return一个值</span><br><span class="line">function say(name:string):void&#123;</span><br><span class="line">    console.log(&#x27;hello:&#x27;, name)</span><br><span class="line">    // return &quot;ok&quot; 会报错</span><br><span class="line">    return undefined;</span><br><span class="line">    return //不会报错</span><br><span class="line">&#125;</span><br><span class="line">say(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 返回一个字符串类型</span><br><span class="line">function say1(name:string):string &#123;</span><br><span class="line">    return &#x27;ok&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10-never类型"><a href="#2-10-never类型" class="headerlink" title="2.10 never类型"></a>2.10 never类型</h3><blockquote><p>这个用得很少，一般是用于抛出异常</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function error(message:string):never &#123;</span><br><span class="line">    throw new Error(message)</span><br><span class="line">&#125;</span><br><span class="line">error(&#x27;errorMsg&#x27;)</span><br></pre></td></tr></table></figure><h3 id="2-11-我们要搞明白any、never、void"><a href="#2-11-我们要搞明白any、never、void" class="headerlink" title="2.11 我们要搞明白any、never、void"></a>2.11 我们要搞明白any、never、void</h3><ul><li><code>any</code>是任意的值</li><li><code>void</code>是不能有任何值</li><li><code>never</code>永远不会有返回值</li></ul><blockquote><p><code>any</code>比较好理解，就是任何值都可以</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str:any = &quot;hello poetries&quot;</span><br><span class="line">str = 28</span><br><span class="line">str = true</span><br></pre></td></tr></table></figure><blockquote><p><code>void</code>不能有任何值(返回值)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():void &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>never</code>则不好理解，什么叫永远不会有返回值？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 除了上面举例的抛出异常以外，我们看一下这个例子</span><br><span class="line">// 这个loop函数，一旦开始执行，就永远不会结束</span><br><span class="line">// 可以看出在while中，是死循环，永远都不会有返回值，包括undefined</span><br><span class="line"></span><br><span class="line">function loop():never &#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        console.log(&quot;陷入死循环啦&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loop()</span><br><span class="line"></span><br><span class="line">// 包括比如JSON.parse也是使用这种 never | any</span><br><span class="line">function parse(str:string):(never | any)&#123;</span><br><span class="line">    return JSON.parse(str)</span><br><span class="line">&#125;</span><br><span class="line">// 首先在正常情况下，我们传一个JSON格式的字符串，是可以正常得到一个JSON对象的</span><br><span class="line">let json = parse(&#x27;&#123;&quot;name&quot;:&quot;poetries&quot;&#125;&#x27;)</span><br><span class="line">// 但是有时候，传进去的不一定是JSON格式的字符串，那么就会抛出异常</span><br><span class="line">// 此时就需要never了</span><br><span class="line">let json = parse(&quot;iamswr&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>也就是说，当一个函数执行的时候，被抛出异常打断了，导致没有返回值或者该函数是一个死循环，永远没有返回值，这样叫做永远不会有返回值。</p></blockquote><p>实际开发中，是<code>never</code>和联合类型来一起用，比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function say():(never | string) &#123;</span><br><span class="line">  return &quot;ok&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><h3 id="3-1-函数定义"><a href="#3-1-函数定义" class="headerlink" title="3.1 函数定义"></a>3.1 函数定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sayHello(name:string):void &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-函数参数处理"><a href="#3-2-函数参数处理" class="headerlink" title="3.2 函数参数处理"></a>3.2 函数参数处理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 函数是这样定义的</span><br><span class="line">// 形参和实参一一对应，完全一样</span><br><span class="line">function sayHello(name:string,age:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHello(&#x27;poetries&#x27;,22)</span><br><span class="line"></span><br><span class="line">// 形参和实参要完全一样，如想不一样，则需要配置可选参数，可选参数放在后面</span><br><span class="line">// 可选参数，用 ？ 处理，只能放在后面</span><br><span class="line">function sayHelloToYou(name:string,age?:number):void &#123;</span><br><span class="line">    console.log(&#x27;hello&#x27;, name, age)</span><br><span class="line">&#125;</span><br><span class="line">sayHelloToYou(&#x27;poetries&#x27;)</span><br><span class="line"></span><br><span class="line">// 那么如何设置默认参数呢？</span><br><span class="line"></span><br><span class="line">function ajax(url:string,method:string = &#x27;GET&#x27;) &#123;</span><br><span class="line">    console.log(url, method)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 那么如何设置剩余参数呢？可以利用扩展运算符</span><br><span class="line"></span><br><span class="line">function sum(...args:Array&lt;number&gt;):number &#123;</span><br><span class="line">    return eval(args.join(&quot;+&quot;))</span><br><span class="line">&#125;</span><br><span class="line">let total:number = sum(1,2,3,4,5)</span><br><span class="line">console.log(total)</span><br></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 那么如何实现函数重载呢？函数重载是java中非常有名的，在java中函数的重载，是指两个或者两个以上的同名函数，参数的个数和类型不一样</span><br><span class="line"></span><br><span class="line">// 比如我们现在有两个同名函数</span><br><span class="line">// function eating(name:string) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// function eating(name:string,age:number) &#123;</span><br><span class="line">    </span><br><span class="line">// &#125;</span><br><span class="line">// 那么我想达到一个效果</span><br><span class="line">// 当我传参数name时，执行name:string这个函数</span><br><span class="line">// 当我传参数name和age时，执行name:string,age:number这个函数</span><br><span class="line">// 此时该怎么办？</span><br><span class="line"></span><br><span class="line">// 接下来看一下typescript中的函数重载</span><br><span class="line"></span><br><span class="line">// 首先声明两个函数名一样的函数</span><br><span class="line">function eating(name: string):void;</span><br><span class="line">function eating(name: number):void;</span><br><span class="line"></span><br><span class="line">function eating(name:any): void &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eating(&quot;hello poetries&quot;)</span><br><span class="line">eating(22)</span><br><span class="line"></span><br><span class="line">// 在typescript中主要体现是同一个同名函数提供多个函数类型定义，函数实际上就只有一个，就是拥有函数体那个，如果想根据传入值类型的不一样执行不同逻辑，则需要在这个函数里面进行一个类型判断。</span><br><span class="line"></span><br><span class="line">// 那么这个函数重载有什么作用呢？其实在ts中，函数重载只是用来限制参数的个数和类型，用来检查类型的，而且重载不能拆开几个函数，这一点和java的处理是不一样的，需要注意。</span><br></pre></td></tr></table></figure><h2 id="四、类"><a href="#四、类" class="headerlink" title="四、类"></a>四、类</h2><h3 id="4-1-定义一个类"><a href="#4-1-定义一个类" class="headerlink" title="4.1 定义一个类"></a>4.1 定义一个类</h3><blockquote><p>如何定义一个类？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// ts 写法</span><br><span class="line">// 跟es6非常像 没有太大区别</span><br><span class="line">class Persion &#123;</span><br><span class="line">    // 这里声明的变量 是实例上的属性</span><br><span class="line">    name: string;</span><br><span class="line">    age:number;</span><br><span class="line"></span><br><span class="line">    constructor(name: string, age: number)&#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    say():string &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p = new Persion(&#x27;poetries&#x27;, 22)</span><br><span class="line">// 那么转为es5呢？</span><br><span class="line"></span><br><span class="line">var Persion = /** @class */ (function () &#123;</span><br><span class="line">    function Persion(name, age) &#123;</span><br><span class="line">        // this.name和this.age 必须先在前面声明好类型</span><br><span class="line">        // name: string</span><br><span class="line">        // age: number</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    // 原型方法</span><br><span class="line">    Persion.prototype.say = function () &#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;;</span><br><span class="line">    &#125;;</span><br><span class="line">    return Persion;</span><br><span class="line">&#125;());</span><br><span class="line">var p = new Persion(&#x27;poetries&#x27;, 22);</span><br></pre></td></tr></table></figure><h3 id="4-2-类的继承"><a href="#4-2-类的继承" class="headerlink" title="4.2 类的继承"></a>4.2 类的继承</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 和es6也是差不多</span><br><span class="line">class Parent &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    constructor(name:string, age: number)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    say():string&#123;</span><br><span class="line">        return &#x27;hello poetries&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    childName: string;</span><br><span class="line">    constructor(name: string,age:number,childName:string) &#123;</span><br><span class="line">        super(name,age)</span><br><span class="line">        this.childName = childName</span><br><span class="line">    &#125;</span><br><span class="line">    childSay():string &#123;</span><br><span class="line">        return this.childName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let child = new Child(&#x27;poetries&#x27;, 22, &#x27;静观流叶&#x27;)</span><br><span class="line">console.log(child)</span><br></pre></td></tr></table></figure><h3 id="4-3-类的修饰符"><a href="#4-3-类的修饰符" class="headerlink" title="4.3 类的修饰符"></a>4.3 类的修饰符</h3><ul><li><code>public</code>公开的，可以供自己、子类以及其它类访问</li><li><code>protected</code>受保护的，可以供自己、子类访问，但是其他就访问不了</li><li><code>private</code>私有的，只有自己访问，而子类、其他都访问不了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Parents &#123;</span><br><span class="line">    public name:string;</span><br><span class="line">    protected age:number;</span><br><span class="line">    private money:number;</span><br><span class="line"></span><br><span class="line">   // 简写</span><br><span class="line">   // constructor(public name:string,protected age:number,private money:number)</span><br><span class="line"></span><br><span class="line">   constructor(name: string, age:number,money:number) &#123;</span><br><span class="line">       this.name = name;</span><br><span class="line">       this.age = age;</span><br><span class="line">       this.money = money;</span><br><span class="line">   &#125;</span><br><span class="line">   getName():string &#123;</span><br><span class="line">       return this.name</span><br><span class="line">   &#125;</span><br><span class="line">   getAge():number&#123;</span><br><span class="line">       return this.age</span><br><span class="line">   &#125;</span><br><span class="line">   getMoney():number&#123;</span><br><span class="line">       return this.money</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">let pare = new Parents(&#x27;poetries&#x27;, 22, 3000)</span><br><span class="line">console.log(pare.name)</span><br><span class="line">// console.log(pare.age)  报错</span><br><span class="line">// console.log(pare.money) 报错</span><br></pre></td></tr></table></figure><h3 id="4-4-静态属性、静态方法"><a href="#4-4-静态属性、静态方法" class="headerlink" title="4.4 静态属性、静态方法"></a>4.4 静态属性、静态方法</h3><p>跟<code>es6</code>差不多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person2 &#123;</span><br><span class="line">    // 类的静态属性</span><br><span class="line">    static name1 = &#x27;poetries&#x27;</span><br><span class="line"></span><br><span class="line">    // 类的静态方法</span><br><span class="line">    static say() &#123;</span><br><span class="line">        console.log(&#x27;hello poetries&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let per2 = new Person2()</span><br><span class="line">Person2.say() // hello poetries</span><br><span class="line">// per2.say() 报错</span><br></pre></td></tr></table></figure><h3 id="4-5-抽象类"><a href="#4-5-抽象类" class="headerlink" title="4.5 抽象类"></a>4.5 抽象类</h3><ul><li>抽象类和方法，有点类似抽取共性出来，但是又不是具体化，比如说，世界上的动物都需要吃东西，那么会把吃东西这个行为，抽象出来</li><li>如果子类继承的是一个抽象类，子类必须实现父类里的抽象方法，不然的话不能实例化，会报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/ 关键字 abstract抽象</span><br><span class="line">// 定义抽象类</span><br><span class="line"></span><br><span class="line">abstract class Animal &#123;</span><br><span class="line">    // 实际上是使用了public修饰符</span><br><span class="line">    // 如果添加private修饰符会报错</span><br><span class="line">    abstract eat():void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要注意的是这个Animal是不能实例化的</span><br><span class="line">// let animal = new Animal() // 报错</span><br><span class="line"></span><br><span class="line">// // 抽象类的抽象方法，意思就是，需要在继承这个抽象类的子类中</span><br><span class="line">// 实现这个抽象方法，不然会报错</span><br><span class="line">// 报错，因为在子类中没有实现eat抽象方法</span><br><span class="line">// class Person4 extends Animal&#123;</span><br><span class="line">//     test()&#123;</span><br><span class="line">//         console.log(&quot;吃米饭&quot;)</span><br><span class="line">//     &#125;</span><br><span class="line">// &#125;</span><br><span class="line"></span><br><span class="line">// Dog类继承Animal类后并且实现了抽象方法eat，所以不会报错</span><br><span class="line">class Dog extends Animal&#123;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&quot;吃骨头&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、接口"><a href="#五、接口" class="headerlink" title="五、接口"></a>五、接口</h2><blockquote><p>这里的接口，主要是一种规范，规范某些类必须遵守规范，和抽象类有点类似，但是不局限于类，还有属性、函数等</p></blockquote><h3 id="5-1-接口规范对象"><a href="#5-1-接口规范对象" class="headerlink" title="5.1 接口规范对象"></a>5.1 接口规范对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//假设我们需要获取用户信息</span><br><span class="line">// 我们通过这样的方式 规范必须传name和age的值</span><br><span class="line">function getUserInfo(user:&#123;name:string,age:number&#125;) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo(&#123;name: &#x27;poetries&#x27;, age: 22&#125;)</span><br><span class="line"></span><br><span class="line">// 这样看挺完美的， 那么问题就出现了，如果我另外还有一个方法，也是需要这个规范呢？</span><br><span class="line"></span><br><span class="line">function getUserInfo1(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo(user:&#123;name:string,age:number&#125;)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo1(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 可以看出，函数getUserInfo和getInfo都遵循同一个规范，那么我们有办法对这个规范复用吗？</span><br><span class="line"></span><br><span class="line">// 首先把需要复用的规范，写到接口 关键字interface</span><br><span class="line">interface infoInterface &#123;</span><br><span class="line">    name: string,</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">// 然后把这个接口 替换到我们需要复用的地方</span><br><span class="line">function getUserInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo2(user:infoInterface) &#123;</span><br><span class="line">    console.log(user.name,user.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line">getInfo2(&#123;name:&quot;poetries&quot;,age:22&#125;)</span><br><span class="line"></span><br><span class="line">// 那么有些参数可传可不传，该怎么处理呢？</span><br><span class="line"></span><br><span class="line">interface infoInterface2&#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">    city?:string;</span><br><span class="line">&#125;</span><br><span class="line">function getUserInfo3(user:infoInterface2)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125; $&#123;user.city&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">function getInfo3(user:infoInterface)&#123;</span><br><span class="line">    console.log(`$&#123;user.name&#125; $&#123;user.age&#125;`)</span><br><span class="line">&#125;</span><br><span class="line">getUserInfo3(&#123;name:&quot;poetries&quot;,age:22,city:&quot;深圳&quot;&#125;)</span><br><span class="line">getInfo3(&#123;name:&quot;iamswr&quot;,age:22&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-2-接口规范函数"><a href="#5-2-接口规范函数" class="headerlink" title="5.2 接口规范函数"></a>5.2 接口规范函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 对一个函数的参数和返回值进行规范</span><br><span class="line">interface mytotal &#123;</span><br><span class="line">    // 左侧是函数的参数，右侧是函数的返回类型</span><br><span class="line">    (a:number,b:number):number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let totalSum:mytotal = function(a:number,b:number):number &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(totalSum(10, 20))</span><br></pre></td></tr></table></figure><h3 id="5-3-接口规范数组"><a href="#5-3-接口规范数组" class="headerlink" title="5.3 接口规范数组"></a>5.3 接口规范数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface userInterface &#123;</span><br><span class="line">    // index为数组索引 类型是number</span><br><span class="line">    // 右边是数组里为字符串的数组成员</span><br><span class="line">    [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line">let arrTest: userInterface = [&#x27;poetries&#x27;, &#x27;静观流叶&#x27;]</span><br><span class="line"></span><br><span class="line">console.log(arrTest)</span><br></pre></td></tr></table></figure><h3 id="5-4-接口规范类"><a href="#5-4-接口规范类" class="headerlink" title="5.4 接口规范类"></a>5.4 接口规范类</h3><blockquote><p>这个比较重要，因为写<code>react</code>的时候会经常使用到类</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// 首先实现一个接口</span><br><span class="line">interface Animal2 &#123;</span><br><span class="line">    // 这个类必须有name</span><br><span class="line">    name:string;</span><br><span class="line"></span><br><span class="line">    // 这个类必须有eat方法</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关键字implements实现</span><br><span class="line">// 因为接口是抽象的，需要通过子类是实现它</span><br><span class="line"></span><br><span class="line">class Person6 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 如果想遵循多个接口</span><br><span class="line"></span><br><span class="line">interface Animal3 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    eat(any: string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 新增一个接口</span><br><span class="line">interface Animal4 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 可以在implements后面通过逗号添加和java一样</span><br><span class="line">class Person7 implements Animal3,Animal4 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string) &#123;</span><br><span class="line">        console.log(`吃`+any)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep() &#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-接口继承接口"><a href="#5-5-接口继承接口" class="headerlink" title="5.5 接口继承接口"></a>5.5 接口继承接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">interface Animal5&#123;</span><br><span class="line">    name:string;</span><br><span class="line">    eat(any:string):void;</span><br><span class="line">&#125;</span><br><span class="line">// 像类一样 通过extends继承</span><br><span class="line">interface Animal6 extends Animal5 &#123;</span><br><span class="line">    sleep():void;</span><br><span class="line">&#125;</span><br><span class="line">// 因为Animal6类继承了Animal5</span><br><span class="line">// 所以这里遵循Animal6就相当于把Animal5也继承了</span><br><span class="line"></span><br><span class="line">class Person8 implements Animal2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    constructor(name:string) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    eat(any:string):void&#123;</span><br><span class="line">        console.log(`吃$&#123;any&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    sleep()&#123;</span><br><span class="line">        console.log(&#x27;睡觉&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、泛型"><a href="#六、泛型" class="headerlink" title="六、泛型"></a>六、泛型</h2><h3 id="6-1-函数的泛型"><a href="#6-1-函数的泛型" class="headerlink" title="6.1 函数的泛型"></a>6.1 函数的泛型</h3><blockquote><p>泛型可以支持不特定的数据类型，什么叫不特定呢？比如我们有一个方法，里面接收参数，但是参数类型我们是不知道，但是这个类型在方法里面很多地方会用到，参数和返回值要保持一致性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 假设我们有一个需求，我们不知道函数接收什么类型的参数，也不知道返回值的类型</span><br><span class="line">// 而我们又需要传进去的参数类型和返回值的类型保持一致，那么我们就需要用到泛型</span><br><span class="line"></span><br><span class="line">// &lt;T&gt;的意思是泛型，即generic type</span><br><span class="line">// 可以看出value的类型也为T，返回值的类型也为T</span><br><span class="line">function deal&lt;T&gt;(value:T):T&#123;</span><br><span class="line">    return value</span><br><span class="line">&#125;</span><br><span class="line">// 下面的&lt;string&gt;、&lt;number&gt;实际上用的时候再传给上面的&lt;T&gt;</span><br><span class="line">console.log(deal&lt;string&gt;(&quot;poetries&quot;))</span><br><span class="line">console.log(deal&lt;number&gt;(22))</span><br></pre></td></tr></table></figure><blockquote><p>实际上，泛型用得还是比较少，主要是看类的泛型是如何使用的</p></blockquote><h3 id="6-2-类的泛型"><a href="#6-2-类的泛型" class="headerlink" title="6.2 类的泛型"></a>6.2 类的泛型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyMath&lt;T&gt; &#123;</span><br><span class="line">    // 定义一个私有属性</span><br><span class="line"></span><br><span class="line">    private arr: T[] = []</span><br><span class="line"></span><br><span class="line">    // 规定传参类型</span><br><span class="line">    add(value: T) &#123;</span><br><span class="line">        this.arr.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这里规定了类型为number</span><br><span class="line">// 相当于把T替换为number</span><br><span class="line"></span><br><span class="line">let mymath = new MyMath&lt;number&gt;()</span><br><span class="line">mymath.add(1)</span><br><span class="line">mymath.add(2)</span><br><span class="line">mymath.add(3)</span><br></pre></td></tr></table></figure><p><strong>有了接口为什么还需要抽象类？</strong></p><blockquote><p>接口里面只能放定义，抽象类里面可以放普通类、普通类的方法、定义抽象的东西。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、typescript-安装&quot;&gt;&lt;a href=&quot;#一、typescript-安装&quot; class=&quot;headerlink&quot; title=&quot;一、typescript 安装&quot;&gt;&lt;/a&gt;一、typescript 安装&lt;/h2&gt;&lt;figure class=&quot;highli</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>TS-interface与type区别</title>
    <link href="http://example.com/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2021/07/25/html+css+js+ts/5-Ts-interface%E4%B8%8Etype%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-25T08:20:43.000Z</published>
    <updated>2022-06-07T00:41:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h2><h3 id="都可以描述一个对象或者函数"><a href="#都可以描述一个对象或者函数" class="headerlink" title="都可以描述一个对象或者函数"></a>都可以描述一个对象或者函数</h3><p><strong>interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SetUser &#123;</span><br><span class="line">  (name: string, age: number): void;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>type</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type User = &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type SetUser = (name: string, age: number)=&gt; void;</span><br></pre></td></tr></table></figure><h3 id="都允许拓展（extends）"><a href="#都允许拓展（extends）" class="headerlink" title="都允许拓展（extends）"></a>都允许拓展（extends）</h3><blockquote><p><code>interface</code> 和 <code>type</code> 都可以拓展，并且两者并不是相互独立的，也就是说 <code>interface</code> 可以 <code>extends type</code>, <code>type</code> 也可以 <code>extends interface</code> 。 虽然效果差不多，但是两者语法不同</p></blockquote><p><strong>interface extends interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>type extends type</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; age: number  &#125;;</span><br></pre></td></tr></table></figure><p><strong>interface extends type</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type Name = &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">interface User extends Name &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>type extends interface</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123; </span><br><span class="line">  name: string; </span><br><span class="line">&#125;</span><br><span class="line">type User = Name &amp; &#123; </span><br><span class="line">  age: number; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h2><h3 id="type-可以而-interface-不行"><a href="#type-可以而-interface-不行" class="headerlink" title="type 可以而 interface 不行"></a>type 可以而 interface 不行</h3><blockquote><p>type 可以声明基本类型别名，联合类型，元组等类型</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 基本类型别名</span><br><span class="line">type Name = string</span><br><span class="line"></span><br><span class="line">// 联合类型</span><br><span class="line">interface Dog &#123;</span><br><span class="line">    wong();</span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">    miao();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pet = Dog | Cat</span><br><span class="line"></span><br><span class="line">// 具体定义数组每个位置的类型</span><br><span class="line">type PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure><p><strong>type 语句中还可以使用 typeof 获取实例的 类型进行赋值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 当你想获取一个变量的类型时，使用 typeof</span><br><span class="line">let div = document.createElement(&#x27;div&#x27;);</span><br><span class="line">type B = typeof div</span><br></pre></td></tr></table></figure><p><strong>其他骚操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type StringOrNumber = string | number;  </span><br><span class="line">type Text = string | &#123; text: string &#125;;  </span><br><span class="line">type NameLookup = Dictionary&lt;string, Person&gt;;  </span><br><span class="line">type Callback&lt;T&gt; = (data: T) =&gt; void;  </span><br><span class="line">type Pair&lt;T&gt; = [T, T];  </span><br><span class="line">type Coordinates = Pair&lt;number&gt;;  </span><br><span class="line">type Tree&lt;T&gt; = T | &#123; left: Tree&lt;T&gt;, right: Tree&lt;T&gt; &#125;;</span><br></pre></td></tr></table></figure><h3 id="interface-可以而-type-不行"><a href="#interface-可以而-type-不行" class="headerlink" title="interface 可以而 type 不行"></a>interface 可以而 type 不行</h3><blockquote><p><code>interface</code> 能够声明合并</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface User &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface User &#123;</span><br><span class="line">  sex: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">User 接口为 &#123;</span><br><span class="line">  name: string</span><br><span class="line">  age: number</span><br><span class="line">  sex: string </span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><blockquote><p>如果不清楚什么时候用<code>interface/type</code>，能用 <code>interface</code> 实现，就用 <code>interface</code> , 如果不能就用 <code>type</code></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相同之处&quot;&gt;&lt;a href=&quot;#相同之处&quot; class=&quot;headerlink&quot; title=&quot;相同之处&quot;&gt;&lt;/a&gt;相同之处&lt;/h2&gt;&lt;h3 id=&quot;都可以描述一个对象或者函数&quot;&gt;&lt;a href=&quot;#都可以描述一个对象或者函数&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="typescript" scheme="http://example.com/tags/typescript/"/>
    
  </entry>
  
  <entry>
    <title>Graphviz绘制流程图</title>
    <link href="http://example.com/2021/07/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Graphviz%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>http://example.com/2021/07/16/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/Graphviz%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE/</id>
    <published>2021-07-16T15:08:47.000Z</published>
    <updated>2022-06-07T00:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、初识Graphviz"><a href="#一、初识Graphviz" class="headerlink" title="一、初识Graphviz"></a>一、初识Graphviz</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><blockquote><p><code>GraphViz</code>是一个开源的图像可视化的软件，是贝尔实验室开发的一个开源的工具包，它使用一个特定的<code>DSL</code>(领域特定语言): <code>dot</code>作为脚本语言，然后使用布局引擎来解析此脚本，并完成自动布局。<code>graphviz</code>提供丰富的导出格式，如常用的图片格式，<code>SVG</code>，<code>PDF</code>格式等</p></blockquote><h3 id="1-2-环境搭建"><a href="#1-2-环境搭建" class="headerlink" title="1.2 环境搭建"></a>1.2 环境搭建</h3><p><strong>结合sublime Text插件实时编译预览</strong></p><blockquote><p>使用<code>shift+command+p</code>，输入搜索选中<code>Package Control: Install Package</code>,然后输入<code>GraphViz</code>,然后安装<code>GraphVizPreview</code>即可，安装完成后，只要全选中代码，然后按<code>shift+command+g</code>就可以预览了。</p></blockquote><ul><li>其实也可以直接用<code>brew</code>安装<code>GraphViz</code>,但是每次要敲命令行，太麻烦了</li></ul><p><strong><code>mac</code>下执行</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure><blockquote><p>终端编译代码 <code>dot test.dot -T png -o test.png</code></p></blockquote><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><blockquote><p><code>Graphviz</code> 支持两类图：无向图（<code>graph</code>,用“ <code>- -</code> ”表示节点之间）和 有向图（<code>digraph</code>,用“ <code>-&gt;</code>” 表示节点之间）。graphviz包含3中元素，图，顶点和边。<strong>每个元素都可以具有各自的属性，用来定义字体，样式，颜色，形状等</strong></p></blockquote><p><strong><code>GraphViz</code>中包含多种布局</strong></p><ul><li><code>dot</code> 默认布局，用于有向图</li><li><code>neato</code> 基于<code>spring-model</code>算法(<code>force-based</code>)</li><li><code>twopo</code> 径向布局</li><li><code>circo</code> 圆形布局</li><li><code>fdp</code> 用于无向图</li></ul><h3 id="2-1-第一个graphviz图"><a href="#2-1-第一个graphviz图" class="headerlink" title="2.1 第一个graphviz图"></a>2.1 第一个graphviz图</h3><blockquote><p>语法介绍 <a href="http://graphs.grevian.org/reference">http://graphs.grevian.org/reference</a></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  a;</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/208.png" alt="img"></p><p><strong>定义顶点和边的样式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  node [shape=&quot;record&quot;];</span><br><span class="line">  edge [style=&quot;dashed&quot;];</span><br><span class="line">  a;</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1124873-67688cd634d43522.png" alt="img"></p><blockquote><p>进一步修改顶点和边样式,将顶点<code>a</code>的颜色改为淡绿色，并将<code>c</code>到<code>d</code>的边改为红色</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">digraph abc&#123;</span><br><span class="line">  node [shape=&quot;record&quot;];</span><br><span class="line">  edge [style=&quot;dashed&quot;];</span><br><span class="line"> </span><br><span class="line">  a [style=&quot;filled&quot;, color=&quot;black&quot;, fillcolor=&quot;chartreuse&quot;];</span><br><span class="line">  b;</span><br><span class="line">  c;</span><br><span class="line">  d;</span><br><span class="line"> </span><br><span class="line">  a -&gt; b;</span><br><span class="line">  b -&gt; d;</span><br><span class="line">  c -&gt; d [color=&quot;red&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/209.png" alt="img"></p><p>其他例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">  label=&quot;儿茶酚胺合成代谢路径&quot;;</span><br><span class="line"></span><br><span class="line">  酪氨酸 -&gt; L多巴 -&gt; 多巴胺 -&gt; 去甲肾上腺素 -&gt; 肾上腺素;</span><br><span class="line"></span><br><span class="line">  下丘脑 -&gt; 多巴胺;</span><br><span class="line">  交感神经元 -&gt; 去甲肾上腺素;</span><br><span class="line">  肾上腺髓质 -&gt; 去甲肾上腺素,肾上腺素;</span><br><span class="line"></span><br><span class="line">  酪氨酸 [label=&quot;酪氨酸&quot;,color=green];</span><br><span class="line">  多巴胺 [label=&quot;多巴胺&quot;, color=red];</span><br><span class="line">  肾上腺素 [label=&quot;肾上腺素&quot;, color=red];</span><br><span class="line"></span><br><span class="line">  下丘脑 [shape=box];</span><br><span class="line">  交感神经元 [shape=box];</span><br><span class="line">  肾上腺髓质 [shape=box];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/210.png" alt="img"></p><h3 id="2-2-带标签"><a href="#2-2-带标签" class="headerlink" title="2.2 带标签"></a>2.2 带标签</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    player[label = &quot;player&quot;, color = Blue, fontcolor = Red, fontsize = 24, shape = box];</span><br><span class="line">    game[label = &quot;game&quot;, color = Red, fontcolor = Blue, fontsize = 24, shape = ellipse];</span><br><span class="line"></span><br><span class="line">    player -&gt; game[label = &quot;play&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/211.jpg" alt="img"></p><h3 id="2-3-子视图"><a href="#2-3-子视图" class="headerlink" title="2.3 子视图"></a>2.3 子视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    label = visitNet</span><br><span class="line"></span><br><span class="line">    rankdir = LR</span><br><span class="line"></span><br><span class="line">    node[color = Red, fontsize = 24, shape = box]</span><br><span class="line">    edge[color = Blue, style = &quot;dashed&quot;]</span><br><span class="line"></span><br><span class="line">    user[style = &quot;filled&quot;, color = &quot;yellow&quot;, fillcolor = &quot;chartreuse&quot;]</span><br><span class="line">    subgraph cluster_cd&#123;</span><br><span class="line">        label = &quot;server and browser&quot;</span><br><span class="line">        bgcolor = green;</span><br><span class="line"></span><br><span class="line">        browser -&gt; server</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    user -&gt; computer;</span><br><span class="line">    computer -&gt; browser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/212.jpg" alt="img"></p><h3 id="2-4-结构视图"><a href="#2-4-结构视图" class="headerlink" title="2.4 结构视图"></a>2.4 结构视图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    node[shape = record];</span><br><span class="line">    struct1[label = &quot;&lt;f0&gt; left|&lt;f1&gt; mid&amp;#92; dle|&lt;f2&gt; right&quot;];</span><br><span class="line">    struct2[label = &quot;&lt;f0&gt; one|&lt;f1&gt; two&quot;];</span><br><span class="line">    struct3[label = &quot;hello&amp;#92;nworld | &#123;b|&#123;c|&lt;here&gt; d|e&#125;|f&#125;|g|h&quot;];</span><br><span class="line">    struct1:f1 -&gt; struct2:f0;</span><br><span class="line">    struct1:f2 -&gt; struct3:here;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/213.jpg" alt="img"></p><h3 id="2-5-树形结构"><a href="#2-5-树形结构" class="headerlink" title="2.5 树形结构"></a>2.5 树形结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph tree &#123;</span><br><span class="line">  </span><br><span class="line">  fontname = &quot;PingFang-SC-Light&quot;</span><br><span class="line">  fontsize = 24</span><br><span class="line"></span><br><span class="line">  node[shape = &quot;plaintext&quot;]</span><br><span class="line"></span><br><span class="line">  1 -&gt; 2;</span><br><span class="line">  1 -&gt; 3;</span><br><span class="line">  2 -&gt; 4;</span><br><span class="line">  2 -&gt; 5;</span><br><span class="line">  3 -&gt; 6;</span><br><span class="line">  3 -&gt; 7;</span><br><span class="line">  4 -&gt; 8;</span><br><span class="line">  4 -&gt; 9;</span><br><span class="line">  5 -&gt; 10;</span><br><span class="line">  5 -&gt; 11;</span><br><span class="line">  6 -&gt; 12;</span><br><span class="line">  6 -&gt; 13;</span><br><span class="line">  7 -&gt; 14;</span><br><span class="line">  7 -&gt; 15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/214.jpg" alt="img"></p><h3 id="2-6-时序图"><a href="#2-6-时序图" class="headerlink" title="2.6 时序图"></a>2.6 时序图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">digraph time &#123;</span><br><span class="line"></span><br><span class="line">    rankdir = &quot;LR&quot;;</span><br><span class="line">    node[shape = &quot;point&quot;, width = 0, height = 0];</span><br><span class="line">    edge[arrowhead = &quot;none&quot;, style = &quot;dashed&quot;];</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        rank = &quot;same&quot;</span><br><span class="line">        edge[style = &quot;solided&quot;];</span><br><span class="line">        APP[shape = &quot;plaintext&quot;];</span><br><span class="line">        APP -&gt; step00 -&gt; step01 -&gt; step02 -&gt; step03 -&gt; step04 -&gt; step05;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        SDK[shape=&quot;plaintext&quot;];</span><br><span class="line">        SDK -&gt; step10 -&gt; step11 -&gt; step12 -&gt; step13 -&gt; step14 -&gt; step15;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        AliPay[shape=&quot;plaintext&quot;];</span><br><span class="line">        AliPay -&gt; step20 -&gt; step21 -&gt; step22 -&gt; step23 -&gt; step24 -&gt; step25;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        rank=&quot;same&quot;;</span><br><span class="line">        edge[style=&quot;solided&quot;];</span><br><span class="line">        Server[shape=&quot;plaintext&quot;];</span><br><span class="line">        Server -&gt; step30 -&gt; step31 -&gt; step32 -&gt; step33 -&gt; step34 -&gt; step35;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    step00 -&gt; step10 [label=&quot;sends order info&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step11 -&gt; step21 [label=&quot;open AliPay&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step22 -&gt; step12 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step13 -&gt; step03 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">    step24 -&gt; step34 [label=&quot;pay success&quot;, arrowhead=&quot;normal&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/215.jpg" alt="img"></p><h3 id="2-7-一个hash表的数据结构"><a href="#2-7-一个hash表的数据结构" class="headerlink" title="2.7 一个hash表的数据结构"></a>2.7 一个hash表的数据结构</h3><blockquote><p><code>hash</code>表内容</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct st_hash_type &#123;</span><br><span class="line">    int (*compare) ();</span><br><span class="line">    int (*hash) ();</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct st_table_entry &#123;</span><br><span class="line">    unsigned int hash;</span><br><span class="line">    char *key;</span><br><span class="line">    char *record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct st_table &#123;</span><br><span class="line">    struct st_hash_type *type;</span><br><span class="line">    int num_bins;</span><br><span class="line">/* slot count */</span><br><span class="line">    int num_entries;</span><br><span class="line">/* total number of entries */</span><br><span class="line">    struct st_table_entry **bins;</span><br><span class="line">/* slot */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph st2&#123;</span><br><span class="line">  fontname = &quot;Verdana&quot;;</span><br><span class="line">  fontsize = 10;</span><br><span class="line">  rankdir=TB;</span><br><span class="line"> </span><br><span class="line">  node [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;skyblue&quot;, shape=&quot;record&quot;];</span><br><span class="line"> </span><br><span class="line">  edge [fontname = &quot;Verdana&quot;, fontsize = 10, color=&quot;crimson&quot;, style=&quot;solid&quot;];</span><br><span class="line"> </span><br><span class="line">  st_hash_type [label=&quot;&#123;&lt;head&gt;st_hash_type|(*compare)|(*hash)&#125;&quot;];</span><br><span class="line">  st_table_entry [label=&quot;&#123;&lt;head&gt;st_table_entry|hash|key|record|&lt;next&gt;next&#125;&quot;];</span><br><span class="line">  st_table [label=&quot;&#123;st_table|&lt;type&gt;type|num_bins|num_entries|&lt;bins&gt;bins&#125;&quot;];</span><br><span class="line"> </span><br><span class="line">  st_table:bins -&gt; st_table_entry:head;</span><br><span class="line">  st_table:type -&gt; st_hash_type:head;</span><br><span class="line">  st_table_entry:next -&gt; st_table_entry:head [style=&quot;dashed&quot;, color=&quot;forestgreen&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/216.jpg" alt="img"></p><h3 id="2-8-模块的生命周期图"><a href="#2-8-模块的生命周期图" class="headerlink" title="2.8 模块的生命周期图"></a>2.8 模块的生命周期图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">digraph module_lc&#123;</span><br><span class="line">  rankdir=TB;</span><br><span class="line">  fontname = &quot;Microsoft YaHei&quot;;</span><br><span class="line">  fontsize = 12;</span><br><span class="line"> </span><br><span class="line">  node [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, shape = &quot;Mrecord&quot;, color=&quot;skyblue&quot;, style=&quot;filled&quot;];</span><br><span class="line">  edge [fontname = &quot;Microsoft YaHei&quot;, fontsize = 12, color=&quot;darkgreen&quot; ];</span><br><span class="line"> </span><br><span class="line">  installed [label=&quot;已安装状态&quot;];</span><br><span class="line">  resolved [label=&quot;已就绪状态&quot;];</span><br><span class="line">  uninstalled [label=&quot;已卸载状态&quot;];</span><br><span class="line">  starting [label=&quot;正在启动&quot;];</span><br><span class="line">  active [label=&quot;已激活(运行)状态&quot;];</span><br><span class="line">  stopping [label=&quot;正在停止&quot;];</span><br><span class="line">  start [label=&quot;&quot;, shape=&quot;circle&quot;, width=0.5, fixedsize=true, style=&quot;filled&quot;, color=&quot;black&quot;];</span><br><span class="line"> </span><br><span class="line">  start -&gt; installed [label=&quot;安装&quot;];</span><br><span class="line">  installed -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">  installed -&gt; resolved [label=&quot;准备&quot;];</span><br><span class="line">  installed -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">  resolved -&gt; installed [label=&quot;更新&quot;];</span><br><span class="line">  resolved -&gt; uninstalled [label=&quot;卸载&quot;];</span><br><span class="line">  resolved -&gt; starting [label=&quot;启动&quot;];</span><br><span class="line">  starting -&gt; active [label=&quot;&quot;];</span><br><span class="line">  active -&gt; stopping [label=&quot;停止&quot;];</span><br><span class="line">  stopping -&gt; resolved [label=&quot;&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/217.jpg" alt="img"></p><h3 id="2-9-简单的UML类图"><a href="#2-9-简单的UML类图" class="headerlink" title="2.9 简单的UML类图"></a>2.9 简单的UML类图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">digraph G&#123;</span><br><span class="line"> </span><br><span class="line">  fontname = &quot;Courier New&quot;</span><br><span class="line">  fontsize = 10</span><br><span class="line"> </span><br><span class="line">  node [ fontname = &quot;Courier New&quot;, fontsize = 10, shape = &quot;record&quot; ];</span><br><span class="line">  edge [ fontname = &quot;Courier New&quot;, fontsize = 10 ];</span><br><span class="line"> </span><br><span class="line">  Animal [ label = &quot;&#123;Animal |+ name : String\\l+ age : int\\l|+ die() : void\\l&#125;&quot; ];</span><br><span class="line"> </span><br><span class="line">      subgraph clusterAnimalImpl&#123;</span><br><span class="line">          bgcolor=&quot;yellow&quot;</span><br><span class="line">          Dog [ label = &quot;&#123;Dog||+ bark() : void\\l&#125;&quot; ];</span><br><span class="line">          Cat [ label = &quot;&#123;Cat||+ meow() : void\\l&#125;&quot; ];</span><br><span class="line">      &#125;;</span><br><span class="line"> </span><br><span class="line">  edge [ arrowhead = &quot;empty&quot; ];</span><br><span class="line"> </span><br><span class="line">  Dog-&gt;Animal;</span><br><span class="line">  Cat-&gt;Animal;</span><br><span class="line">  Dog-&gt;Cat [arrowhead=&quot;none&quot;, label=&quot;0..*&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/218.jpg" alt="img"></p><h3 id="2-10-有限状态机"><a href="#2-10-有限状态机" class="headerlink" title="2.10 有限状态机"></a>2.10 有限状态机</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">digraph finite_state_machine &#123;</span><br><span class="line">    rankdir=LR;</span><br><span class="line">    size=&quot;8,5&quot;</span><br><span class="line">    node [shape = circle];</span><br><span class="line">    S0 -&gt; S1 [ label = &quot;Lift Nozzle&quot; ]</span><br><span class="line">    S1 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]</span><br><span class="line">    S1 -&gt; S2 [ label = &quot;Authorize Pump&quot; ]</span><br><span class="line">    S2 -&gt; S0 [ label = &quot;Replace Nozzle&quot; ]</span><br><span class="line">    S2 -&gt; S3 [ label = &quot;Pull Trigger&quot; ]</span><br><span class="line">    S3 -&gt; S2 [ label = &quot;Release Trigger&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://img2.tuicool.com/yEze6z.png%21web" alt="img"></p><h2 id="三、语法"><a href="#三、语法" class="headerlink" title="三、语法"></a>三、语法</h2><blockquote><p>完整列表 <a href="http://graphviz.org/doc/info/attrs.html">http://graphviz.org/doc/info/attrs.html</a></p></blockquote><h3 id="3-1-图像属性"><a href="#3-1-图像属性" class="headerlink" title="3.1 图像属性"></a>3.1 图像属性</h3><ul><li><code>label=&quot;My Graph&quot;;</code> 给图像设置标签</li><li><code>rankdir=LR</code>; 将图片由原来的从上到下布局变成从左到右布局</li><li><code>&#123;rank=same; a, b, c &#125;</code> 将一组元素放到同一个<code>level</code></li><li><code>splines=&quot;line&quot;</code>; 让边框变为直线，没有曲线和锐角</li><li><code>K=0.6</code>; 用来在布局中影响<code>spring</code>属性，<code>spring</code>属性可以用于将节点往外推，这个在<code>twopi</code>和<code>sfdp</code>布局中很有用。</li></ul><h3 id="3-2-交点属性"><a href="#3-2-交点属性" class="headerlink" title="3.2 交点属性"></a>3.2 交点属性</h3><ul><li><code>[label=&quot;Some Label&quot;]</code> 给交点打标签</li><li><code>[color=&quot;red&quot;]</code> 给交点上色</li><li><code>[fillcolor=&quot;blue&quot;]</code> 设置交点的填充色</li></ul><h3 id="3-3-边的属性"><a href="#3-3-边的属性" class="headerlink" title="3.3 边的属性"></a>3.3 边的属性</h3><ul><li><code>[label=&quot;Some Label&quot;]</code> 给边设置标签 (设置路径权重的时候很有用)</li><li><code>[color=&quot;red&quot;]</code> # 给交点上色 (标示路径的时候很有用)</li><li><code>[penwidth=2.0]</code> # 给边适配厚度，标示路径的时候很有用。</li></ul><h3 id="3-4-尺寸-背景颜色"><a href="#3-4-尺寸-背景颜色" class="headerlink" title="3.4 尺寸, 背景颜色"></a>3.4 尺寸, 背景颜色</h3><ul><li><code>fixedsize=true</code>;</li><li><code>size=&quot;1,1&quot;</code>;</li><li><code>resolution=72</code>;</li><li><code>bgcolor=&quot;#C6CFD532&quot;</code>;</li></ul><h2 id="四、一些技巧"><a href="#四、一些技巧" class="headerlink" title="四、一些技巧"></a>四、一些技巧</h2><h3 id="4-1-插入图片"><a href="#4-1-插入图片" class="headerlink" title="4.1 插入图片"></a>4.1 插入图片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    c[shape = none, image = &quot;./pic.png&quot;]</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/219.jpg" alt="img"></p><blockquote><p>注：需要用命令行<code>dot test.dot -T png -o test.png</code>生成，前提是用<code>brew</code>安装了<code>GraphViz</code></p></blockquote><h3 id="4-2-统一节点和连线"><a href="#4-2-统一节点和连线" class="headerlink" title="4.2 统一节点和连线"></a>4.2 统一节点和连线</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">digraph &#123;</span><br><span class="line"></span><br><span class="line">    node[color = Red, fontsize = 24, shape = box]</span><br><span class="line">    edge[color = Blue, style = &quot;dashed&quot;]</span><br><span class="line"></span><br><span class="line">    c[shape = none, image = &quot;./pic.png&quot;]</span><br><span class="line">    a -&gt; b -&gt; c;</span><br><span class="line">    c -&gt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://poetries1.gitee.io/img-repo/2019/10/220.jpg" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、初识Graphviz&quot;&gt;&lt;a href=&quot;#一、初识Graphviz&quot; class=&quot;headerlink&quot; title=&quot;一、初识Graphviz&quot;&gt;&lt;/a&gt;一、初识Graphviz&lt;/h2&gt;&lt;h3 id=&quot;1-1-简介&quot;&gt;&lt;a href=&quot;#1-1-简介&quot;</summary>
      
    
    
    
    <category term="数据可视化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="Graphviz" scheme="http://example.com/tags/Graphviz/"/>
    
  </entry>
  
  <entry>
    <title>echart使用小结</title>
    <link href="http://example.com/2021/06/23/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2021/06/23/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/echart%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2021-06-23T11:34:07.000Z</published>
    <updated>2022-06-07T00:40:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>十一个组件选项主要用来进行交互</p></blockquote><h2 id="一、Timeline选项"><a href="#一、Timeline选项" class="headerlink" title="一、Timeline选项"></a>一、Timeline选项</h2><ul><li>时间轴，每个图表最多仅有一个时间轴控件</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/45.png" alt="img"></p><h2 id="二、Title选项"><a href="#二、Title选项" class="headerlink" title="二、Title选项"></a>二、Title选项</h2><ul><li>每个图表最多仅有一个标题控件，每个标题控件可设主副标题</li></ul><blockquote><p>可以对标题文字的大小样式进行设置</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/46.png" alt="img"></p><h2 id="三、toolbox"><a href="#三、toolbox" class="headerlink" title="三、toolbox"></a>三、toolbox</h2><ul><li>工具箱，每个图表最多仅有一个工具箱。工具箱里面可以实现图表类型的切换，保存图片，刷新，查看数据等功能。可以对其像素进行设置</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/47.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    mark : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            mark : &#x27;辅助线开关&#x27;,</span><br><span class="line"></span><br><span class="line">            markUndo : &#x27;删除辅助线&#x27;,</span><br><span class="line"></span><br><span class="line">            markClear : &#x27;清空辅助线&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        lineStyle : &#123;</span><br><span class="line"></span><br><span class="line">            width : 2,</span><br><span class="line"></span><br><span class="line">            color : &#x27;#1e90ff&#x27;,</span><br><span class="line"></span><br><span class="line">            type : &#x27;dashed&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataZoom : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            dataZoom : &#x27;区域缩放&#x27;,</span><br><span class="line"></span><br><span class="line">            dataZoomReset : &#x27;区域缩放后退&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    dataView : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;数据视图&#x27;,</span><br><span class="line"></span><br><span class="line">        readOnly: false,</span><br><span class="line"></span><br><span class="line">        lang: [&#x27;数据视图&#x27;, &#x27;关闭&#x27;, &#x27;刷新&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    magicType: &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#123;</span><br><span class="line"></span><br><span class="line">            line : &#x27;折线图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            bar : &#x27;柱形图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            stack : &#x27;堆积&#x27;,</span><br><span class="line"></span><br><span class="line">            tiled : &#x27;平铺&#x27;,</span><br><span class="line"></span><br><span class="line">            force: &#x27;力导向布局图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            chord: &#x27;和弦图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            pie: &#x27;饼图切换&#x27;,</span><br><span class="line"></span><br><span class="line">            funnel: &#x27;漏斗图切换&#x27;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        option: &#123;</span><br><span class="line"></span><br><span class="line">            // line: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // bar: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // stack: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // tiled: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // force: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // chord: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // pie: &#123;...&#125;,</span><br><span class="line"></span><br><span class="line">            // funnel: &#123;...&#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        type : []</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    restore : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;还原&#x27;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    saveAsImage : &#123;</span><br><span class="line"></span><br><span class="line">        show : false,</span><br><span class="line"></span><br><span class="line">        title : &#x27;保存为图片&#x27;,</span><br><span class="line"></span><br><span class="line">        type : &#x27;png&#x27;,</span><br><span class="line"></span><br><span class="line">        lang : [&#x27;点击保存&#x27;]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、tooltip"><a href="#四、tooltip" class="headerlink" title="四、tooltip"></a>四、tooltip</h2><ul><li>提示框，鼠标悬浮交互时的信息提示</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/48.png" alt="img"></p><h2 id="五、legend"><a href="#五、legend" class="headerlink" title="五、legend"></a>五、legend</h2><ul><li>图例，每个图表最多仅有一个图例，混搭图表共享</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/49.png" alt="img"></p><h2 id="六、dataRange"><a href="#六、dataRange" class="headerlink" title="六、dataRange"></a>六、dataRange</h2><ul><li>值域选择，每个图表最多仅有一个值域控件</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/50.png" alt="img"></p><h2 id="七、dataZoom"><a href="#七、dataZoom" class="headerlink" title="七、dataZoom"></a>七、dataZoom</h2><ul><li><a href="http://echarts.baidu.com/echarts2/doc/example/dataZoom.html">数据区域缩放</a>。与toolbox.feature.dataZoom同步，仅对直角坐标系图表有效</li></ul><h2 id="roamController"><a href="#roamController" class="headerlink" title="roamController"></a>roamController</h2><ul><li><a href="http://echarts.baidu.com/echarts2/doc/example/map1.html">缩放漫游组件</a>，仅对地图有效</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/51.png" alt="img"></p><h2 id="八、grid"><a href="#八、grid" class="headerlink" title="八、grid"></a>八、grid</h2><blockquote><p>直角坐标系内绘图网格</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/52.png" alt="img"></p><h2 id="九、xAxis"><a href="#九、xAxis" class="headerlink" title="九、xAxis"></a>九、xAxis</h2><blockquote><p>直角坐标系中横轴数组，数组中每一项代表一条横轴坐标轴，仅有一条时可省略数组。最多同时存在2条横轴，单条横轴时可指定安放于grid的底部（默认）或顶部，2条同时存在时位置互斥，默认第一条安放于底部，第二条安放于顶部</p></blockquote><h2 id="十、yAxis"><a href="#十、yAxis" class="headerlink" title="十、yAxis"></a>十、yAxis</h2><blockquote><p>直角坐标系中纵轴数组，数组中每一项代表一条纵轴坐标轴，仅有一条时可省略数组。最多同时存在2条纵轴，单条纵轴时可指定安放于grid的左侧（默认）或右侧，2条同时存在时位置互斥，默认第一条安放于左侧，第二条安放于右侧</p></blockquote><ul><li>坐标轴有三种类型，类目型、数值型和时间型，纵轴通常为数值型，但条形图时则纵轴为类目型</li></ul><h2 id="十一、series（通用）"><a href="#十一、series（通用）" class="headerlink" title="十一、series（通用）"></a>十一、series（通用）</h2><blockquote><p>驱动图表生成的数据内容数组，数组中每一项为一个系列的选项及数据，其中个别选项仅在部分图表类型中有效，请注意适用类型</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;十一个组件选项主要用来进行交互&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、Timeline选项&quot;&gt;&lt;a href=&quot;#一、Timeline选项&quot; class=&quot;headerlink&quot; title=&quot;一、Timeline选项&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="数据可视化" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    
    <category term="echart" scheme="http://example.com/tags/echart/"/>
    
  </entry>
  
  <entry>
    <title>浅谈PWA(Progressive Web App)</title>
    <link href="http://example.com/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/"/>
    <id>http://example.com/2021/06/12/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%85%E8%B0%88PWA(Progressive%20Web%20App)/</id>
    <published>2021-06-12T08:27:05.000Z</published>
    <updated>2022-06-07T00:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、初识PWA"><a href="#一、初识PWA" class="headerlink" title="一、初识PWA"></a>一、初识PWA</h1><blockquote><ul><li><code>PWA</code>，即<code>Progressive Web App</code>, 是提升 <code>Web App</code> 的体验的一种新方法，能给用户原生应用的体验。</li><li>一个 <code>PWA</code> 应用首先是一个网页, 可以通过 <code>Web</code> 技术编写出一个网页应用. 随后添加上 <code>App Manifest</code> 和 <code>Service Worker</code> 来实现<code>PWA</code> 的安装和离线等功能</li></ul></blockquote><h2 id="1-1-PWA中的一些技术"><a href="#1-1-PWA中的一些技术" class="headerlink" title="1.1 PWA中的一些技术"></a>1.1 PWA中的一些技术</h2><blockquote><p><code>PWA</code>本身其实是一个概念集合，它不是指某一项技术，而是通过一系列的<code>Web</code>技术与<code>Web</code>标准来优化<code>Web App</code>的安全、性能和体验。其中涉及到的一些技术概念包括了</p></blockquote><ul><li><code>Web App Manifest</code></li><li><code>Service Worker</code></li><li><code>Cache API</code> 缓存</li><li><code>Push、Notification</code> 推送与通知</li><li><code>Background Sync</code>后台同步</li><li>响应式设计</li></ul><h2 id="1-2-解决了哪些问题"><a href="#1-2-解决了哪些问题" class="headerlink" title="1.2 解决了哪些问题"></a>1.2 解决了哪些问题</h2><ul><li>可以添加至主屏幕，点击主屏幕图标可以实现启动动画以及隐藏地址栏</li><li>实现离线缓存功能，即使用户手机没有网络，依然可以使用一些离线功能</li><li>实现了消息推送</li></ul><h2 id="1-3-PWA存在的问题"><a href="#1-3-PWA存在的问题" class="headerlink" title="1.3 PWA存在的问题"></a>1.3 PWA存在的问题</h2><ul><li>支持率不高:现在<code>ios</code>手机端不支持<code>pwa</code>，<code>IE</code>也暂时不支持<br><code>Chrome</code>在中国桌面版占有率还是不错的，安卓移动端上的占有率却很低</li><li>各大厂商还未明确支持<code>pwa</code></li><li>依赖的<code>GCM</code>服务在国内无法使用</li><li>微信小程序的竞争</li></ul><blockquote><p>尽管有上述的一些缺点，PWA技术仍然有很多可以使用的点。</p></blockquote><ul><li><code>service worker</code>技术实现离线缓存，可以将一些不经常更改的静态文件放到缓存中，提升用户体验。</li><li><code>service worker</code>实现消息推送，使用浏览器推送功能，吸引用户<br>渐进式开发，尽管一些浏览器暂时不支持，可以利用上述技术给使用支持浏览器的用户带来更好的体验</li></ul><h1 id="二、PWA的实现"><a href="#二、PWA的实现" class="headerlink" title="二、PWA的实现"></a>二、PWA的实现</h1><h2 id="2-1-Manifest实现添加至主屏幕"><a href="#2-1-Manifest实现添加至主屏幕" class="headerlink" title="2.1 Manifest实现添加至主屏幕"></a>2.1 Manifest实现添加至主屏幕</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;title&gt;Minimal PWA&lt;/title&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;manifest&quot; href=&quot;manifest.json&quot; /&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot;&gt;</span><br><span class="line">  &lt;link rel=&quot;icon&quot; href=&quot;/e.png&quot; type=&quot;image/png&quot; /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">// manifest.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;Minimal PWA&quot;, // 必填 显示的插件名称</span><br><span class="line">  &quot;short_name&quot;: &quot;PWA Demo&quot;, // 可选  在APP launcher和新的tab页显示，如果没有设置，则使用name</span><br><span class="line">  &quot;description&quot;: &quot;The app that helps you understand PWA&quot;, //用于描述应用</span><br><span class="line">  &quot;display&quot;: &quot;standalone&quot;, // 定义开发人员对Web应用程序的首选显示模式。standalone模式会有单独的</span><br><span class="line">  &quot;start_url&quot;: &quot;/&quot;, // 应用启动时的url</span><br><span class="line">  &quot;theme_color&quot;: &quot;#313131&quot;, // 桌面图标的背景色</span><br><span class="line">  &quot;background_color&quot;: &quot;#313131&quot;, // 为web应用程序预定义的背景颜色。在启动web应用程序和加载应用程序的内容之间创建了一个平滑的过渡。</span><br><span class="line">  &quot;icons&quot;: [ // 桌面图标，是一个数组</span><br><span class="line">    &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres.webp&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;,  // 以空格分隔的图片尺寸</span><br><span class="line">    &quot;type&quot;: &quot;image/webp&quot;  // 帮助userAgent快速排除不支持的类型</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/lowres&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;48x48&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.ico&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72 96x96 128x128 256x256&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;src&quot;: &quot;icon/hd_hi.svg&quot;,</span><br><span class="line">    &quot;sizes&quot;: &quot;72x72&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><code>Manifest</code>参考文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/Manifest">https://developer.mozilla.org/zh-CN/docs/Web/Manifest</a></li><li>如果用的是安卓手机，可以下载chrome浏览器自己操作看看</li></ul></blockquote><h2 id="2-2-service-worker实现离线缓存"><a href="#2-2-service-worker实现离线缓存" class="headerlink" title="2.2 service worker实现离线缓存"></a>2.2 service worker实现离线缓存</h2><h3 id="2-2-1-什么是service-worker"><a href="#2-2-1-什么是service-worker" class="headerlink" title="2.2.1 什么是service worker"></a>2.2.1 什么是service worker</h3><blockquote><p><code>Service Worker</code> 是 Chrome 团队提出和力推的一个 WEB API，用于给 web 应用提供高级的可持续的后台处理能力</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/401.png" alt="img"></p><blockquote><p><code>Service Workers</code> 就像介于服务器和网页之间的拦截器，能够拦截进出的HTTP 请求，从而完全控制你的网站</p></blockquote><h3 id="2-2-2-最主要的特点"><a href="#2-2-2-最主要的特点" class="headerlink" title="2.2.2 最主要的特点"></a>2.2.2 最主要的特点</h3><ul><li>在页面中注册并安装成功后，运行于浏览器后台，不受页面刷新的影响，可以监听和截拦作用域范围内所有页面的 <code>HTTP</code> 请求。</li><li>网站必须使用 <code>HTTPS</code>。除了使用本地开发环境调试时(如域名使用 <code>localhost</code>)</li><li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li><li>单独的作用域范围，单独的运行环境和执行线程</li><li>不能操作页面 <code>DOM</code>。但可以通过事件机制来处理</li><li>事件驱动型服务线程</li></ul><blockquote><p>为什么要求网站必须是<code>HTTPS</code>的，大概是因为<code>service worker</code>权限太大能拦截所有页面的请求，如果<code>http</code>的网站安装<code>service worker</code>很容易被攻击</p></blockquote><h3 id="2-2-3-生命周期"><a href="#2-2-3-生命周期" class="headerlink" title="2.2.3 生命周期"></a>2.2.3 生命周期</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/402.png" alt="img"></p><blockquote><p>当用户首次导航至 URL 时，服务器会返回响应的网页。</p></blockquote><ul><li>第1步:当你调用 <code>register()</code> 函数时， <code>Service Worker</code>开始下载。</li><li>第2步:在注册过程中，浏览器会下载、解析并执行 <code>Service Worker ()</code>。如果在此步骤中出现任何错误，<code>register()</code>返回的 <code>promise</code> 都会执行 <code>reject</code>操作，并且 <code>Service Worker</code> 会被废弃。</li><li>第3步:一旦 <code>Service Worker</code> 成功执行了，<code>install</code> 事件就会激活</li><li>第4步:安装完成，<code>Service Worker</code> 便会激活，并控制在其范围内的一切。如果生命周期中的所有事件都成功了，<code>Service Worker</code>便已准备就绪，随时可以使用了！</li></ul><blockquote><p><code>chrome://serviceworker-internals</code> 来了解当前浏览器中所有已安装<code>Service Worker</code>的详细情况</p></blockquote><h3 id="2-2-4-实现离线缓存"><a href="#2-2-4-实现离线缓存" class="headerlink" title="2.2.4 实现离线缓存"></a>2.2.4 实现离线缓存</h3><p><strong>HTTP缓存</strong></p><ul><li><code>Web</code> 服务器可以使用 <code>Expires</code> 首部来通知 <code>Web</code>客户端，它可以使用资源的当前副本，直到指定的“过期时间”。反过来，浏览器可以缓存此资源，并且只有在有效期满后才会再次检查新版本。使用 <code>HTTP</code> 缓存意味着你要依赖服务器来告诉你何时缓存资源和何时过期</li></ul><p><strong>service worker缓存</strong></p><ul><li><code>Service Workers</code>的强大在于它们拦截 HTTP 请求的能力<br>进入任何传入的<code>HTTP</code> 请求，并决定想要如何响应。在你的 <code>Service Worker</code> 中，可以编写逻辑来决定想要缓存的资源，以及需要满足什么条件和资源需要缓存多久。一切尽归你掌控！</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Hello Caching World!&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- Image --&gt;</span><br><span class="line">    &lt;img src=&quot;/images/hello.png&quot; /&gt;                 </span><br><span class="line">    &lt;!-- JavaScript --&gt;</span><br><span class="line">    &lt;script async src=&quot;/js/script.js&quot;&gt;&lt;/script&gt;     </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      // 注册 service worker</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;           </span><br><span class="line">        navigator.serviceWorker.register(&#x27;/service-worker.js&#x27;, &#123;scope: &#x27;/&#x27;&#125;).then(function (registration) &#123;</span><br><span class="line">          // 注册成功</span><br><span class="line">          console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope);</span><br><span class="line">        &#125;).catch(function (err) &#123;                   </span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><ul><li>注：<code>Service Worker</code>的注册路径决定了其 <code>scope</code>默认作用页面的范围。</li><li>如果 <code>service-worker.js</code>是在 <code>/sw/</code> 页面路径下，这使得该 <code>Service Worker</code> 默认只会收到 页面<code>/sw/</code> 路径下的 fetch 事件。</li><li>如果存放在网站的根路径下，则将会收到该网站的所有 <code>fetch</code>事件。</li><li>如果希望改变它的作用域，可在第二个参数设置 <code>scope</code> 范围。示例中将其改为了根目录，即对整个站点生效。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">var cacheName = &#x27;helloWorld&#x27;;     // 缓存的名称  </span><br><span class="line">// install 事件，它发生在浏览器安装并注册 Service Worker 时        </span><br><span class="line">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123; </span><br><span class="line">/* event.waitUtil 用于在安装成功之前执行一些预装逻辑</span><br><span class="line"> 但是建议只做一些轻量级和非常重要资源的缓存，减少安装失败的概率</span><br><span class="line"> 安装成功后 ServiceWorker 状态会从 installing 变为 installed */</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(cacheName)                  </span><br><span class="line">    .then(cache =&gt; cache.addAll([    // 如果所有的文件都成功缓存了，便会安装完成。如果任何文件下载失败了，那么安装过程也会随之失败。        </span><br><span class="line">      &#x27;/js/script.js&#x27;,</span><br><span class="line">      &#x27;/images/hello.png&#x27;</span><br><span class="line">    ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">  </span><br><span class="line">/**</span><br><span class="line">为 fetch 事件添加一个事件监听器。接下来，使用 caches.match() 函数来检查传入的请求 URL 是否匹配当前缓存中存在的任何内容。如果存在的话，返回缓存的资源。</span><br><span class="line">如果资源并不存在于缓存当中，通过网络来获取资源，并将获取到的资源添加到缓存中。</span><br><span class="line">*/</span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, function (event) &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)                  </span><br><span class="line">    .then(function (response) &#123;</span><br><span class="line">      if (response) &#123;                            </span><br><span class="line">        return response;                         </span><br><span class="line">      &#125;</span><br><span class="line">      var requestToCache = event.request.clone();  //          </span><br><span class="line">      return fetch(requestToCache).then(                   </span><br><span class="line">        function (response) &#123;</span><br><span class="line">          if (!response || response.status !== 200) &#123;      </span><br><span class="line">            return response;</span><br><span class="line">          &#125;</span><br><span class="line">          var responseToCache = response.clone();          </span><br><span class="line">          caches.open(cacheName)                           </span><br><span class="line">            .then(function (cache) &#123;</span><br><span class="line">              cache.put(requestToCache, responseToCache);  </span><br><span class="line">            &#125;);</span><br><span class="line">          return response;             </span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>注：为什么用<code>request.clone()</code>和<code>response.clone()</code><br>需要这么做是因为<code>request</code>和<code>response</code>是一个流，它只能消耗一次。因为我们已经通过缓存消耗了一次，然后发起 <code>HTTP</code> 请求还要再消耗一次，所以我们需要在此时克隆请求<br>Clone the request—a request is a stream and can only be consumed once</p></blockquote><h3 id="2-2-5-调试相关"><a href="#2-2-5-调试相关" class="headerlink" title="2.2.5 调试相关"></a>2.2.5 调试相关</h3><blockquote><p>chrome浏览器打开<code>https://googlechrome.github.io/samples/service-worker/basic/index.html</code>，这是一个实现了<code>service worker</code>离线缓存功能的网站，打开调试工具</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/403.png" alt="img"></p><ul><li>勾选可以模拟网站离线情况，勾选后<code>network</code>会有一个黄色警告图标，该网站已经离线。此时刷新页面，页面仍然能够正常显示</li><li>当前<code>service worker</code>的<code>scope</code>。它能够拦截<code>https://googlechrome.github.i</code>…，同样也能够拦截<code>https://googlechrome.github.i.</code>..<em>&#x2F;</em>.html下的请求</li></ul><blockquote><p>调试面板具体代表的什么参看 <code>https://x5.tencent.com/tbs/guide/serviceworker.html</code>的第三部分</p></blockquote><h2 id="2-3-serice-worker实现消息推送"><a href="#2-3-serice-worker实现消息推送" class="headerlink" title="2.3 serice worker实现消息推送"></a>2.3 serice worker实现消息推送</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/404.png" alt="img"></p><ul><li>步骤一、提示用户并获得他们的订阅详细信息</li><li>步骤二、将这些详细信息保存在服务器上</li><li>步骤三、在需要时发送任何消息</li></ul><blockquote><p>不同浏览器需要用不同的推送消息服务器。以 Chrome 上使用 <code>Google Cloud Messaging</code> 作为推送服务为例，第一步是注册 <code>applicationServerKey</code>(通过 GCM 注册获取)，并在页面上进行订阅或发起订阅。每一个会话会有一个独立的端点（<code>endpoint</code>），订阅对象的属性(<code>PushSubscription.endpoint</code>) 即为端点值。将端点发送给服务器后，服务器用这一值来发送消息给会话的激活的 Service Worker （通过 GCM 与浏览器客户端沟通</p></blockquote><p><strong>步骤一和步骤二</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--index.html--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Progressive Times&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;manifest&quot; href=&quot;/manifest.json&quot;&gt;                                      </span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      var endpoint;</span><br><span class="line">      var key;</span><br><span class="line">      var authSecret;</span><br><span class="line">      var vapidPublicKey = &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;;</span><br><span class="line">      // 方法很复杂，但是可以不用具体看，知识用来转化vapidPublicKey用</span><br><span class="line">      function urlBase64ToUint8Array(base64String) &#123;                                  </span><br><span class="line">        const padding = &#x27;=&#x27;.repeat((4 - base64String.length % 4) % 4);</span><br><span class="line">        const base64 = (base64String + padding)</span><br><span class="line">          .replace(/\-/g, &#x27;+&#x27;)</span><br><span class="line">          .replace(/_/g, &#x27;/&#x27;);</span><br><span class="line">        const rawData = window.atob(base64);</span><br><span class="line">        const outputArray = new Uint8Array(rawData.length);</span><br><span class="line">        for (let i = 0; i &lt; rawData.length; ++i) &#123;</span><br><span class="line">          outputArray[i] = rawData.charCodeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return outputArray;</span><br><span class="line">      &#125;</span><br><span class="line">      if (&#x27;serviceWorker&#x27; in navigator) &#123;</span><br><span class="line">        navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(function (registration) &#123;</span><br><span class="line">          return registration.pushManager.getSubscription()                            </span><br><span class="line">            .then(function (subscription) &#123;</span><br><span class="line">              if (subscription) &#123;                                                      </span><br><span class="line">                return;</span><br><span class="line">              &#125;</span><br><span class="line">              return registration.pushManager.subscribe(&#123;                              </span><br><span class="line">                  userVisibleOnly: true,</span><br><span class="line">                  applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)</span><br><span class="line">                &#125;)</span><br><span class="line">                .then(function (subscription) &#123;</span><br><span class="line">                  var rawKey = subscription.getKey ? subscription.getKey(&#x27;p256dh&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  key = rawKey ? btoa(String.fromCharCode.apply(null, new Uint8Array(rawKey))) : &#x27;&#x27;;</span><br><span class="line">                  var rawAuthSecret = subscription.getKey ? subscription.getKey(&#x27;auth&#x27;) : &#x27;&#x27;;</span><br><span class="line">                  authSecret = rawAuthSecret ?</span><br><span class="line">                    btoa(String.fromCharCode.apply(null, new Uint8Array(rawAuthSecret))) : &#x27;&#x27;;</span><br><span class="line">                  endpoint = subscription.endpoint;</span><br><span class="line">                  return fetch(&#x27;./register&#x27;, &#123;                                         </span><br><span class="line">                    method: &#x27;post&#x27;,</span><br><span class="line">                    headers: new Headers(&#123;</span><br><span class="line">                      &#x27;content-type&#x27;: &#x27;application/json&#x27;</span><br><span class="line">                    &#125;),</span><br><span class="line">                    body: JSON.stringify(&#123;</span><br><span class="line">                      endpoint: subscription.endpoint,</span><br><span class="line">                      key: key,</span><br><span class="line">                      authSecret: authSecret,</span><br><span class="line">                    &#125;),</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;).catch(function (err) &#123;</span><br><span class="line">          // 注册失败 :(</span><br><span class="line">          console.log(&#x27;ServiceWorker registration failed: &#x27;, err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>步骤三 服务器发送消息给service worker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// app.js</span><br><span class="line"></span><br><span class="line">const webpush = require(&#x27;web-push&#x27;);                 </span><br><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">var bodyParser = require(&#x27;body-parser&#x27;);</span><br><span class="line">const app = express();</span><br><span class="line">webpush.setVapidDetails(                             </span><br><span class="line">  &#x27;mailto:contact@deanhume.com&#x27;,</span><br><span class="line">  &#x27;BAyb_WgaR0L0pODaR7wWkxJi__tWbM1MPBymyRDFEGjtDCWeRYS9EF7yGoCHLdHJi6hikYdg4MuYaK0XoD0qnoY&#x27;,</span><br><span class="line">  &#x27;p6YVD7t8HkABoez1CvVJ5bl7BnEdKUu5bSyVjyxMBh0&#x27;</span><br><span class="line">);</span><br><span class="line">app.post(&#x27;/register&#x27;, function (req, res) &#123;           </span><br><span class="line">  var endpoint = req.body.endpoint;</span><br><span class="line">  saveRegistrationDetails(endpoint, key, authSecret); </span><br><span class="line">  const pushSubscription = &#123;                          </span><br><span class="line">    endpoint: req.body.endpoint,</span><br><span class="line">    keys: &#123;</span><br><span class="line">      auth: req.body.authSecret,</span><br><span class="line">      p256dh: req.body.key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  var body = &#x27;Thank you for registering&#x27;;</span><br><span class="line">  var iconUrl = &#x27;https://example.com/images/homescreen.png&#x27;;</span><br><span class="line">  // 发送 Web 推送消息</span><br><span class="line">  webpush.sendNotification(pushSubscription,          </span><br><span class="line">      JSON.stringify(&#123;</span><br><span class="line">        msg: body,</span><br><span class="line">        url: &#x27;http://localhost:3111/&#x27;,</span><br><span class="line">        icon: iconUrl</span><br><span class="line">      &#125;))</span><br><span class="line">    .then(result =&gt; res.sendStatus(201))</span><br><span class="line">    .catch(err =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(3111, function () &#123;</span><br><span class="line">  console.log(&#x27;Web push app listening on port 3111!&#x27;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><code>service worker</code>监听push事件，将通知详情推送给用户</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// service-worker.js</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;push&#x27;, function (event) &#123;</span><br><span class="line"> // 检查服务端是否发来了任何有效载荷数据</span><br><span class="line">  var payload = event.data ? JSON.parse(event.data.text()) : &#x27;no payload&#x27;;</span><br><span class="line">  var title = &#x27;Progressive Times&#x27;;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    // 使用提供的信息来显示 Web 推送通知</span><br><span class="line">    self.registration.showNotification(title, &#123;                           </span><br><span class="line">      body: payload.msg,</span><br><span class="line">      url: payload.url,</span><br><span class="line">      icon: payload.icon</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><ul><li><a href="https://lzw.me/a/pwa-service-worker.html#3.3">网站渐进式增强体验(PWA)改造：Service Worker 应用详解</a></li><li><a href="https://github.com/SangKa/PWA-Book-CN">PWA实战：面向下一代的Progressive Web APP</a></li><li><a href="https://x5.tencent.com/tbs/guide/serviceworker.html">Service Worker最佳实践</a></li><li><a href="https://fed.renren.com/2017/10/04/service-worker/">使用 Service Worker 做一个 PWA 离线网页应用</a></li><li><a href="https://zhuanlan.zhihu.com/p/28461857">理解Service Worker</a></li><li><a href="http://obkoro1.com/web_accumulate/accumulate/JS/webWorker%E4%B8%8A%E6%89%8B.html">前端er来学习一下 WebWorker</a></li><li><a href="https://juejin.im/post/5bf3f656e51d45338e084044?utm_source=gold_browser_extension">Service Worker学习与实践（二）——PWA简介</a></li><li><a href="https://juejin.im/post/5bf3f6b2e51d45360069e527?utm_source=gold_browser_extension">Service Worker学习与实践（三）——消息推送</a></li><li><a href="https://github.com/nicejade/nice-front-end-tutorial/blob/master/tutorial/pwa-tutorial.md">pwa-tutoria</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、初识PWA&quot;&gt;&lt;a href=&quot;#一、初识PWA&quot; class=&quot;headerlink&quot; title=&quot;一、初识PWA&quot;&gt;&lt;/a&gt;一、初识PWA&lt;/h1&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PWA&lt;/code&gt;，即&lt;code&gt;Progres</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器组成与架构</title>
    <link href="http://example.com/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/"/>
    <id>http://example.com/2021/05/27/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BB%84%E6%88%90%E4%B8%8E%E6%9E%B6%E6%9E%84/</id>
    <published>2021-05-27T07:31:26.000Z</published>
    <updated>2022-06-07T00:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>​        浏览器由shell（用户界面、网络、UI后端、JavaScript解释器、XML解析器、数据存储）和内核（浏览器引擎、渲染引擎）组成，内核是浏览器的核心。不同的浏览器有不同的内核，ie 浏览器是 Trident，Firefox 浏览器是 Geoko（Mozilla自主研发的渲染引擎），Safari 和 Chrome 使用的是 webkit （后来 Chrome 推出了 Blink）。</p><h2 id="用户界面（User-Interface）"><a href="#用户界面（User-Interface）" class="headerlink" title="用户界面（User Interface）"></a>用户界面（User Interface）</h2><pre><code>    用户界面主要包括工具栏、地址栏、前进/后退按钮、书签菜单、可视化页面加载进度、智能下载处理、首选项、打印等。除了浏览器主窗口显示请求的页面之外，其他显示的部分都属于用户界面。    用户界面还可以与桌面环境集成，以提供浏览器会话管理或与其他桌面应用程序的通信。</code></pre><h2 id="网络（Networking）"><a href="#网络（Networking）" class="headerlink" title="网络（Networking）"></a>网络（Networking）</h2><pre><code>    网络系统实现HTTP和FTP等文件传输协议。 网络系统可以在不同的字符集之间进行转换，为文件解析MIME媒体类型。 网络系统可以实现最近检索资源的缓存功能。</code></pre><h2 id="UI后端（Display-Backend）"><a href="#UI后端（Display-Backend）" class="headerlink" title="UI后端（Display Backend）"></a>UI后端（Display Backend）</h2><pre><code>    UI后端提供绘图和窗口原语，包括：用户界面控件集合、字体集合。</code></pre><h2 id="JavaScript解释器（JavaScript-Interpreter）"><a href="#JavaScript解释器（JavaScript-Interpreter）" class="headerlink" title="JavaScript解释器（JavaScript Interpreter）"></a>JavaScript解释器（JavaScript Interpreter）</h2><pre><code>    JavaScript解释器能够解释并执行嵌入在网页中的JavaScript（又称ECMAScript）代码。 为了安全起见，浏览器引擎或渲染引擎可能会禁用某些JavaScript功能，如弹出窗口的打开。</code></pre><h2 id="XML解析器（XML-Parser）"><a href="#XML解析器（XML-Parser）" class="headerlink" title="XML解析器（XML Parser）"></a>XML解析器（XML Parser）</h2><pre><code>    XML解析器可以将XML文档解析成文档对象模型（Document Object Model，DOM）树。 XML解析器是浏览器架构中复用最多的子系统之一，几乎所有的浏览器实现都利用现有的XML解析器，而不是从头开始创建自己的XML解析器。</code></pre><h2 id="数据存储（Data-Persistence）"><a href="#数据存储（Data-Persistence）" class="headerlink" title="数据存储（Data Persistence）"></a>数据存储（Data Persistence）</h2><pre><code>    数据存储将与浏览会话相关联的各种数据存储在硬盘上。 这些数据可能是诸如：书签、工具栏设置等这样的高级数据，也可能是诸如：Cookie，安全证书、缓存等这样的低级数据。</code></pre><h2 id="浏览器引擎（Browser-Engine）"><a href="#浏览器引擎（Browser-Engine）" class="headerlink" title="浏览器引擎（Browser Engine）"></a>浏览器引擎（Browser Engine）</h2><pre><code>    浏览器引擎是一个可嵌入的组件，其为渲染引擎提供高级接口。浏览器引擎可以加载一个给定的URI，并支持诸如：前进/后退/重新加载等浏览操作。浏览器引擎提供查看浏览会话的各个方面的挂钩，例如：当前页面加载进度、JavaScript alert。浏览器引擎还允许查询/修改渲染引擎设置。</code></pre><h2 id="渲染引擎（Rendering-Engine-或-layout-engineer）"><a href="#渲染引擎（Rendering-Engine-或-layout-engineer）" class="headerlink" title="渲染引擎（Rendering Engine 或 layout engineer）"></a>渲染引擎（Rendering Engine 或 layout engineer）</h2><pre><code>    渲染引擎负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。渲染引擎能够显示HTML和XML文档，可选择CSS样式，以及嵌入式内容（如图片）。渲染引擎能够准确计算页面布局，可使用“回流”算法逐步调整页面元素的位置。渲染引擎内部包含HTML解析器。</code></pre><h1 id="软件构造"><a href="#软件构造" class="headerlink" title="软件构造"></a>软件构造</h1><p>​        不同的浏览器软件架构也不一样，好的软件都是支持多进程和多线程，进程与进程相互独立，不同的进程之间通过IPC（Inter Process Communication）进行通信。</p><pre><code>    以 Chrome 浏览器为例，它的架构模式由浏览器进程（Browser Process）、渲染进程（Renderer Process）、插件进程（Plugin Process）、GPU进程（GPU Process）、网络进程（NetWork Process）和其他进程组成，每个进程都有自己核心的职责，它们相互配合完成浏览器的整体功能，每个进程中又包含多个线程，一个进程内的多个线程也会协同工作，配合完成所在进程的职责。和大多数浏览器不同，Chrome 浏览器的每个标签页都分别对应一个渲染引擎实例。每个标签页都是一个独立的进程，当标签页的数量足够多时（40个页面以上），会与之前的标签页共用同一个进程。</code></pre><h2 id="浏览器进程（Browser-Process）"><a href="#浏览器进程（Browser-Process）" class="headerlink" title="浏览器进程（Browser Process）"></a>浏览器进程（Browser Process）</h2><pre><code>    主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。控制应用程序的 chrome 部分，包括地址栏、书签、后退和前进等按钮，还处理Web浏览器的隐形、底层操作，例如网络请求和文件访问。 </code></pre><h2 id="渲染进程（Renderer-Process）"><a href="#渲染进程（Renderer-Process）" class="headerlink" title="渲染进程（Renderer Process）"></a>渲染进程（Renderer Process）</h2><pre><code>    核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，渲染引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。</code></pre><h2 id="GPU-进程（GPU-Process）"><a href="#GPU-进程（GPU-Process）" class="headerlink" title="GPU 进程（GPU Process）"></a>GPU 进程（GPU Process）</h2><pre><code>    GPU 进程的使用初衷是为了实现 3D CSS 的效果，随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制。</code></pre><h2 id="网络进程（NetWork-Process）"><a href="#网络进程（NetWork-Process）" class="headerlink" title="网络进程（NetWork Process）"></a>网络进程（NetWork Process）</h2><pre><code>    主要负责页面的网络资源加载。</code></pre><h2 id="插件进程（Plugin-Process）"><a href="#插件进程（Plugin-Process）" class="headerlink" title="插件进程（Plugin Process）"></a>插件进程（Plugin Process）</h2><pre><code>    主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</code></pre><h2 id="utility进程（Utility-Process）"><a href="#utility进程（Utility-Process）" class="headerlink" title="utility进程（Utility Process）"></a>utility进程（Utility Process）</h2><pre><code>    有时候浏览器主进程需要做一些“危险”的事情，比如图片解码、文件解压缩。如果这些“危险”的操作发生了失败，会导致整个主进程发生异常崩溃，这是我们不愿意看到的。因此Chromium设计出了一个utility进程的机制。主进程临时需要做一些不方便的任务的情况下，可以启动一个utility进程来代替主进程执行，主进程与utility进程之间通过IPC消息来通信。</code></pre><h2 id="其他进程"><a href="#其他进程" class="headerlink" title="其他进程"></a>其他进程</h2><pre><code>    UI进程、存储进程、备进程、Audio进程、Video进程、Profile进程等等。</code></pre><p>面向服务架构<br>        面向服务架构（Services Oriented Architecture，简称 SOA），后端技术开发中比较火热的微服务架构就是 SOA 的一种变体，Chrome 官方团队将原来的各种模块重构成独立的服务（Service），访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，每个服务（Service）都可以在独立的进程中运行，并且可以轻松拆分为不同的进程或聚合为一个进程。当Chrome在功能强大的硬件上运行时，它可能会将每个服务拆分为不同的进程以提供更高的稳定性，但是如果是在资源受限的设备上，Chrome 会将服务整合到一个进程中以节省内存。</p><pre><code>    在最新的 Chrome 浏览器中，可以在设置中打开更多工具，找到任务管理器并打开。     可以看到有部分的 Chrome Service 与进程同时在运行，Chrome 仍在努力的完善面向服务架构。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h1&gt;&lt;p&gt;​        浏览器由shell（用户界面、网络、UI后端、JavaScript解释器、XML解析器、数据存储）和内核（浏览器引擎、渲染</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>await 在 forEach 中不生效解决方案</title>
    <link href="http://example.com/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://example.com/2021/05/24/html+css+js+ts/await%20%E5%9C%A8%20forEach%20%E4%B8%AD%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-05-24T06:46:21.000Z</published>
    <updated>2022-05-31T03:43:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、场景"><a href="#一、场景" class="headerlink" title="一、场景"></a>一、场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;</span><br><span class="line">let arr = [3, 2, 1]</span><br><span class="line">arr.forEach(async item =&gt; &#123;</span><br><span class="line">const res = await fetch(item)</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fetch(x) &#123;</span><br><span class="line">return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">resolve(x)</span><br><span class="line">&#125;, 500 * x)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>期望的打印顺序是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>结果打印顺序居然是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>原因</strong></p><blockquote><p>那就是 <code>forEach</code> 只支持同步代码。<code>forEach</code> 并不会去处理异步的情况</p></blockquote><h2 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h2><h3 id="2-1-第一种是使用-Promise-all-的方式"><a href="#2-1-第一种是使用-Promise-all-的方式" class="headerlink" title="2.1 第一种是使用 Promise.all 的方式"></a>2.1 第一种是使用 Promise.all 的方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">let arr = [3, 2, 1]</span><br><span class="line">await Promise.all(</span><br><span class="line">arr.map(async item =&gt; &#123;</span><br><span class="line">const res = await fetch(item)</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">)</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样可以生效的原因是 <code>async</code> 函数肯定会返回一个 <code>Promise</code> 对象，调用 <code>map</code> 以后返回值就是一个存放了 <code>Promise</code> 的数组了，这样我们把数组传入 <code>Promise.all</code> 中就可以解决问题了。但是这种方式其实并不能达成我们要的效果，如果你希望内部的 <code>fetch</code> 是顺序完成的，可以选择第二种方式</p></blockquote><h3 id="2-2-另一种方法是使用-for…of"><a href="#2-2-另一种方法是使用-for…of" class="headerlink" title="2.2 另一种方法是使用 for…of"></a>2.2 另一种方法是使用 for…of</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">let arr = [3, 2, 1]</span><br><span class="line">for (const item of arr) &#123;</span><br><span class="line">const res = await fetch(item)</span><br><span class="line">console.log(res)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种方式相比 <code>Promise.all</code> 要简洁的多，并且也可以实现开头我想要的输出顺序。</li><li>但是这时候你是否又多了一个疑问？为啥 <code>for...of</code> 内部就能让 <code>await</code> 生效呢。</li><li>因为 <code>for...of</code> 内部处理的机制和 f<code>orEach</code> 不同，<code>forEach</code> 是直接调用回调函数，<code>for...of</code> 是通过迭代器的方式去遍历。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">let arr = [3, 2, 1]</span><br><span class="line">const iterator = arr[Symbol.iterator]()</span><br><span class="line">let res = iterator.next()</span><br><span class="line">while (!res.done) &#123;</span><br><span class="line">const value = res.value</span><br><span class="line">const res1 = await fetch(value)</span><br><span class="line">console.log(res1)</span><br><span class="line">res = iterator.next()</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;end&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码等价于 <code>for...of</code>，可以看成 <code>for...of</code> 是以上代码的语法糖</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、场景&quot;&gt;&lt;a href=&quot;#一、场景&quot; class=&quot;headerlink&quot; title=&quot;一、场景&quot;&gt;&lt;/a&gt;一、场景&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="前端" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="问题" scheme="http://example.com/categories/%E5%89%8D%E7%AB%AF/%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="async/await" scheme="http://example.com/tags/async-await/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理</title>
    <link href="http://example.com/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/05/19/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-19T06:18:26.000Z</published>
    <updated>2022-06-07T00:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p><ol><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ol><blockquote><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p></blockquote><p>具体如下图过程如下图所示</p><p><img src="https://poetries1.gitee.io/img-repo/2019/10/19.png" alt="img"></p><p><img src="https://poetries1.gitee.io/img-repo/2019/10/20.png" alt="img"></p><p><strong>渲染</strong></p><ul><li>网页生成的时候，至少会渲染一次</li><li>在用户访问的过程中，还会不断重新渲染</li></ul><blockquote><p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p></blockquote><ul><li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li><li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li></ul><h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote><p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p></blockquote><ul><li>作为下个阶段渲染树状图的输入</li><li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li></ul><p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p><ol><li><code>html</code>解析器停止解析,</li><li>如果是外部脚本，就从外部网络获取脚本代码</li><li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li><li>恢复<code>html</code>解析器的控制权</li></ol><blockquote><p>由此可以得到第一个结论1</p></blockquote><ul><li>由于&#96;&#96;标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li><li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li><li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li><li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li></ul><h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul><li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li><li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li></ul><p><strong>通过以下手段可以减轻cssom带来的影响</strong></p><ul><li>将<code>script</code>脚本放在页面底部</li><li>尽可能快的加载<code>css</code>样式表</li><li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li><li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li></ul><h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="https://poetries1.gitee.io/img-repo/2019/10/21.png" alt="img"></p><h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote><p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p></blockquote><h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote><p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p></blockquote><h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul><li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li><li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li></ul><h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p></blockquote><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>以下几个动作可能会导致性能问题</strong></p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>常见的引起重绘的属性</strong></p><ul><li><code>color</code></li><li><code>border-style</code></li><li><code>visibility</code></li><li><code>background</code></li><li><code>text-decoration</code></li><li><code>background-image</code></li><li><code>background-position</code></li><li><code>background-repeat</code></li><li><code>outline-color</code></li><li><code>outline</code></li><li><code>outline-style</code></li><li><code>border-radius</code></li><li><code>outline-width</code></li><li><code>box-shadow</code></li><li><code>background-size</code></li></ul><h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p></blockquote><ul><li>添加或者删除可见的<code>DOM</code>元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在<code>input</code>框中输入文字</li><li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li><li>设置 <code>style</code> 属性的值</li></ul><p><strong>回流影响的范围</strong></p><blockquote><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p></blockquote><ul><li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围回流</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;h4&gt;hello&lt;/h4&gt;</span><br><span class="line">    &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt;BDing&lt;/p&gt;</span><br><span class="line">    &lt;h5&gt;male&lt;/h5&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li&gt;coding&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;loving&lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><blockquote><p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p></blockquote><p><strong>局部范围回流</strong></p><blockquote><p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p></blockquote><h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote><p>使用 <code>translate</code> 替代 <code>top</code></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;test&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .test &#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 10px;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        // 引起回流</span><br><span class="line">        document.querySelector(&#x27;.test&#x27;).style.top = &#x27;100px&#x27;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li><li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">    // 获取 offsetTop 会导致回流，因为需要去获取正确的值</span><br><span class="line">    console.log(document.querySelector(&#x27;.test&#x27;).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/22.png" alt="img"></p><p><img src="https://poetries1.gitee.io/img-repo/2019/10/23.png" alt="img"></p><blockquote><p><a href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81">重绘与回流</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、浏览器如何渲染网页&quot;&gt;&lt;a href=&quot;#一、浏览器如何渲染网页&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器如何渲染网页&quot;&gt;&lt;/a&gt;一、浏览器如何渲染网页&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概述：浏览器渲染一共有五步&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存原理</title>
    <link href="http://example.com/2021/05/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/05/07/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E5%8E%9F%E7%90%86/</id>
    <published>2021-05-07T01:33:18.000Z</published>
    <updated>2022-06-07T00:36:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、浏览器缓存基本认识"><a href="#一、浏览器缓存基本认识" class="headerlink" title="一、浏览器缓存基本认识"></a>一、浏览器缓存基本认识</h1><p><strong>分为强缓存和协商缓存</strong></p><ol><li>浏览器在加载资源时，先根据这个资源的一些<code>http header</code>判断它是否命中强缓存，强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器。比如某个<code>css</code>文件，如果浏览器在加载它所在的网页时，这个<code>css</code>文件的缓存配置命中了强缓存，浏览器就直接从缓存中加载这个<code>css</code>，连请求都不会发送到网页所在服务器</li><li>当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端依据资源的另外一些<code>http header</code>验证这个资源是否命中协商缓存，如果协商缓存命中，服务器会将这个请求返回，但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源</li><li><strong>强缓存与协商缓存的共同点是</strong>：如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；区别是：<strong>强缓存不发请求到服务器</strong>，协商缓存会发请求到服务器</li><li>当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据</li></ol><h1 id="二、强缓存的原理"><a href="#二、强缓存的原理" class="headerlink" title="二、强缓存的原理"></a>二、强缓存的原理</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><blockquote><p>当浏览器对某个资源的请求命中了强缓存时，返回的<code>http</code>状态为<code>200</code>，在<code>chrome</code>的开发者工具的<code>network</code>里面<code>size</code>会显示为<code>from cache</code>，比如京东的首页里就有很多静态资源配置了强缓存，用<code>chrome</code>打开几次，再用<code>f12</code>查看<code>network</code>，可以看到有不少请求就是从缓存中加载的</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/1.png" alt="img"></p><ul><li>强缓存是利用<code>Expires</code>或者<code>Cache-Control</code>这两个<code>http response header</code>实现的，它们都用来表示资源在客户端缓存的有效期。</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是`http1.0`提出的一个表示资源过期时间的`header`，它描述的是一个绝对时间，由服务器返回，用`GMT`格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-2-Expires缓存原理"><a href="#2-2-Expires缓存原理" class="headerlink" title="2.2 Expires缓存原理"></a>2.2 Expires缓存原理</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Expires</code>，如</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/2.png" alt="img"></p><ol><li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来（所以缓存命中的请求返回的<code>header</code>并不是来自服务器，而是来自之前缓存的<code>header</code>）</li><li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的<code>Expires</code>跟当前的请求时间比较，如果请求时间在<code>Expires</code>指定的时间之前，就能命中缓存，否则就不行</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Expires Header</code>在重新加载的时候会被更新</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires`是较老的强缓存管理`header`，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在`http1.1`的时候，提出了一个新的`header`，就是`Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：`Cache-Control:max-age=315360000</span><br></pre></td></tr></table></figure></blockquote><h2 id="2-3-Cache-Control缓存原理"><a href="#2-3-Cache-Control缓存原理" class="headerlink" title="2.3 Cache-Control缓存原理"></a>2.3 Cache-Control缓存原理</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Cache-Control</code>，如：</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/3.png" alt="img"></p><ol><li>浏览器在接收到这个资源后，会把这个资源连同所有<code>response header</code>一起缓存下来</li><li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和<code>Cache-Control</code>设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行</li><li>如果缓存没有命中，浏览器直接从服务器加载资源时，<code>Cache-Control Header</code>在重新加载的时候会被更新</li></ol><ul><li><code>Cache-Control</code>描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较<code>Expires</code>，<code>Cache-Control</code>的缓存管理更有效，安全一些。</li><li>这两个<code>header</code>可以只启用一个，也可以同时启用，当<code>response header</code>中，<code>Expires</code>和<code>Cache-Control</code>同时存在时，<code>Cache-Control</code>优先级高于<code>Expires</code>：</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/4.png" alt="img"></p><h1 id="三、强缓存的管理"><a href="#三、强缓存的管理" class="headerlink" title="三、强缓存的管理"></a>三、强缓存的管理</h1><blockquote><p>前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存</p></blockquote><ol><li>通过代码的方式，在<code>web</code>服务器返回的响应中添加<code>Expires</code>和<code>Cache-Control Header</code></li><li>通过配置<code>web</code>服务器的方式，让<code>web</code>服务器在响应资源的时候统一添加<code>Expires</code>和<code>Cache-Control Header</code></li></ol><blockquote><p>比如在javaweb里面，我们可以使用类似下面的代码设置强缓存</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.util.Date date = new java.util.Date();    </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;,date.getTime()+20000); //Expires:过时期限值 </span><br><span class="line">response.setHeader(&quot;Cache-Control&quot;, &quot;public&quot;); //Cache-Control来控制页面的缓存与否,public:浏览器和缓存服务器都可以缓存页面信息；</span><br><span class="line">response.setHeader(&quot;Pragma&quot;, &quot;Pragma&quot;); //Pragma:设置页面是否缓存，为Pragma则缓存，no-cache则不缓存</span><br></pre></td></tr></table></figure><blockquote><p>还可以通过类似下面的<code>java</code>代码设置不启用强缓存</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader( &quot;Pragma&quot;, &quot;no-cache&quot; );   </span><br><span class="line">response.setDateHeader(&quot;Expires&quot;, 0);   </span><br><span class="line">response.addHeader( &quot;Cache-Control&quot;, &quot;no-cache&quot; );//浏览器和缓存服务器都不应该缓存页面信息</span><br></pre></td></tr></table></figure><ul><li><code>nginx</code>和<code>apache</code>作为专业的<code>web</code>服务器，都有专门的配置文件，可以配置<code>expires</code>和<code>cache-control</code>，这方面的知识，如果你对运维感兴趣的话，可以在百度上搜索<code>nginx</code> 设置 <code>expires cache-control</code>或 <code>apache 设置 expires cache-control</code> 都能找到不少相关的文章。</li><li>由于在开发的时候不会专门去配置强缓存，而浏览器又默认会缓存图片，<code>css</code>和<code>js</code>等静态资源，所以开发环境下经常会因为强缓存导致资源没有及时更新而看不到最新的效果，解决这个问题的方法有很多，常用的有以下几种</li></ul><p><strong>处理缓存带来的问题</strong></p><ol><li>直接<code>ctrl+f5</code>，这个办法能解决页面直接引用的资源更新的问题</li><li>使用浏览器的隐私模式开发</li><li>如果用的是<code>chrome</code>，可以<code>f12</code>在<code>network</code>那里把缓存给禁掉（这是个非常有效的方法）</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/5.png" alt="img"></p><ol><li>在开发阶段，给资源加上一个动态的参数，如<code>css/index.css?v=0.0001</code>，由于每次资源的修改都要更新引用的位置，同时修改参数的值，所以操作起来不是很方便，除非你是在动态页面比如jsp里开发就可以用服务器变量来解决（<code>v=$&#123;sysRnd&#125;</code>），或者你能用一些前端的构建工具来处理这个参数修改的问题</li><li>如果资源引用的页面，被嵌入到了一个<code>iframe</code>里面，可以在<code>iframe</code>的区域右键单击重新加载该页面，以<code>chrome</code>为例</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/6.png" alt="img"></p><ol><li>如果缓存问题出现在<code>ajax</code>请求中，最有效的解决办法就是<code>ajax</code>的请求地址追加随机数</li><li>还有一种情况就是动态设置<code>iframe</code>的<code>src</code>时，有可能也会因为缓存问题，导致看不到最新的效果，这时候在要设置的<code>src</code>后面添加随机数也能解决问题</li><li>如果你用的是<code>grunt</code>和<code>gulp</code>、<code>webpack</code>这种前端工具开发，通过它们的插件比如<code>grunt-contrib-connect</code>来启动一个静态服务器，则完全不用担心开发阶段的资源更新问题，因为在这个静态服务器下的所有资源返回的<code>respone header</code>中，<code>cache-control</code>始终被设置为不缓存</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/7.png" alt="img"></p><h1 id="四、强缓存的应用"><a href="#四、强缓存的应用" class="headerlink" title="四、强缓存的应用"></a>四、强缓存的应用</h1><blockquote><p>强缓存是前端性能优化最有力的工具，没有之一，对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的<code>Expires</code>或<code>Cache-Control</code>，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载，比如前面提到过的京东首页缓存的资源，它的缓存过期时间都设置到了<code>2026</code>年</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/8.png" alt="img"></p><blockquote><p>然而这种缓存配置方式会带来一个新的问题，就是发布时资源更新的问题，比如某一张图片，在用户访问第一个版本的时候已经缓存到了用户的电脑上，当网站发布新版本，替换了这个图片时，已经访问过第一个版本的用户由于缓存的设置，导致在默认的情况下不会请求服务器最新的图片资源，除非他清掉或禁用缓存或者强制刷新，否则就看不到最新的图片效果</p></blockquote><p>这个问题已经有成熟的解决方案，具体内容可阅读知乎这篇文章详细了解：<a href="http://www.zhihu.com/question/20790576">http://www.zhihu.com/question/20790576</a></p><p>文章提到的东西都属于理论上的解决方案，不过现在已经有很多前端工具能够实际地解决这个问题，由于每个工具涉及到的内容细节都有很多，本文没有办法一一深入介绍。有兴趣的可以去了解下<code>grunt</code> <code>gulp</code> <code>webpack</code> <code>fis</code>还有edp这几个工具，基于这几个工具都能解决这个问题，尤其是<code>fis</code>和<code>edp</code>是百度推出的前端开发平台，有现成的文档可以参考：</p><p><a href="http://fis.baidu.com/fis3/api/index.html">http://fis.baidu.com/fis3/api/index.html</a></p><p><a href="http://ecomfe.github.io/edp/doc/initialization/install/">http://ecomfe.github.io/edp/doc/initialization/install/</a></p><blockquote><p>强缓存还有一点需要注意的是，通常都是针对静态资源使用，动态资源需要慎用，除了服务端页面可以看作动态资源外，那些引用静态资源的<code>html</code>也可以看作是动态资源，如果这种<code>html</code>也被缓存，当这些<code>html</code>更新之后，可能就没有机制能够通知浏览器这些html有更新，尤其是前后端分离的应用里，页面都是纯<code>html</code>页面，每个访问地址可能都是直接访问<code>html</code>页面，这些页面通常不加强缓存，以保证浏览器访问这些页面时始终请求服务器最新的资源</p></blockquote><h1 id="五、协商缓存的原理"><a href="#五、协商缓存的原理" class="headerlink" title="五、协商缓存的原理"></a>五、协商缓存的原理</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的<code>http</code>状态为<code>304</code>并且会显示一个<code>Not Modified</code>的字符串，比如你打开京东的首页，按<code>f12</code>打开开发者工具，再按<code>f5</code>刷新页面，查看<code>network</code>，可以看到有不少请求就是命中了协商缓存的</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/9.png" alt="img"></p><blockquote><p>查看单个请求的<code>Response Header</code>，也能看到<code>304</code>的状态码和<code>Not Modified</code>的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/10.png" alt="img"></p><h2 id="5-2-Last-Modified，If-Modified-Since控制协商缓存"><a href="#5-2-Last-Modified，If-Modified-Since控制协商缓存" class="headerlink" title="5.2 Last-Modified，If-Modified-Since控制协商缓存"></a>5.2 Last-Modified，If-Modified-Since控制协商缓存</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>Last-Modified</code>的<code>header</code>，这个<code>header</code>表示这个资源在服务器上的最后修改时间</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/11.png" alt="img"></p><ol><li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-Modified-Since</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>Last-Modified</code>的值</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/12.png" alt="img"></p><ol><li>服务器再次收到资源请求时，根据浏览器传过来<code>If-Modified-Since</code>和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回<code>304 Not Modified</code>的响应时，<code>response header</code>中不会再添加<code>Last-Modified</code>的<code>header</code>，因为既然资源没有变化，那么<code>Last-Modified</code>也就不会改变，这是服务器返回<code>304</code>时的<code>response header</code></li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/13.png" alt="img"></p><ol><li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源</li><li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，<code>Last-Modified</code> <code>Header</code>在重新加载的时候会被更新，下次请求时，<code>If-Modified-Since</code>会启用上次返回的<code>Last-Modified</code>值</li></ol><blockquote><p>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】都是根据服务器时间返回的<code>header</code>，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个<code>header</code>配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性。所以就有了另外一对<code>header</code>来管理协商缓存，这对<code>header</code>就是【<code>ETag</code>、<code>If-None-Match</code>】。它们的缓存管理的方式是</p></blockquote><h2 id="5-3-ETag、If-None-Match控制协商缓存"><a href="#5-3-ETag、If-None-Match控制协商缓存" class="headerlink" title="5.3 ETag、If-None-Match控制协商缓存"></a>5.3 ETag、If-None-Match控制协商缓存</h2><ol><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在<code>respone</code>的<code>header</code>加上<code>ETag</code>的<code>header</code>，这个<code>header</code>是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充<code>Last-Modified</code>的问题</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/14.png" alt="img"></p><ol><li>浏览器再次跟服务器请求这个资源时，在<code>request</code>的<code>header</code>上加上<code>If-None-Match</code>的<code>header</code>，这个<code>header</code>的值就是上一次请求时返回的<code>ETag</code>的值</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/15.png" alt="img"></p><ol><li>服务器再次收到资源请求时，根据浏览器传过来<code>If-None-Match</code>和然后再根据资源生成一个新的<code>ETag</code>，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回<code>304 Not Modified</code>，但是不会返回资源内容；如果有变化，就正常返回资源内容。与<code>Last-Modified</code>不一样的是，当服务器返回<code>304 Not Modified</code>的响应时，由于<code>ETag</code>重新生成过，<code>response header</code>中还会把这个<code>ETag</code>返回，即使这个<code>ETag</code>跟之前的没有变化</li></ol><p><img src="https://poetries1.gitee.io/img-repo/2019/10/16.png" alt="img"></p><ol><li>浏览器收到<code>304</code>的响应后，就会从缓存中加载资源。</li></ol><h1 id="六、协商缓存的管理"><a href="#六、协商缓存的管理" class="headerlink" title="六、协商缓存的管理"></a>六、协商缓存的管理</h1><blockquote><p>协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分<code>web</code>服务器都默认开启协商缓存，而且是同时启用【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】，比如<code>apache</code>:</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/17.png" alt="img"></p><blockquote><p>如果没有协商缓存，每个到服务器的请求，就都得返回资源内容，这样服务器的性能会极差。</p></blockquote><ul><li>【<code>Last-Modified</code>，<code>If-Modified-Since</code>】和【<code>ETag</code>、<code>If-None-Match</code>】一般都是同时启用，这是为了处理<code>Last-Modified</code>不可靠的情况。</li></ul><p><strong>有一种场景需要注意</strong></p><ul><li>分布式系统里多台机器间文件的<code>Last-Modified</code>必须保持一致，以免负载均衡到不同机器导致比对失败；</li><li>分布式系统尽量关闭掉<code>ETag</code>(每台机器生成的<code>ETag</code>都会不一样）；</li><li>京东页面的资源请求，返回的<code>repsones header</code>就只有<code>Last-Modified</code>，没有<code>ETag</code>：</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/18.png" alt="img"></p><blockquote><p>协商缓存需要配合强缓存使用，你看前面这个截图中，除了<code>Last-Modified</code>这个<code>header</code>，还有强缓存的相关<code>header</code>，因为如果不启用强缓存的话，协商缓存根本没有意义</p></blockquote><h1 id="七、相关浏览器行为对缓存的影响"><a href="#七、相关浏览器行为对缓存的影响" class="headerlink" title="七、相关浏览器行为对缓存的影响"></a>七、相关浏览器行为对缓存的影响</h1><blockquote><p>如果资源已经被浏览器缓存下来，在缓存失效之前，再次请求时，默认会先检查是否命中强缓存，如果强缓存命中则直接读取缓存，如果强缓存没有命中则发请求到服务器检查是否命中协商缓存，如果协商缓存命中，则告诉浏览器还是可以从缓存读取，否则才从服务器返回最新的资源。这是默认的处理方式，这个方式可能被浏览器的行为改变：</p></blockquote><ul><li>当<code>ctrl+f5</code>强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当<code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;a href=&quot;#一、浏览器缓存基本认识&quot; class=&quot;headerlink&quot; title=&quot;一、浏览器缓存基本认识&quot;&gt;&lt;/a&gt;一、浏览器缓存基本认识&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;分为强缓存和协商缓存&lt;/strong&gt;&lt;/p&gt;
&lt;o</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>浏览器安全插箱跨域</title>
    <link href="http://example.com/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/"/>
    <id>http://example.com/2021/04/29/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8%E6%8F%92%E7%AE%B1%E8%B7%A8%E5%9F%9F/</id>
    <published>2021-04-29T07:31:05.000Z</published>
    <updated>2022-06-07T00:36:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是跨域？</strong></p><ul><li>概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域</li></ul><p><strong>下面是具体的跨域情况详解</strong></p><table><thead><tr><th align="left">URL</th><th align="left">说明</th><th align="left">是否允许通信</th></tr></thead><tbody><tr><td align="left"><a href="http://www.a.com/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com/a.js、http://www.a.com/b.js</a></td><td align="left">同一域名下</td><td align="left">允许</td></tr><tr><td align="left"><a href="http://www.a.com/lab/a.js%E3%80%81http://www.a.com/script/b.js">http://www.a.com/lab/a.js、http://www.a.com/script/b.js</a></td><td align="left">同一域名下不同文件夹</td><td align="left">允许</td></tr><tr><td align="left"><a href="http://www.a.com:8000/a.js%E3%80%81http://www.a.com/b.js">http://www.a.com:8000/a.js、http://www.a.com/b.js</a></td><td align="left">同一域名，不同端口</td><td align="left">不允许</td></tr><tr><td align="left"><a href="http://www.a.com/a.js%E3%80%81https://www.a.com/b.js">http://www.a.com/a.js、https://www.a.com/b.js</a></td><td align="left">同一域名，不同协议</td><td align="left">不允许</td></tr><tr><td align="left"><a href="http://www.a.com/a.js%E3%80%81http://70.32.92.74/b.js">http://www.a.com/a.js、http://70.32.92.74/b.js</a></td><td align="left">域名和域名对应ip</td><td align="left">不允许</td></tr><tr><td align="left"><a href="http://www.a.com/a.js%E3%80%81http://script.a.com/b.js">http://www.a.com/a.js、http://script.a.com/b.js</a></td><td align="left">主域相同，子域不同</td><td align="left">不允许（cookie这种情况下也不允许访问）</td></tr><tr><td align="left"><a href="http://www.a.com/a.js%E3%80%81http://a.com/b.js">http://www.a.com/a.js、http://a.com/b.js</a></td><td align="left">同一域名，不同二级域名（同上）</td><td align="left">不允许（cookie这种情况下也不允许访问）</td></tr><tr><td align="left"><a href="http://www.cnblogs.com/a.js%E3%80%81http://www.a.com/b.js">http://www.cnblogs.com/a.js、http://www.a.com/b.js</a></td><td align="left">不同域名</td><td align="left">不允许</td></tr></tbody></table><h2 id="一、document-domain跨域"><a href="#一、document-domain跨域" class="headerlink" title="一、document.domain跨域"></a>一、document.domain跨域</h2><hr><ul><li>原理：相同主域名不同子域名下的页面，可以设置<code>document.domain</code>让它们同域</li><li>限制：同域<code>document</code>提供的是页面间的互操作，需要载入<code>iframe</code>页面</li></ul><blockquote><p>下面几个域名下的页面都是可以通过<code>document.domain</code>跨域互操作的： <code>http://a.com/foo</code>, <code>http://b.a.com/bar</code>, <code>http://c.a.com/bar</code>。 但只能以页面嵌套的方式来进行页面互操作，比如常见的<code>iframe</code>方式就可以完成页面嵌套</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// URL http://a.com/foo</span><br><span class="line">var ifr = document.createElement(&#x27;iframe&#x27;);</span><br><span class="line">ifr.src = &#x27;http://b.a.com/bar&#x27;; </span><br><span class="line">ifr.onload = function()&#123;</span><br><span class="line">    var ifrdoc = ifr.contentDocument || ifr.contentWindow.document;</span><br><span class="line">    ifrdoc.getElementsById(&quot;foo&quot;).innerHTML);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ifr.style.display = &#x27;none&#x27;;</span><br><span class="line">document.body.appendChild(ifr);</span><br></pre></td></tr></table></figure><ul><li>上述代码所在的<code>URL</code>是<code>http://a.com/foo</code>，它对<code>http://b.a.com/bar</code>的<code>DOM</code>访问要求后者将 <code>document.domain</code>往上设置一级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// URL http://b.a.com/bar</span><br><span class="line">document.domain = &#x27;a.com&#x27;</span><br></pre></td></tr></table></figure><ul><li><code>document.domain</code>只能从子域设置到主域，往下设置以及往其他域名设置都是不允许的， 在<code>Chrome</code>中给出的错误是这样的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught DOMException: Failed to set the &#x27;domain&#x27; property on &#x27;Document&#x27;: &#x27;baidu.com&#x27; is not a suffix of &#x27;b.a.com&#x27;</span><br></pre></td></tr></table></figure><h2 id="二、有src的标签"><a href="#二、有src的标签" class="headerlink" title="二、有src的标签"></a>二、有src的标签</h2><hr><ul><li>原理：所有具有<code>src</code>属性的<code>HTML</code>标签都是可以跨域的，包括<code>, </code></li><li>限制：需要创建一个<code>DOM</code>对象，只能用于<code>GET</code>方法</li></ul><blockquote><ul><li>在<code>document.body</code>中<code>append</code>一个具有<code>src</code>属性的<code>HTML</code>标签， <code>src</code>属性值指向的<code>URL</code>会以<code>GET</code>方法被访问，该访问是可以跨域的</li><li>其实样式表的&#96;&#96;标签也是可以跨域的，只要是有<code>src</code>或<code>href</code>的<code>HTML</code>标签都有跨域的能力</li></ul></blockquote><ul><li>不同的<code>HTML</code>标签发送<code>HTTP</code>请求的时机不同，例如&#96;&#96;在更改<code>src</code>属性时就会发送请求，而<code>script</code>, <code>iframe</code>, <code>link[rel=stylesheet]</code>只有在添加到<code>DOM</code>树之后才会发送<code>HTTP</code>请求：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var img = new Image();</span><br><span class="line">img.src = &#x27;http://some/picture&#x27;;        // 发送HTTP请求</span><br><span class="line"></span><br><span class="line">var ifr = $(&#x27;&lt;iframe&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);</span><br><span class="line">$(&#x27;body&#x27;).append(ifr);                  // 发送HTTP请求</span><br></pre></td></tr></table></figure><h2 id="三、JSONP"><a href="#三、JSONP" class="headerlink" title="三、JSONP"></a>三、JSONP</h2><hr><ul><li>原理：&#96;&#96;是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数</li><li>限制：需要创建一个<code>DOM</code>对象并且添加到<code>DOM</code>树，只能用于<code>GET</code>方法</li></ul><blockquote><p><code>JSONP</code>利用的是&#96;&#96;可以跨域的特性，跨域<code>URL</code>返回的脚本不仅包含数据，还包含一个回调</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://b.a.com/foo</span><br><span class="line">var data = &#123;</span><br><span class="line">    foo: &#x27;bar&#x27;,</span><br><span class="line">    bar: &#x27;foo&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">callback(data);</span><br></pre></td></tr></table></figure><ul><li>然后在我们在主站<code>http://a.com</code>中，可以这样来跨域获取<code>http://b.a.com</code>的数据：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://a.com/foo</span><br><span class="line">var callback = function(data)&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;;</span><br><span class="line">var script = $(&#x27;&lt;script&gt;&#x27;, &#123;src: &#x27;http://b.a.com/bar&#x27;&#125;);</span><br><span class="line">$(&#x27;body&#x27;).append(script);</span><br></pre></td></tr></table></figure><ul><li>其实<code>jQuery</code>已经封装了<code>JSONP</code>的使用，我们可以这样来</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data )&#123;</span><br><span class="line">    // 处理跨域请求得到的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><code>$.getJSON</code>与<code>$.get</code>的区别是前者会把<code>responseText</code>转换为<code>JSON</code>，而且当<code>URL</code>具有<code>callback</code>参数时， <code>jQuery</code>将会把它解释为一个<code>JSONP</code>请求，创建一个&#96;&#96;标签来完成该请求</p></blockquote><h2 id="四、navigation-对象"><a href="#四、navigation-对象" class="headerlink" title="四、navigation 对象"></a>四、navigation 对象</h2><hr><ul><li>原理：<code>iframe</code>之间是共享<code>navigator</code>对象的，用它来传递信息</li><li>要求：<code>IE6/7</code></li></ul><blockquote><p>有些人注意到了<code>IE6/7</code>的一个漏洞：<code>iframe</code>之间的<code>window.navigator</code>对象是共享的。 我们可以把它作为一个<code>Messenger</code>，通过它来传递信息。比如一个简单的委托：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// a.com</span><br><span class="line">navigation.onData()&#123;</span><br><span class="line">    // 数据到达的处理函数</span><br><span class="line">&#125;</span><br><span class="line">typeof navigation.getData === &#x27;function&#x27; </span><br><span class="line">    || navigation.getData()</span><br><span class="line">// b.com</span><br><span class="line">navigation.getData = function()&#123;</span><br><span class="line">    $.get(&#x27;/path/under/b.com&#x27;)</span><br><span class="line">        .success(function(data)&#123;</span><br><span class="line">            typeof navigation.onData === &#x27;function&#x27;</span><br><span class="line">                || navigation.onData(data)</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与<code>document.navigator</code>类似，<code>window.name</code>也是当前窗口所有页面所共享的。也可以用它来传递信息。 同样蛋疼的办法还有传递<code>Hash</code>（有些人叫锚点），这是因为每次浏览器打开一个<code>URL</code>时，<code>URL</code>后面的<code>#xxx</code>部分会保留下来，那么新的页面可以从这里获得上一个页面的数据</p></blockquote><h2 id="五、跨域资源共享（CORS）"><a href="#五、跨域资源共享（CORS）" class="headerlink" title="五、跨域资源共享（CORS）"></a>五、跨域资源共享（CORS）</h2><hr><ul><li>原理：服务器设置<code>Access-Control-Allow-OriginHTTP</code>响应头之后，浏览器将会允许跨域请求</li><li>限制：浏览器需要支持<code>HTML5</code>，可以支持<code>POST</code>，<code>PUT</code>等方法</li></ul><blockquote><p>前面提到的跨域手段都是某种意义上的<code>Hack</code>， <code>HTML5</code>标准中提出的跨域资源共享（<code>Cross Origin Resource Share</code>，<code>CORS</code>）才是正道。 它支持其他的<code>HTTP</code>方法如<code>PUT</code>, <code>POST</code>等，可以从本质上解决跨域问题。</p></blockquote><ul><li>例如，从<code>http://a.com</code>要访问<code>http://b.com</code>的数据，通常情况下<code>Chrome</code>会因跨域请求而报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://b.com. No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;http://a.com&#x27; is therefore not allowed access</span><br></pre></td></tr></table></figure><ul><li>错误原因是被请求资源没有设置<code>Access-Control-Allow-Origin</code>，所以我们在<code>b.com</code>的服务器中设置这个响应头字段即可</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *              # 允许所有域名访问，或者</span><br><span class="line">Access-Control-Allow-Origin: http://a.com   # 只允许所有域名访问</span><br></pre></td></tr></table></figure><h2 id="六、window-postMessage"><a href="#六、window-postMessage" class="headerlink" title="六、window.postMessage"></a>六、window.postMessage</h2><hr><ul><li>原理：<code>HTML5</code>允许窗口之间发送消息</li><li>限制：浏览器需要支持<code>HTML5</code>，获取窗口句柄后才能相互通信</li></ul><blockquote><p>这是一个安全的跨域通信方法，<code>postMessage(message,targetOrigin)</code>也是<code>HTML5</code>引入的特性。 可以给任何一个<code>window</code>发送消息，不论是否同源。第二个参数可以是*但如果你设置了一个<code>URL</code>但不相符，那么该事件不会被分发。看一个普通的使用方式吧</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// URL: http://a.com/foo</span><br><span class="line">var win = window.open(&#x27;http://b.com/bar&#x27;);</span><br><span class="line">win.postMessage(&#x27;Hello, bar!&#x27;, &#x27;http://b.com&#x27;);</span><br><span class="line">// URL: http://b.com/bar</span><br><span class="line">window.addEventListener(&#x27;message&#x27;,function(event) &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="七、访问控制安全的讨论"><a href="#七、访问控制安全的讨论" class="headerlink" title="七、访问控制安全的讨论"></a>七、访问控制安全的讨论</h2><hr><ul><li>在<code>HTML5</code>之前，<code>JSONP</code>已经成为跨域的事实标准了，<code>jQuery</code>都给出了支持。 值得注意的是它只是<code>Hack</code>，并没有产生额外的安全问题。 因为<code>JSONP</code>要成功获取数据，需要跨域资源所在服务器的配合，比如资源所在服务器需要自愿地回调一个合适的函数，所以服务器仍然有能力控制资源的跨域访问</li><li>跨域的正道还是要使用<code>HTML5</code>提供的CORS头字段以及<code>window.postMessage</code>， 可以支持<code>POST</code>, <code>PUT</code>等<code>HTTP</code>方法，从机制上解决跨域问题。 值得注意的是<code>Access-Control-Allow-Origin</code>头字段是资源所在服务器设置的， 访问控制的责任仍然是在提供资源的服务器一方，这和<code>JSONP</code>是一样的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;什么是跨域？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;下面是具体的跨域情况详解&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr</summary>
      
    
    
    
    <category term="浏览器" scheme="http://example.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
    <category term="浏览器" scheme="http://example.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler 抓包分析</title>
    <link href="http://example.com/2021/04/24/%E8%B0%83%E8%AF%95/Fiddler%E6%8A%93%E5%8C%85/"/>
    <id>http://example.com/2021/04/24/%E8%B0%83%E8%AF%95/Fiddler%E6%8A%93%E5%8C%85/</id>
    <published>2021-04-24T10:09:17.000Z</published>
    <updated>2022-06-07T00:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Fiddler简介"><a href="#一、Fiddler简介" class="headerlink" title="一、Fiddler简介"></a>一、Fiddler简介</h2><blockquote><p><code>Fiddler</code>是位于客户端和服务器端的<code>HTTP</code>代理，也是目前最常用的<code>http</code>抓包工具之一 。 它能够记录客户端和服务器之间的所有 <code>HTTP</code>请求，可以针对特定的<code>HTTP</code>请求，分析请求数据、设置断点、调试<code>web</code>应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是<code>web</code>调试的利器</p></blockquote><ul><li>客户端的所有请求都要先经过<code>Fiddler</code>，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过<code>Fiddler</code>然后发送到客户端</li><li>使用了<code>Fiddler</code>之后，web客户端和服务器的请求如下所示</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/187.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/188.png" alt="img"></p><p><strong>主界面中主要包括四个常用的块</strong></p><ul><li><code>Fiddler</code>的菜单栏，上图绿色部分。包括捕获<code>http</code>请求，停止捕获请求，保存<code>http</code>请求，载入本地<code>session</code>、设置捕获规则等功能。</li><li><code>Fiddler</code>的工具栏,上图红色部分。包括<code>Fiddler</code>针对当前<code>view</code>的操作（暂停，清除<code>session</code>,<code>decode</code>模式、清除缓存等）。</li><li><code>web Session</code>面板，上图黄色区域，主要是<code>Fiddler</code>抓取到的每条<code>http</code>请求（每一条称为一个<code>session</code>）,主要包含了请求的<code>url</code>，协议，状态码，<code>body</code>等信息，详细的字段含义如下图所示</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/189.png" alt="img"></p><h2 id="二、HTTP请求图标说明"><a href="#二、HTTP请求图标说明" class="headerlink" title="二、HTTP请求图标说明"></a>二、HTTP请求图标说明</h2><p><img src="https://poetries1.gitee.io/img-repo/2019/10/190.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/191.png" alt="img"></p><h2 id="三、Statistic"><a href="#三、Statistic" class="headerlink" title="三、Statistic"></a>三、Statistic</h2><blockquote><p>关于HTTP请求的性能和其他数据分析</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/192.png" alt="img"></p><blockquote><p>我们可以从中看出一些基本性能数据：如DNS解析的时间消耗是<code>8ms</code>,建立<code>TCP/IP</code>连接的时间消耗是<code>8ms</code>等等信息</p></blockquote><h2 id="四、Inspectors"><a href="#四、Inspectors" class="headerlink" title="四、Inspectors"></a>四、Inspectors</h2><blockquote><p>分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。</p></blockquote><ul><li>JPG 格式使用 ImageView 就可以看到图片</li><li>HTML&#x2F;JS&#x2F;CSS 使用 TextView可以看到响应的内容。</li><li>Raw标签可以查看原始的符合HTTP标准的请求和响应头。</li><li>Auth则可以查看授权Proxy-Authorization 和 Authorization的相关信息。</li><li>Cookies标签可以看到请求的cookie和响应的set-cookie头信息</li></ul><h2 id="五、Composer"><a href="#五、Composer" class="headerlink" title="五、Composer"></a>五、Composer</h2><blockquote><p>老版本的<code>fiddler</code>中叫<code>request-builder</code>.顾名思义，可以构建相应的请求，有两种常用的方式构建请求</p></blockquote><ul><li><code>Parsed 输入请求的url之后</code>executed<code>即可，也可以修改相应的头信息（如添加常用的</code>accept<code>,</code>host<code>,</code>referrer<code>,</code>cookie<code>，</code>cache-control<code>等头部）后</code>execute&#96;.</li><li><code>Raw</code>。使用HTTP头部信息构建<code>http</code>请求。与上类似</li></ul><h2 id="六、fiddler过滤会话"><a href="#六、fiddler过滤会话" class="headerlink" title="六、fiddler过滤会话"></a>六、fiddler过滤会话</h2><blockquote><p>问题：每次使用<code>Fiddler</code>,<br>打开一个网站，都能在<code>Fiddler</code>中看到几十个会话，看得眼花缭乱。</p></blockquote><ul><li>期望：只想抓取自己想要的请求</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/193.png" alt="img"></p><h2 id="七、Response乱码时的处理方法"><a href="#七、Response乱码时的处理方法" class="headerlink" title="七、Response乱码时的处理方法"></a>七、Response乱码时的处理方法</h2><blockquote><p>问题：有时候我们看到<code>Response</code>中的<code>HTML</code>是乱码的， 这是因为<code>HTML</code>被压缩了， 我们可以通过两种方法去解压缩</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/194.png" alt="img"></p><ul><li>方法二：选中工具栏中的”Decode”。 这样会自动解压缩</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/195.png" alt="img"></p><h2 id="八、反向代理-AutoResponder"><a href="#八、反向代理-AutoResponder" class="headerlink" title="八、反向代理-AutoResponder"></a>八、反向代理-AutoResponder</h2><blockquote><p>原理：利用<code>fiddler</code>作為反向代理。意思就是将外界的<code>request</code>请求端口修改掉！ 改写返回数据，最实用的功能</p></blockquote><ul><li>用浏览器随意输入一个网址，如<code>http://www.baidu.com/</code></li><li>选中序号<code>16</code>记录，右击-勾选<code>“Unlock fo Editing”</code>,选择<code>Fiddler</code>右侧<code>reponse</code>块下的<code>TextView</code>，这里修改<code>title</code>,如图：</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/196.png" alt="img"></p><ul><li>选择<code>Fiddler</code>右侧<code>reponse</code>块下的<code>TextView</code>，这里修改<code>title</code>,如图：</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/197.png" alt="img"></p><ul><li>去掉<code>“Unlock for Editing”</code>，再选择右侧上方的<code>AutoResponder</code>,勾选下方的<code>checkbox</code>选框，并将序号<code>16</code>托到下方，同时，里面会多条记录，如下图：</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/198.png" alt="img"></p><ul><li>回到浏览器，刷新页面，如图，标题变为上面改的内容</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/199.png" alt="img"></p><h2 id="九、fiddler提供了一个功能，让我们模拟低速网路环境"><a href="#九、fiddler提供了一个功能，让我们模拟低速网路环境" class="headerlink" title="九、fiddler提供了一个功能，让我们模拟低速网路环境"></a>九、fiddler提供了一个功能，让我们模拟低速网路环境</h2><blockquote><p>启用方法如：Rules → Performances → Simulate Modem Speeds</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/200.png" alt="img"></p><h2 id="十、直接在fiddler上配置host"><a href="#十、直接在fiddler上配置host" class="headerlink" title="十、直接在fiddler上配置host"></a>十、直接在fiddler上配置host</h2><blockquote><p>点击<code>tools&gt;&gt;hosts</code>,在里面填写自己想要设置的<code>host</code>即可</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/201.png" alt="img"></p><h2 id="十一、Fiddler显示请求服务器的ip及系统环境的配置方法"><a href="#十一、Fiddler显示请求服务器的ip及系统环境的配置方法" class="headerlink" title="十一、Fiddler显示请求服务器的ip及系统环境的配置方法"></a>十一、Fiddler显示请求服务器的ip及系统环境的配置方法</h2><ul><li>打开<code>Rules——&gt;Customize Rules</code></li><li>找到如下这段代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static function Main()</span><br><span class="line">&#123;</span><br><span class="line">var today: Date = new Date();</span><br><span class="line">FiddlerObject.StatusText = &quot; CustomRules.js was loaded at: &quot; + today;</span><br><span class="line">// Uncomment to add a &quot;Server&quot; column containing the response &quot;Server&quot; header, if present</span><br><span class="line"></span><br><span class="line">在这一行后面添加如下代码：</span><br><span class="line"></span><br><span class="line">// 显示服务器web环境</span><br><span class="line">FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;Server&quot;, 50, &quot;@response.server&quot;);</span><br><span class="line">// 显示服务器IP地址</span><br><span class="line">FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;HostIP&quot;, 50, &quot;x-hostIP&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置后重启<code>fiddler</code>，效果如下</li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/202.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/203.png" alt="img"></p><h2 id="十二、fiddler断点调试"><a href="#十二、fiddler断点调试" class="headerlink" title="十二、fiddler断点调试"></a>十二、fiddler断点调试</h2><blockquote><p>第一种方法：菜单栏 <code>Rules</code> –》 <code>Automatic Breakpoints</code> –》 <code>Before Requests</code>(请求被发送到服务器端之前)；或者 <code>After Responses</code>(响应返回客户端之前)，这种设置对客户机发出的所有请求都进行拦截</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/204.png" alt="img"><br><img src="https://poetries1.gitee.io/img-repo/2019/10/205.png" alt="img"></p><h2 id="十三、配合SwitchySharp插件使用"><a href="#十三、配合SwitchySharp插件使用" class="headerlink" title="十三、配合SwitchySharp插件使用"></a>十三、配合SwitchySharp插件使用</h2><blockquote><p>为<code>fiddler</code>创建一个规则，代理到本地的<code>8888</code>端口（<code>fiddler</code>所用的端口）<br><code>google</code>设置代理的方法：下载<code>SwitchySharp</code>插件，设置如下：</p></blockquote><p><img src="https://poetries1.gitee.io/img-repo/2019/10/206.png" alt="img"></p><ul><li>接着点击保存即可~ 这样在需要的时候可以切换到<code>Fiddler</code></li></ul><p><img src="https://poetries1.gitee.io/img-repo/2019/10/207.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Fiddler简介&quot;&gt;&lt;a href=&quot;#一、Fiddler简介&quot; class=&quot;headerlink&quot; title=&quot;一、Fiddler简介&quot;&gt;&lt;/a&gt;一、Fiddler简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Fiddler&lt;/code&gt;是</summary>
      
    
    
    
    <category term="爬虫" scheme="http://example.com/categories/%E7%88%AC%E8%99%AB/"/>
    
    
    <category term="抓包" scheme="http://example.com/tags/%E6%8A%93%E5%8C%85/"/>
    
  </entry>
  
</feed>
